// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/sending/transfer.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/dydxprotocol/v4/x/subaccounts/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Transfer represents a single transfer between two subaccounts.
type Transfer struct {
	// The sender subaccount ID.
	Sender types.SubaccountId `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender"`
	// The recipient subaccount ID.
	Recipient types.SubaccountId `protobuf:"bytes,2,opt,name=recipient,proto3" json:"recipient"`
	// Id of the asset to transfer.
	AssetId uint32 `protobuf:"varint,3,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The amount of asset to transfer
	Amount uint64 `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *Transfer) Reset()         { *m = Transfer{} }
func (m *Transfer) String() string { return proto.CompactTextString(m) }
func (*Transfer) ProtoMessage()    {}
func (*Transfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ef1d018df19de71, []int{0}
}
func (m *Transfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transfer.Merge(m, src)
}
func (m *Transfer) XXX_Size() int {
	return m.Size()
}
func (m *Transfer) XXX_DiscardUnknown() {
	xxx_messageInfo_Transfer.DiscardUnknown(m)
}

var xxx_messageInfo_Transfer proto.InternalMessageInfo

func (m *Transfer) GetSender() types.SubaccountId {
	if m != nil {
		return m.Sender
	}
	return types.SubaccountId{}
}

func (m *Transfer) GetRecipient() types.SubaccountId {
	if m != nil {
		return m.Recipient
	}
	return types.SubaccountId{}
}

func (m *Transfer) GetAssetId() uint32 {
	if m != nil {
		return m.AssetId
	}
	return 0
}

func (m *Transfer) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// MsgDepositToSubaccount represents a single transfer from an `x/bank`
// account to an `x/subaccounts` subaccount.
type MsgDepositToSubaccount struct {
	// The sender wallet address.
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// The recipient subaccount ID.
	Recipient types.SubaccountId `protobuf:"bytes,2,opt,name=recipient,proto3" json:"recipient"`
	// Id of the asset to transfer.
	AssetId uint32 `protobuf:"varint,3,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The number of quantums of asset to transfer.
	Quantums uint64 `protobuf:"varint,4,opt,name=quantums,proto3" json:"quantums,omitempty"`
}

func (m *MsgDepositToSubaccount) Reset()         { *m = MsgDepositToSubaccount{} }
func (m *MsgDepositToSubaccount) String() string { return proto.CompactTextString(m) }
func (*MsgDepositToSubaccount) ProtoMessage()    {}
func (*MsgDepositToSubaccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ef1d018df19de71, []int{1}
}
func (m *MsgDepositToSubaccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositToSubaccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositToSubaccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositToSubaccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositToSubaccount.Merge(m, src)
}
func (m *MsgDepositToSubaccount) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositToSubaccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositToSubaccount.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositToSubaccount proto.InternalMessageInfo

func (m *MsgDepositToSubaccount) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgDepositToSubaccount) GetRecipient() types.SubaccountId {
	if m != nil {
		return m.Recipient
	}
	return types.SubaccountId{}
}

func (m *MsgDepositToSubaccount) GetAssetId() uint32 {
	if m != nil {
		return m.AssetId
	}
	return 0
}

func (m *MsgDepositToSubaccount) GetQuantums() uint64 {
	if m != nil {
		return m.Quantums
	}
	return 0
}

// MsgWithdrawFromSubaccount represents a single transfer from an
// `x/subaccounts` subaccount to an `x/bank` account.
type MsgWithdrawFromSubaccount struct {
	// The sender subaccount ID.
	Sender types.SubaccountId `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender"`
	// The recipient wallet address.
	Recipient string `protobuf:"bytes,1,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// Id of the asset to transfer.
	AssetId uint32 `protobuf:"varint,3,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The number of quantums of asset to transfer.
	Quantums uint64 `protobuf:"varint,4,opt,name=quantums,proto3" json:"quantums,omitempty"`
}

func (m *MsgWithdrawFromSubaccount) Reset()         { *m = MsgWithdrawFromSubaccount{} }
func (m *MsgWithdrawFromSubaccount) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawFromSubaccount) ProtoMessage()    {}
func (*MsgWithdrawFromSubaccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ef1d018df19de71, []int{2}
}
func (m *MsgWithdrawFromSubaccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawFromSubaccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawFromSubaccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawFromSubaccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawFromSubaccount.Merge(m, src)
}
func (m *MsgWithdrawFromSubaccount) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawFromSubaccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawFromSubaccount.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawFromSubaccount proto.InternalMessageInfo

func (m *MsgWithdrawFromSubaccount) GetSender() types.SubaccountId {
	if m != nil {
		return m.Sender
	}
	return types.SubaccountId{}
}

func (m *MsgWithdrawFromSubaccount) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgWithdrawFromSubaccount) GetAssetId() uint32 {
	if m != nil {
		return m.AssetId
	}
	return 0
}

func (m *MsgWithdrawFromSubaccount) GetQuantums() uint64 {
	if m != nil {
		return m.Quantums
	}
	return 0
}

func init() {
	proto.RegisterType((*Transfer)(nil), "dydxprotocol.sending.Transfer")
	proto.RegisterType((*MsgDepositToSubaccount)(nil), "dydxprotocol.sending.MsgDepositToSubaccount")
	proto.RegisterType((*MsgWithdrawFromSubaccount)(nil), "dydxprotocol.sending.MsgWithdrawFromSubaccount")
}

func init() {
	proto.RegisterFile("dydxprotocol/sending/transfer.proto", fileDescriptor_6ef1d018df19de71)
}

var fileDescriptor_6ef1d018df19de71 = []byte{
	// 396 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0x4e, 0xa9, 0x4c, 0xa9,
	0x28, 0x28, 0xca, 0x2f, 0xc9, 0x4f, 0xce, 0xcf, 0xd1, 0x2f, 0x4e, 0xcd, 0x4b, 0xc9, 0xcc, 0x4b,
	0xd7, 0x2f, 0x29, 0x4a, 0xcc, 0x2b, 0x4e, 0x4b, 0x2d, 0xd2, 0x03, 0xcb, 0x08, 0x89, 0x20, 0x2b,
	0xd2, 0x83, 0x2a, 0x92, 0x92, 0x4c, 0xce, 0x2f, 0xce, 0xcd, 0x2f, 0x8e, 0x07, 0x4b, 0xe8, 0x43,
	0x38, 0x10, 0x0d, 0x52, 0xe2, 0x10, 0x9e, 0x7e, 0x6e, 0x71, 0xba, 0x7e, 0x99, 0x21, 0x88, 0x82,
	0x4a, 0x88, 0xa4, 0xe7, 0xa7, 0xe7, 0x43, 0x34, 0x80, 0x58, 0x50, 0x51, 0x4d, 0x54, 0x47, 0x94,
	0x26, 0x25, 0x26, 0x27, 0xe7, 0x97, 0xe6, 0x95, 0x14, 0x23, 0xb1, 0x21, 0x4a, 0x95, 0xce, 0x33,
	0x72, 0x71, 0x84, 0x40, 0x5d, 0x27, 0xe4, 0xc2, 0xc5, 0x06, 0x72, 0x4c, 0x6a, 0x91, 0x04, 0xa3,
	0x02, 0xa3, 0x06, 0xb7, 0x91, 0x9a, 0x1e, 0xaa, 0x43, 0x11, 0x06, 0xe9, 0x05, 0xc3, 0xd9, 0x9e,
	0x29, 0x4e, 0x2c, 0x27, 0xee, 0xc9, 0x33, 0x04, 0x41, 0xf5, 0x0a, 0x79, 0x71, 0x71, 0x16, 0xa5,
	0x26, 0x67, 0x16, 0x64, 0xa6, 0xe6, 0x95, 0x48, 0x30, 0x91, 0x61, 0x10, 0x42, 0xbb, 0x90, 0x24,
	0x17, 0x47, 0x62, 0x71, 0x71, 0x6a, 0x49, 0x7c, 0x66, 0x8a, 0x04, 0xb3, 0x02, 0xa3, 0x06, 0x6f,
	0x10, 0x3b, 0x98, 0xef, 0x99, 0x22, 0x24, 0xc6, 0xc5, 0x96, 0x98, 0x0b, 0xd2, 0x27, 0xc1, 0xa2,
	0xc0, 0xa8, 0xc1, 0x12, 0x04, 0xe5, 0x29, 0xdd, 0x62, 0xe4, 0x12, 0xf3, 0x2d, 0x4e, 0x77, 0x49,
	0x2d, 0xc8, 0x2f, 0xce, 0x2c, 0x09, 0xc9, 0x47, 0x58, 0x20, 0x64, 0x80, 0xe2, 0x3f, 0x4e, 0x27,
	0x89, 0x4b, 0x5b, 0x74, 0x45, 0xa0, 0x01, 0xed, 0x98, 0x92, 0x52, 0x94, 0x5a, 0x5c, 0x1c, 0x5c,
	0x52, 0x94, 0x99, 0x97, 0x4e, 0x6f, 0xbf, 0x48, 0x71, 0x71, 0x14, 0x96, 0x26, 0xe6, 0x95, 0x94,
	0xe6, 0x16, 0x43, 0x7d, 0x03, 0xe7, 0x5b, 0x71, 0x37, 0x3d, 0xdf, 0xa0, 0x05, 0x75, 0x8f, 0xd2,
	0x05, 0x46, 0x2e, 0x49, 0xdf, 0xe2, 0xf4, 0xf0, 0xcc, 0x92, 0x8c, 0x94, 0xa2, 0xc4, 0x72, 0xb7,
	0xa2, 0xfc, 0x5c, 0x24, 0xff, 0x21, 0xe2, 0x8f, 0x89, 0x82, 0xf8, 0x33, 0x43, 0xf6, 0x33, 0xa1,
	0x80, 0xa2, 0xd8, 0x7f, 0x4e, 0x2e, 0x27, 0x1e, 0xc9, 0x31, 0x5e, 0x78, 0x24, 0xc7, 0xf8, 0xe0,
	0x91, 0x1c, 0xe3, 0x84, 0xc7, 0x72, 0x0c, 0x17, 0x1e, 0xcb, 0x31, 0xdc, 0x78, 0x2c, 0xc7, 0x10,
	0xa5, 0x95, 0x9e, 0x59, 0x92, 0x51, 0x9a, 0xa4, 0x97, 0x9c, 0x9f, 0xab, 0x8f, 0x92, 0xa2, 0xcb,
	0x4c, 0xf4, 0x2b, 0x10, 0x79, 0xab, 0xb2, 0x20, 0xb5, 0x38, 0x89, 0x0d, 0x2c, 0x69, 0x0c, 0x08,
	0x00, 0x00, 0xff, 0xff, 0xf5, 0x8f, 0x93, 0x3e, 0x80, 0x03, 0x00, 0x00,
}

func (m *Transfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintTransfer(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x20
	}
	if m.AssetId != 0 {
		i = encodeVarintTransfer(dAtA, i, uint64(m.AssetId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Recipient.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTransfer(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTransfer(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgDepositToSubaccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositToSubaccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositToSubaccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantums != 0 {
		i = encodeVarintTransfer(dAtA, i, uint64(m.Quantums))
		i--
		dAtA[i] = 0x20
	}
	if m.AssetId != 0 {
		i = encodeVarintTransfer(dAtA, i, uint64(m.AssetId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Recipient.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTransfer(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTransfer(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawFromSubaccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawFromSubaccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawFromSubaccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantums != 0 {
		i = encodeVarintTransfer(dAtA, i, uint64(m.Quantums))
		i--
		dAtA[i] = 0x20
	}
	if m.AssetId != 0 {
		i = encodeVarintTransfer(dAtA, i, uint64(m.AssetId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTransfer(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTransfer(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransfer(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransfer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Transfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Sender.Size()
	n += 1 + l + sovTransfer(uint64(l))
	l = m.Recipient.Size()
	n += 1 + l + sovTransfer(uint64(l))
	if m.AssetId != 0 {
		n += 1 + sovTransfer(uint64(m.AssetId))
	}
	if m.Amount != 0 {
		n += 1 + sovTransfer(uint64(m.Amount))
	}
	return n
}

func (m *MsgDepositToSubaccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTransfer(uint64(l))
	}
	l = m.Recipient.Size()
	n += 1 + l + sovTransfer(uint64(l))
	if m.AssetId != 0 {
		n += 1 + sovTransfer(uint64(m.AssetId))
	}
	if m.Quantums != 0 {
		n += 1 + sovTransfer(uint64(m.Quantums))
	}
	return n
}

func (m *MsgWithdrawFromSubaccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTransfer(uint64(l))
	}
	l = m.Sender.Size()
	n += 1 + l + sovTransfer(uint64(l))
	if m.AssetId != 0 {
		n += 1 + sovTransfer(uint64(m.AssetId))
	}
	if m.Quantums != 0 {
		n += 1 + sovTransfer(uint64(m.Quantums))
	}
	return n
}

func sovTransfer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransfer(x uint64) (n int) {
	return sovTransfer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Transfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Recipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			m.AssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransfer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositToSubaccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositToSubaccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositToSubaccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Recipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			m.AssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantums", wireType)
			}
			m.Quantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransfer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawFromSubaccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawFromSubaccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawFromSubaccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			m.AssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantums", wireType)
			}
			m.Quantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransfer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransfer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransfer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransfer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransfer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransfer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransfer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransfer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransfer = fmt.Errorf("proto: unexpected end of group")
)
