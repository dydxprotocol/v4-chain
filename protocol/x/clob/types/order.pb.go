// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/clob/order.proto

package types

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/dydxprotocol/v4/x/subaccounts/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Represents the side of the orderbook the order will be placed on.
// Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be
// placed on the orderbook.
type Order_Side int32

const (
	// Default value. This value is invalid and unused.
	Order_SIDE_UNSPECIFIED Order_Side = 0
	// SIDE_BUY is used to represent a BUY order.
	Order_SIDE_BUY Order_Side = 1
	// SIDE_SELL is used to represent a SELL order.
	Order_SIDE_SELL Order_Side = 2
)

var Order_Side_name = map[int32]string{
	0: "SIDE_UNSPECIFIED",
	1: "SIDE_BUY",
	2: "SIDE_SELL",
}

var Order_Side_value = map[string]int32{
	"SIDE_UNSPECIFIED": 0,
	"SIDE_BUY":         1,
	"SIDE_SELL":        2,
}

func (x Order_Side) String() string {
	return proto.EnumName(Order_Side_name, int32(x))
}

func (Order_Side) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{7, 0}
}

// TimeInForce indicates how long an order will remain active before it
// is executed or expires.
type Order_TimeInForce int32

const (
	// TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an
	// order will first match with existing orders on the book, and any
	// remaining size will be added to the book as a maker order.
	Order_TIME_IN_FORCE_UNSPECIFIED Order_TimeInForce = 0
	// TIME_IN_FORCE_IOC enforces that an order only be matched with
	// maker orders on the book. If the order has remaining size after
	// matching with existing orders on the book, the remaining size
	// is not placed on the book.
	Order_TIME_IN_FORCE_IOC Order_TimeInForce = 1
	// TIME_IN_FORCE_POST_ONLY enforces that an order only be placed
	// on the book as a maker order. Note this means that validators will cancel
	// any newly-placed post only orders that would cross with other maker
	// orders.
	Order_TIME_IN_FORCE_POST_ONLY Order_TimeInForce = 2
	// TIME_IN_FORCE_FILL_OR_KILL enforces that an order will either be filled
	// completely and immediately by maker orders on the book or canceled if the
	// entire amount canâ€˜t be matched.
	Order_TIME_IN_FORCE_FILL_OR_KILL Order_TimeInForce = 3
)

var Order_TimeInForce_name = map[int32]string{
	0: "TIME_IN_FORCE_UNSPECIFIED",
	1: "TIME_IN_FORCE_IOC",
	2: "TIME_IN_FORCE_POST_ONLY",
	3: "TIME_IN_FORCE_FILL_OR_KILL",
}

var Order_TimeInForce_value = map[string]int32{
	"TIME_IN_FORCE_UNSPECIFIED":  0,
	"TIME_IN_FORCE_IOC":          1,
	"TIME_IN_FORCE_POST_ONLY":    2,
	"TIME_IN_FORCE_FILL_OR_KILL": 3,
}

func (x Order_TimeInForce) String() string {
	return proto.EnumName(Order_TimeInForce_name, int32(x))
}

func (Order_TimeInForce) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{7, 1}
}

type Order_ConditionType int32

const (
	// CONDITION_TYPE_UNSPECIFIED represents the default behavior where an
	// order will be placed immediately on the orderbook.
	Order_CONDITION_TYPE_UNSPECIFIED Order_ConditionType = 0
	// CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will
	// trigger when the oracle price moves at or above the trigger price for
	// buys, and at or below the trigger price for sells.
	Order_CONDITION_TYPE_STOP_LOSS Order_ConditionType = 1
	// CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit
	// order will trigger when the oracle price moves at or below the trigger
	// price for buys and at or above the trigger price for sells.
	Order_CONDITION_TYPE_TAKE_PROFIT Order_ConditionType = 2
)

var Order_ConditionType_name = map[int32]string{
	0: "CONDITION_TYPE_UNSPECIFIED",
	1: "CONDITION_TYPE_STOP_LOSS",
	2: "CONDITION_TYPE_TAKE_PROFIT",
}

var Order_ConditionType_value = map[string]int32{
	"CONDITION_TYPE_UNSPECIFIED": 0,
	"CONDITION_TYPE_STOP_LOSS":   1,
	"CONDITION_TYPE_TAKE_PROFIT": 2,
}

func (x Order_ConditionType) String() string {
	return proto.EnumName(Order_ConditionType_name, int32(x))
}

func (Order_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{7, 2}
}

// OrderId refers to a single order belonging to a Subaccount.
type OrderId struct {
	// The subaccount ID that opened this order.
	// Note that this field has `gogoproto.nullable = false` so that it is
	// generated as a value instead of a pointer. This is because the `OrderId`
	// proto is used as a key within maps, and map comparisons will compare
	// pointers for equality (when the desired behavior is to compare the values).
	SubaccountId types.SubaccountId `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id"`
	// The client ID of this order, unique with respect to the specific
	// sub account (I.E., the same subaccount can't have two orders with
	// the same ClientId).
	ClientId uint32 `protobuf:"fixed32,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// order_flags represent order flags for the order. This field is invalid if
	// it's greater than 127 (larger than one byte). Each bit in the first byte
	// represents a different flag. Currently only two flags are supported.
	//
	// Starting from the bit after the most MSB (note that the MSB is used in
	// proto varint encoding, and therefore cannot be used): Bit 1 is set if this
	// order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this
	// order is a Conditional order (0x20, or 32 as a uint8).
	//
	// If neither bit is set, the order is assumed to be a Short-Term order.
	//
	// If both bits are set or bits other than the 2nd and 3rd are set, the order
	// ID is invalid.
	OrderFlags uint32 `protobuf:"varint,3,opt,name=order_flags,json=orderFlags,proto3" json:"order_flags,omitempty"`
	// ID of the CLOB the order is created for.
	ClobPairId uint32 `protobuf:"varint,4,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
}

func (m *OrderId) Reset()         { *m = OrderId{} }
func (m *OrderId) String() string { return proto.CompactTextString(m) }
func (*OrderId) ProtoMessage()    {}
func (*OrderId) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{0}
}
func (m *OrderId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderId.Merge(m, src)
}
func (m *OrderId) XXX_Size() int {
	return m.Size()
}
func (m *OrderId) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderId.DiscardUnknown(m)
}

var xxx_messageInfo_OrderId proto.InternalMessageInfo

func (m *OrderId) GetSubaccountId() types.SubaccountId {
	if m != nil {
		return m.SubaccountId
	}
	return types.SubaccountId{}
}

func (m *OrderId) GetClientId() uint32 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *OrderId) GetOrderFlags() uint32 {
	if m != nil {
		return m.OrderFlags
	}
	return 0
}

func (m *OrderId) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

// OrdersFilledDuringLatestBlock represents a list of `OrderIds` that were
// filled by any non-zero amount in the latest block.
type OrdersFilledDuringLatestBlock struct {
	// A list of unique order_ids that were filled by any non-zero amount in the
	// latest block.
	OrderIds []OrderId `protobuf:"bytes,1,rep,name=order_ids,json=orderIds,proto3" json:"order_ids"`
}

func (m *OrdersFilledDuringLatestBlock) Reset()         { *m = OrdersFilledDuringLatestBlock{} }
func (m *OrdersFilledDuringLatestBlock) String() string { return proto.CompactTextString(m) }
func (*OrdersFilledDuringLatestBlock) ProtoMessage()    {}
func (*OrdersFilledDuringLatestBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{1}
}
func (m *OrdersFilledDuringLatestBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrdersFilledDuringLatestBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrdersFilledDuringLatestBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrdersFilledDuringLatestBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrdersFilledDuringLatestBlock.Merge(m, src)
}
func (m *OrdersFilledDuringLatestBlock) XXX_Size() int {
	return m.Size()
}
func (m *OrdersFilledDuringLatestBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_OrdersFilledDuringLatestBlock.DiscardUnknown(m)
}

var xxx_messageInfo_OrdersFilledDuringLatestBlock proto.InternalMessageInfo

func (m *OrdersFilledDuringLatestBlock) GetOrderIds() []OrderId {
	if m != nil {
		return m.OrderIds
	}
	return nil
}

// PotentiallyPrunableOrders represents a list of orders that may be prunable
// from state at a future block height.
type PotentiallyPrunableOrders struct {
	// A list of unique order_ids that may potentially be pruned from state at a
	// future block height.
	OrderIds []OrderId `protobuf:"bytes,1,rep,name=order_ids,json=orderIds,proto3" json:"order_ids"`
}

func (m *PotentiallyPrunableOrders) Reset()         { *m = PotentiallyPrunableOrders{} }
func (m *PotentiallyPrunableOrders) String() string { return proto.CompactTextString(m) }
func (*PotentiallyPrunableOrders) ProtoMessage()    {}
func (*PotentiallyPrunableOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{2}
}
func (m *PotentiallyPrunableOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PotentiallyPrunableOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PotentiallyPrunableOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PotentiallyPrunableOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PotentiallyPrunableOrders.Merge(m, src)
}
func (m *PotentiallyPrunableOrders) XXX_Size() int {
	return m.Size()
}
func (m *PotentiallyPrunableOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_PotentiallyPrunableOrders.DiscardUnknown(m)
}

var xxx_messageInfo_PotentiallyPrunableOrders proto.InternalMessageInfo

func (m *PotentiallyPrunableOrders) GetOrderIds() []OrderId {
	if m != nil {
		return m.OrderIds
	}
	return nil
}

// OrderFillState represents the fill amount of an order according to on-chain
// state. This proto includes both the current on-chain fill amount of the
// order, as well as the block at which this information can be pruned from
// state.
type OrderFillState struct {
	// The current fillAmount of the order according to on-chain state.
	FillAmount uint64 `protobuf:"varint,1,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty"`
	// The block height at which the fillAmount state for this order can be
	// pruned.
	PrunableBlockHeight uint32 `protobuf:"varint,2,opt,name=prunable_block_height,json=prunableBlockHeight,proto3" json:"prunable_block_height,omitempty"`
}

func (m *OrderFillState) Reset()         { *m = OrderFillState{} }
func (m *OrderFillState) String() string { return proto.CompactTextString(m) }
func (*OrderFillState) ProtoMessage()    {}
func (*OrderFillState) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{3}
}
func (m *OrderFillState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFillState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFillState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFillState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFillState.Merge(m, src)
}
func (m *OrderFillState) XXX_Size() int {
	return m.Size()
}
func (m *OrderFillState) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFillState.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFillState proto.InternalMessageInfo

func (m *OrderFillState) GetFillAmount() uint64 {
	if m != nil {
		return m.FillAmount
	}
	return 0
}

func (m *OrderFillState) GetPrunableBlockHeight() uint32 {
	if m != nil {
		return m.PrunableBlockHeight
	}
	return 0
}

// StatefulOrderTimeSliceValue represents the type of the value of the
// `StatefulOrdersTimeSlice` in state. The `StatefulOrdersTimeSlice`
// in state consists of key/value pairs where the keys are UTF-8-encoded
// `RFC3339NANO` timestamp strings with right-padded zeroes and no
// time zone info, and the values are of type `StatefulOrderTimeSliceValue`.
// This `StatefulOrderTimeSliceValue` in state is used for managing stateful
// order expiration. Stateful order expirations can be for either long term
// or conditional orders.
type StatefulOrderTimeSliceValue struct {
	// A unique list of order_ids that expire at this timestamp, sorted in
	// ascending order by block height and transaction index of each stateful
	// order.
	OrderIds []OrderId `protobuf:"bytes,1,rep,name=order_ids,json=orderIds,proto3" json:"order_ids"`
}

func (m *StatefulOrderTimeSliceValue) Reset()         { *m = StatefulOrderTimeSliceValue{} }
func (m *StatefulOrderTimeSliceValue) String() string { return proto.CompactTextString(m) }
func (*StatefulOrderTimeSliceValue) ProtoMessage()    {}
func (*StatefulOrderTimeSliceValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{4}
}
func (m *StatefulOrderTimeSliceValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderTimeSliceValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderTimeSliceValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderTimeSliceValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderTimeSliceValue.Merge(m, src)
}
func (m *StatefulOrderTimeSliceValue) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderTimeSliceValue) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderTimeSliceValue.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderTimeSliceValue proto.InternalMessageInfo

func (m *StatefulOrderTimeSliceValue) GetOrderIds() []OrderId {
	if m != nil {
		return m.OrderIds
	}
	return nil
}

// LongTermOrderPlacement represents the placement of a stateful order in
// state. It stores the stateful order itself and the `BlockHeight` and
// `TransactionIndex` at which the order was placed.
type LongTermOrderPlacement struct {
	Order Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order"`
	// The block height and transaction index at which the order was placed.
	// Used for ordering by time priority when the chain is restarted.
	PlacementIndex TransactionOrdering `protobuf:"bytes,2,opt,name=placement_index,json=placementIndex,proto3" json:"placement_index"`
}

func (m *LongTermOrderPlacement) Reset()         { *m = LongTermOrderPlacement{} }
func (m *LongTermOrderPlacement) String() string { return proto.CompactTextString(m) }
func (*LongTermOrderPlacement) ProtoMessage()    {}
func (*LongTermOrderPlacement) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{5}
}
func (m *LongTermOrderPlacement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongTermOrderPlacement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongTermOrderPlacement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongTermOrderPlacement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongTermOrderPlacement.Merge(m, src)
}
func (m *LongTermOrderPlacement) XXX_Size() int {
	return m.Size()
}
func (m *LongTermOrderPlacement) XXX_DiscardUnknown() {
	xxx_messageInfo_LongTermOrderPlacement.DiscardUnknown(m)
}

var xxx_messageInfo_LongTermOrderPlacement proto.InternalMessageInfo

func (m *LongTermOrderPlacement) GetOrder() Order {
	if m != nil {
		return m.Order
	}
	return Order{}
}

func (m *LongTermOrderPlacement) GetPlacementIndex() TransactionOrdering {
	if m != nil {
		return m.PlacementIndex
	}
	return TransactionOrdering{}
}

// ConditionalOrderPlacement represents the placement of a conditional order in
// state. It stores the stateful order itself, the `BlockHeight` and
// `TransactionIndex` at which the order was placed and triggered.
type ConditionalOrderPlacement struct {
	Order Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order"`
	// The block height and transaction index at which the order was placed.
	PlacementIndex TransactionOrdering `protobuf:"bytes,2,opt,name=placement_index,json=placementIndex,proto3" json:"placement_index"`
	// The block height and transaction index at which the order was triggered.
	// Set to be nil if the transaction has not been triggered.
	// Used for ordering by time priority when the chain is restarted.
	TriggerIndex *TransactionOrdering `protobuf:"bytes,3,opt,name=trigger_index,json=triggerIndex,proto3" json:"trigger_index,omitempty"`
}

func (m *ConditionalOrderPlacement) Reset()         { *m = ConditionalOrderPlacement{} }
func (m *ConditionalOrderPlacement) String() string { return proto.CompactTextString(m) }
func (*ConditionalOrderPlacement) ProtoMessage()    {}
func (*ConditionalOrderPlacement) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{6}
}
func (m *ConditionalOrderPlacement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionalOrderPlacement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionalOrderPlacement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionalOrderPlacement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionalOrderPlacement.Merge(m, src)
}
func (m *ConditionalOrderPlacement) XXX_Size() int {
	return m.Size()
}
func (m *ConditionalOrderPlacement) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionalOrderPlacement.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionalOrderPlacement proto.InternalMessageInfo

func (m *ConditionalOrderPlacement) GetOrder() Order {
	if m != nil {
		return m.Order
	}
	return Order{}
}

func (m *ConditionalOrderPlacement) GetPlacementIndex() TransactionOrdering {
	if m != nil {
		return m.PlacementIndex
	}
	return TransactionOrdering{}
}

func (m *ConditionalOrderPlacement) GetTriggerIndex() *TransactionOrdering {
	if m != nil {
		return m.TriggerIndex
	}
	return nil
}

// Order represents a single order belonging to a `Subaccount`
// for a particular `ClobPair`.
type Order struct {
	// The unique ID of this order. Meant to be unique across all orders.
	OrderId OrderId    `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	Side    Order_Side `protobuf:"varint,2,opt,name=side,proto3,enum=dydxprotocol.clob.Order_Side" json:"side,omitempty"`
	// The size of this order in base quantums. Must be a multiple of
	// `ClobPair.StepBaseQuantums` and above `ClobPair.MinOrderBaseQuantums`
	// (where `ClobPair.Id = orderId.ClobPairId`).
	Quantums uint64 `protobuf:"varint,3,opt,name=quantums,proto3" json:"quantums,omitempty"`
	// The price level that this order will be placed at on the orderbook,
	// in subticks. Must be a multiple of ClobPair.SubticksPerTick
	// (where `ClobPair.Id = orderId.ClobPairId`).
	Subticks uint64 `protobuf:"varint,4,opt,name=subticks,proto3" json:"subticks,omitempty"`
	// Information about when the order expires.
	//
	// Types that are valid to be assigned to GoodTilOneof:
	//
	//	*Order_GoodTilBlock
	//	*Order_GoodTilBlockTime
	GoodTilOneof isOrder_GoodTilOneof `protobuf_oneof:"good_til_oneof"`
	// The time in force of this order.
	TimeInForce Order_TimeInForce `protobuf:"varint,7,opt,name=time_in_force,json=timeInForce,proto3,enum=dydxprotocol.clob.Order_TimeInForce" json:"time_in_force,omitempty"`
	// Enforces that the order can only reduce the size of an existing position.
	// If a ReduceOnly order would change the side of the existing position,
	// its size is reduced to that of the remaining size of the position.
	// If existing orders on the book with ReduceOnly
	// would already close the position, the least aggressive (out-of-the-money)
	// ReduceOnly orders are resized and canceled first.
	ReduceOnly bool `protobuf:"varint,8,opt,name=reduce_only,json=reduceOnly,proto3" json:"reduce_only,omitempty"`
	// Set of bit flags set arbitrarily by clients and ignored by the protocol.
	// Used by indexer to infer information about a placed order.
	ClientMetadata uint32              `protobuf:"varint,9,opt,name=client_metadata,json=clientMetadata,proto3" json:"client_metadata,omitempty"`
	ConditionType  Order_ConditionType `protobuf:"varint,10,opt,name=condition_type,json=conditionType,proto3,enum=dydxprotocol.clob.Order_ConditionType" json:"condition_type,omitempty"`
	// conditional_order_trigger_subticks represents the price at which this order
	// will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,
	// this value is enforced to be 0. If this value is nonzero, condition_type
	// cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.
	// Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =
	// orderId.ClobPairId`).
	ConditionalOrderTriggerSubticks uint64 `protobuf:"varint,11,opt,name=conditional_order_trigger_subticks,json=conditionalOrderTriggerSubticks,proto3" json:"conditional_order_trigger_subticks,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{7}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

type isOrder_GoodTilOneof interface {
	isOrder_GoodTilOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Order_GoodTilBlock struct {
	GoodTilBlock uint32 `protobuf:"varint,5,opt,name=good_til_block,json=goodTilBlock,proto3,oneof" json:"good_til_block,omitempty"`
}
type Order_GoodTilBlockTime struct {
	GoodTilBlockTime uint32 `protobuf:"fixed32,6,opt,name=good_til_block_time,json=goodTilBlockTime,proto3,oneof" json:"good_til_block_time,omitempty"`
}

func (*Order_GoodTilBlock) isOrder_GoodTilOneof()     {}
func (*Order_GoodTilBlockTime) isOrder_GoodTilOneof() {}

func (m *Order) GetGoodTilOneof() isOrder_GoodTilOneof {
	if m != nil {
		return m.GoodTilOneof
	}
	return nil
}

func (m *Order) GetOrderId() OrderId {
	if m != nil {
		return m.OrderId
	}
	return OrderId{}
}

func (m *Order) GetSide() Order_Side {
	if m != nil {
		return m.Side
	}
	return Order_SIDE_UNSPECIFIED
}

func (m *Order) GetQuantums() uint64 {
	if m != nil {
		return m.Quantums
	}
	return 0
}

func (m *Order) GetSubticks() uint64 {
	if m != nil {
		return m.Subticks
	}
	return 0
}

func (m *Order) GetGoodTilBlock() uint32 {
	if x, ok := m.GetGoodTilOneof().(*Order_GoodTilBlock); ok {
		return x.GoodTilBlock
	}
	return 0
}

func (m *Order) GetGoodTilBlockTime() uint32 {
	if x, ok := m.GetGoodTilOneof().(*Order_GoodTilBlockTime); ok {
		return x.GoodTilBlockTime
	}
	return 0
}

func (m *Order) GetTimeInForce() Order_TimeInForce {
	if m != nil {
		return m.TimeInForce
	}
	return Order_TIME_IN_FORCE_UNSPECIFIED
}

func (m *Order) GetReduceOnly() bool {
	if m != nil {
		return m.ReduceOnly
	}
	return false
}

func (m *Order) GetClientMetadata() uint32 {
	if m != nil {
		return m.ClientMetadata
	}
	return 0
}

func (m *Order) GetConditionType() Order_ConditionType {
	if m != nil {
		return m.ConditionType
	}
	return Order_CONDITION_TYPE_UNSPECIFIED
}

func (m *Order) GetConditionalOrderTriggerSubticks() uint64 {
	if m != nil {
		return m.ConditionalOrderTriggerSubticks
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Order) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Order_GoodTilBlock)(nil),
		(*Order_GoodTilBlockTime)(nil),
	}
}

// TransactionOrdering represents a unique location in the block where a
// transaction was placed. This proto includes both block height and the
// transaction index that the specific transaction was placed. This information
// is used for ordering by time priority when the chain is restarted.
type TransactionOrdering struct {
	// Block height in which the transaction was placed.
	BlockHeight uint32 `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Within the block, the unique transaction index.
	TransactionIndex uint32 `protobuf:"varint,2,opt,name=transaction_index,json=transactionIndex,proto3" json:"transaction_index,omitempty"`
}

func (m *TransactionOrdering) Reset()         { *m = TransactionOrdering{} }
func (m *TransactionOrdering) String() string { return proto.CompactTextString(m) }
func (*TransactionOrdering) ProtoMessage()    {}
func (*TransactionOrdering) Descriptor() ([]byte, []int) {
	return fileDescriptor_673c6f4faa93736b, []int{8}
}
func (m *TransactionOrdering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionOrdering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionOrdering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionOrdering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionOrdering.Merge(m, src)
}
func (m *TransactionOrdering) XXX_Size() int {
	return m.Size()
}
func (m *TransactionOrdering) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionOrdering.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionOrdering proto.InternalMessageInfo

func (m *TransactionOrdering) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *TransactionOrdering) GetTransactionIndex() uint32 {
	if m != nil {
		return m.TransactionIndex
	}
	return 0
}

func init() {
	proto.RegisterEnum("dydxprotocol.clob.Order_Side", Order_Side_name, Order_Side_value)
	proto.RegisterEnum("dydxprotocol.clob.Order_TimeInForce", Order_TimeInForce_name, Order_TimeInForce_value)
	proto.RegisterEnum("dydxprotocol.clob.Order_ConditionType", Order_ConditionType_name, Order_ConditionType_value)
	proto.RegisterType((*OrderId)(nil), "dydxprotocol.clob.OrderId")
	proto.RegisterType((*OrdersFilledDuringLatestBlock)(nil), "dydxprotocol.clob.OrdersFilledDuringLatestBlock")
	proto.RegisterType((*PotentiallyPrunableOrders)(nil), "dydxprotocol.clob.PotentiallyPrunableOrders")
	proto.RegisterType((*OrderFillState)(nil), "dydxprotocol.clob.OrderFillState")
	proto.RegisterType((*StatefulOrderTimeSliceValue)(nil), "dydxprotocol.clob.StatefulOrderTimeSliceValue")
	proto.RegisterType((*LongTermOrderPlacement)(nil), "dydxprotocol.clob.LongTermOrderPlacement")
	proto.RegisterType((*ConditionalOrderPlacement)(nil), "dydxprotocol.clob.ConditionalOrderPlacement")
	proto.RegisterType((*Order)(nil), "dydxprotocol.clob.Order")
	proto.RegisterType((*TransactionOrdering)(nil), "dydxprotocol.clob.TransactionOrdering")
}

func init() { proto.RegisterFile("dydxprotocol/clob/order.proto", fileDescriptor_673c6f4faa93736b) }

var fileDescriptor_673c6f4faa93736b = []byte{
	// 984 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xdd, 0x4e, 0xe3, 0x46,
	0x14, 0x8e, 0x21, 0x40, 0x38, 0xf9, 0x59, 0x33, 0xec, 0xb6, 0x06, 0x4a, 0x48, 0xa3, 0x8a, 0xa5,
	0xaa, 0x94, 0xa8, 0x74, 0x6f, 0xaa, 0xaa, 0x17, 0xfc, 0x24, 0xc2, 0x22, 0xe0, 0xd4, 0x36, 0x95,
	0x58, 0x55, 0x1d, 0x39, 0xf6, 0x60, 0x46, 0x3b, 0xf1, 0xa4, 0xf6, 0xb8, 0x22, 0x77, 0x7d, 0x84,
	0xbe, 0x44, 0xdf, 0xa2, 0x0f, 0xb0, 0x97, 0x7b, 0xd9, 0xab, 0xaa, 0x82, 0x67, 0xa8, 0x7a, 0x5b,
	0xcd, 0xd8, 0xe4, 0x87, 0x5d, 0x54, 0x55, 0x7b, 0xb3, 0x77, 0x9e, 0xef, 0xfb, 0xe6, 0x9b, 0x73,
	0xce, 0x9c, 0x33, 0x32, 0x6c, 0x07, 0xe3, 0xe0, 0x66, 0x14, 0x73, 0xc1, 0x7d, 0xce, 0xda, 0x3e,
	0xe3, 0x83, 0x36, 0x8f, 0x03, 0x12, 0xb7, 0x14, 0x86, 0xd6, 0x66, 0xe9, 0x96, 0xa4, 0x37, 0x9f,
	0x86, 0x3c, 0xe4, 0x0a, 0x6a, 0xcb, 0xaf, 0x4c, 0xb8, 0xf9, 0xf9, 0x9c, 0x4f, 0x92, 0x0e, 0x3c,
	0xdf, 0xe7, 0x69, 0x24, 0x92, 0x99, 0xef, 0x4c, 0xda, 0xfc, 0x5d, 0x83, 0x15, 0x4b, 0x9e, 0x61,
	0x06, 0xe8, 0x3b, 0xa8, 0x4e, 0x79, 0x4c, 0x03, 0x43, 0x6b, 0x68, 0x7b, 0xe5, 0xfd, 0xdd, 0xd6,
	0xdc, 0xb9, 0x33, 0x76, 0x2d, 0x67, 0xf2, 0x6d, 0x06, 0x87, 0xc5, 0xd7, 0x7f, 0xee, 0x14, 0xec,
	0x4a, 0x32, 0x83, 0xa1, 0x2d, 0x58, 0xf5, 0x19, 0x25, 0x99, 0xdd, 0x42, 0x43, 0xdb, 0x5b, 0xb1,
	0x4b, 0x19, 0x60, 0x06, 0x68, 0x07, 0xca, 0x2a, 0x3d, 0x7c, 0xc5, 0xbc, 0x30, 0x31, 0x16, 0x1b,
	0xda, 0x5e, 0xd5, 0x06, 0x05, 0x75, 0x25, 0x82, 0x1a, 0x50, 0x91, 0x59, 0xe2, 0x91, 0x47, 0x63,
	0x69, 0x50, 0xcc, 0x14, 0x12, 0xeb, 0x7b, 0x34, 0x36, 0x83, 0xe6, 0x8f, 0xb0, 0xad, 0xa2, 0x4f,
	0xba, 0x94, 0x31, 0x12, 0x1c, 0xa7, 0x31, 0x8d, 0xc2, 0x9e, 0x27, 0x48, 0x22, 0x0e, 0x19, 0xf7,
	0x5f, 0xa1, 0x6f, 0x61, 0x35, 0x3b, 0x83, 0x06, 0x89, 0xa1, 0x35, 0x16, 0xf7, 0xca, 0xfb, 0x9b,
	0xad, 0xb7, 0xea, 0xd8, 0xca, 0x4b, 0x90, 0xe7, 0x50, 0xe2, 0xd9, 0x32, 0x69, 0xbe, 0x84, 0x8d,
	0x3e, 0x17, 0x24, 0x12, 0xd4, 0x63, 0x6c, 0xdc, 0x8f, 0xd3, 0xc8, 0x1b, 0x30, 0x92, 0x1d, 0xf9,
	0xbe, 0xde, 0x04, 0x6a, 0x8a, 0x92, 0xa1, 0x3b, 0xc2, 0x13, 0x44, 0x16, 0xe4, 0x8a, 0x32, 0x86,
	0xbd, 0xa1, 0x2c, 0x9f, 0x2a, 0x7f, 0xd1, 0x06, 0x09, 0x1d, 0x28, 0x04, 0xed, 0xc3, 0xb3, 0x51,
	0x1e, 0x03, 0x1e, 0xc8, 0xfc, 0xf0, 0x35, 0xa1, 0xe1, 0xb5, 0x50, 0xa5, 0xad, 0xda, 0xeb, 0xf7,
	0xa4, 0xca, 0xfd, 0x44, 0x51, 0xcd, 0x1f, 0x60, 0x4b, 0xb9, 0x5f, 0xa5, 0x4c, 0x1d, 0xe7, 0xd2,
	0x21, 0x71, 0x18, 0xf5, 0xc9, 0xf7, 0x1e, 0x4b, 0xc9, 0xfb, 0x26, 0xf1, 0x9b, 0x06, 0x1f, 0xf5,
	0x78, 0x14, 0xba, 0x24, 0x1e, 0x2a, 0x4d, 0x9f, 0x79, 0x3e, 0x19, 0x92, 0x48, 0xa0, 0x17, 0xb0,
	0xa4, 0x64, 0x79, 0x1b, 0x19, 0x8f, 0xb9, 0xe6, 0x9e, 0x99, 0x18, 0x5d, 0xc0, 0x93, 0xd1, 0xbd,
	0x05, 0xa6, 0x51, 0x40, 0x6e, 0x54, 0x72, 0x6f, 0xb5, 0xa1, 0xda, 0xef, 0xc6, 0x5e, 0x94, 0x78,
	0xbe, 0xa0, 0x3c, 0x52, 0x56, 0x34, 0x0a, 0x73, 0xb7, 0xda, 0xc4, 0xc4, 0x94, 0x1e, 0xcd, 0xbf,
	0x35, 0xd8, 0x38, 0xe2, 0x51, 0x40, 0xa5, 0xd6, 0x63, 0x1f, 0x70, 0xa8, 0xe8, 0x14, 0xaa, 0x22,
	0xa6, 0x61, 0x28, 0xef, 0x44, 0x99, 0x2e, 0xfe, 0x1f, 0x53, 0xbb, 0x92, 0x6f, 0xce, 0xf2, 0xfe,
	0x67, 0x19, 0x96, 0x14, 0x85, 0xbe, 0x81, 0xd2, 0xfd, 0x45, 0xe7, 0x69, 0xfe, 0xf7, 0x3d, 0xaf,
	0xe4, 0xf7, 0x8c, 0xbe, 0x84, 0x62, 0x42, 0x03, 0xa2, 0xf2, 0xab, 0xed, 0x6f, 0x3f, 0xb6, 0xb1,
	0xe5, 0xd0, 0x80, 0xd8, 0x4a, 0x8a, 0x36, 0xa1, 0xf4, 0x53, 0xea, 0x45, 0x22, 0x1d, 0x66, 0xa3,
	0x5d, 0xb4, 0x27, 0x6b, 0xc9, 0x25, 0xe9, 0x40, 0x50, 0xff, 0x55, 0xa2, 0x86, 0xba, 0x68, 0x4f,
	0xd6, 0x68, 0x17, 0x6a, 0x21, 0xe7, 0x01, 0x16, 0x94, 0x65, 0x3d, 0x6e, 0x2c, 0xc9, 0xe6, 0x3e,
	0x29, 0xd8, 0x15, 0x89, 0xbb, 0x94, 0x65, 0x93, 0xdd, 0x86, 0xf5, 0x79, 0x1d, 0x16, 0x74, 0x48,
	0x8c, 0x65, 0xf9, 0xc8, 0x9c, 0x14, 0x6c, 0x7d, 0x56, 0x2c, 0x7b, 0x1e, 0x9d, 0x40, 0x55, 0x2a,
	0x30, 0x8d, 0xf0, 0x15, 0x8f, 0x7d, 0x62, 0xac, 0xa8, 0x64, 0x3e, 0x7b, 0x34, 0x19, 0xb9, 0xcb,
	0x8c, 0xba, 0x52, 0x6b, 0x97, 0xc5, 0x74, 0x21, 0xe7, 0x34, 0x26, 0x41, 0xea, 0x13, 0xcc, 0x23,
	0x36, 0x36, 0x4a, 0x0d, 0x6d, 0xaf, 0x64, 0x43, 0x06, 0x59, 0x11, 0x1b, 0xa3, 0xe7, 0xf0, 0x24,
	0x7f, 0xf6, 0x86, 0x44, 0x78, 0x81, 0x27, 0x3c, 0x63, 0x55, 0x4d, 0x68, 0x2d, 0x83, 0xcf, 0x72,
	0x14, 0x9d, 0x41, 0xcd, 0xbf, 0xef, 0x4a, 0x2c, 0xc6, 0x23, 0x62, 0x80, 0x0a, 0x6a, 0xf7, 0xd1,
	0xa0, 0x26, 0x4d, 0xec, 0x8e, 0x47, 0xc4, 0xae, 0xfa, 0xb3, 0x4b, 0x74, 0x0a, 0x4d, 0x7f, 0xda,
	0xe4, 0x38, 0xbb, 0xef, 0xfb, 0x66, 0x9a, 0x54, 0xbc, 0xac, 0x2a, 0xbe, 0xe3, 0x3f, 0x18, 0x07,
	0x37, 0xd3, 0x39, 0xb9, 0xac, 0xf9, 0x35, 0x14, 0xe5, 0x75, 0xa2, 0xa7, 0xa0, 0x3b, 0xe6, 0x71,
	0x07, 0x5f, 0x9c, 0x3b, 0xfd, 0xce, 0x91, 0xd9, 0x35, 0x3b, 0xc7, 0x7a, 0x01, 0x55, 0xa0, 0xa4,
	0xd0, 0xc3, 0x8b, 0x4b, 0x5d, 0x43, 0x55, 0x58, 0x55, 0x2b, 0xa7, 0xd3, 0xeb, 0xe9, 0x0b, 0xcd,
	0x5f, 0x34, 0x28, 0xcf, 0x54, 0x0f, 0x6d, 0xc3, 0x86, 0x6b, 0x9e, 0x75, 0xb0, 0x79, 0x8e, 0xbb,
	0x96, 0x7d, 0xf4, 0xd0, 0xeb, 0x19, 0xac, 0xcd, 0xd3, 0xa6, 0x75, 0xa4, 0x6b, 0x68, 0x0b, 0x3e,
	0x9e, 0x87, 0xfb, 0x96, 0xe3, 0x62, 0xeb, 0xbc, 0x77, 0xa9, 0x2f, 0xa0, 0x3a, 0x6c, 0xce, 0x93,
	0x5d, 0xb3, 0xd7, 0xc3, 0x96, 0x8d, 0x4f, 0xcd, 0x5e, 0x4f, 0x5f, 0x6c, 0x0e, 0xa1, 0x3a, 0x57,
	0x2a, 0xb9, 0xe1, 0xc8, 0x3a, 0x3f, 0x36, 0x5d, 0xd3, 0x3a, 0xc7, 0xee, 0x65, 0xff, 0x61, 0x10,
	0x9f, 0x80, 0xf1, 0x80, 0x77, 0x5c, 0xab, 0x8f, 0x7b, 0x96, 0xe3, 0xe8, 0xda, 0x3b, 0x76, 0xbb,
	0x07, 0xa7, 0x1d, 0xdc, 0xb7, 0xad, 0xae, 0xe9, 0xea, 0x0b, 0x87, 0xfa, 0x4c, 0xd7, 0xf2, 0x88,
	0xf0, 0xab, 0x26, 0x81, 0xf5, 0x77, 0x8c, 0x27, 0xfa, 0x14, 0x2a, 0x73, 0x2f, 0xb7, 0xa6, 0xfa,
	0xa2, 0x3c, 0x98, 0xbe, 0xd8, 0xe8, 0x0b, 0x58, 0x13, 0xd3, 0x9d, 0x33, 0x2f, 0x4b, 0xd5, 0xd6,
	0x67, 0x08, 0x35, 0xe0, 0x87, 0x07, 0xaf, 0x6f, 0xeb, 0xda, 0x9b, 0xdb, 0xba, 0xf6, 0xd7, 0x6d,
	0x5d, 0xfb, 0xf5, 0xae, 0x5e, 0x78, 0x73, 0x57, 0x2f, 0xfc, 0x71, 0x57, 0x2f, 0xbc, 0x7c, 0x1e,
	0x52, 0x71, 0x9d, 0x0e, 0x5a, 0x3e, 0x1f, 0xb6, 0xe7, 0x7e, 0x08, 0x7e, 0x7e, 0xd1, 0xbe, 0xc9,
	0xfe, 0x2e, 0x64, 0xc7, 0x25, 0x83, 0x65, 0xc5, 0x7c, 0xf5, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x93, 0x1c, 0x40, 0x69, 0x7f, 0x08, 0x00, 0x00,
}

func (m *OrderId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClobPairId != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x20
	}
	if m.OrderFlags != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderFlags))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientId != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ClientId))
		i--
		dAtA[i] = 0x15
	}
	{
		size, err := m.SubaccountId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrder(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OrdersFilledDuringLatestBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrdersFilledDuringLatestBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrdersFilledDuringLatestBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		for iNdEx := len(m.OrderIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrder(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PotentiallyPrunableOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PotentiallyPrunableOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PotentiallyPrunableOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		for iNdEx := len(m.OrderIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrder(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderFillState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFillState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrunableBlockHeight != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.PrunableBlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.FillAmount != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.FillAmount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderTimeSliceValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderTimeSliceValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderTimeSliceValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		for iNdEx := len(m.OrderIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrder(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LongTermOrderPlacement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongTermOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LongTermOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PlacementIndex.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrder(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrder(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConditionalOrderPlacement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionalOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionalOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TriggerIndex != nil {
		{
			size, err := m.TriggerIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.PlacementIndex.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrder(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrder(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConditionalOrderTriggerSubticks != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.ConditionalOrderTriggerSubticks))
		i--
		dAtA[i] = 0x58
	}
	if m.ConditionType != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.ConditionType))
		i--
		dAtA[i] = 0x50
	}
	if m.ClientMetadata != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.ClientMetadata))
		i--
		dAtA[i] = 0x48
	}
	if m.ReduceOnly {
		i--
		if m.ReduceOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.TimeInForce != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.TimeInForce))
		i--
		dAtA[i] = 0x38
	}
	if m.GoodTilOneof != nil {
		{
			size := m.GoodTilOneof.Size()
			i -= size
			if _, err := m.GoodTilOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Subticks != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.Subticks))
		i--
		dAtA[i] = 0x20
	}
	if m.Quantums != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.Quantums))
		i--
		dAtA[i] = 0x18
	}
	if m.Side != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.Side))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.OrderId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrder(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Order_GoodTilBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order_GoodTilBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintOrder(dAtA, i, uint64(m.GoodTilBlock))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Order_GoodTilBlockTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order_GoodTilBlockTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.GoodTilBlockTime))
	i--
	dAtA[i] = 0x35
	return len(dAtA) - i, nil
}
func (m *TransactionOrdering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionOrdering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionOrdering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionIndex != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.TransactionIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockHeight != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOrder(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrder(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OrderId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SubaccountId.Size()
	n += 1 + l + sovOrder(uint64(l))
	if m.ClientId != 0 {
		n += 5
	}
	if m.OrderFlags != 0 {
		n += 1 + sovOrder(uint64(m.OrderFlags))
	}
	if m.ClobPairId != 0 {
		n += 1 + sovOrder(uint64(m.ClobPairId))
	}
	return n
}

func (m *OrdersFilledDuringLatestBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		for _, e := range m.OrderIds {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	return n
}

func (m *PotentiallyPrunableOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		for _, e := range m.OrderIds {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	return n
}

func (m *OrderFillState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FillAmount != 0 {
		n += 1 + sovOrder(uint64(m.FillAmount))
	}
	if m.PrunableBlockHeight != 0 {
		n += 1 + sovOrder(uint64(m.PrunableBlockHeight))
	}
	return n
}

func (m *StatefulOrderTimeSliceValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		for _, e := range m.OrderIds {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	return n
}

func (m *LongTermOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Order.Size()
	n += 1 + l + sovOrder(uint64(l))
	l = m.PlacementIndex.Size()
	n += 1 + l + sovOrder(uint64(l))
	return n
}

func (m *ConditionalOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Order.Size()
	n += 1 + l + sovOrder(uint64(l))
	l = m.PlacementIndex.Size()
	n += 1 + l + sovOrder(uint64(l))
	if m.TriggerIndex != nil {
		l = m.TriggerIndex.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OrderId.Size()
	n += 1 + l + sovOrder(uint64(l))
	if m.Side != 0 {
		n += 1 + sovOrder(uint64(m.Side))
	}
	if m.Quantums != 0 {
		n += 1 + sovOrder(uint64(m.Quantums))
	}
	if m.Subticks != 0 {
		n += 1 + sovOrder(uint64(m.Subticks))
	}
	if m.GoodTilOneof != nil {
		n += m.GoodTilOneof.Size()
	}
	if m.TimeInForce != 0 {
		n += 1 + sovOrder(uint64(m.TimeInForce))
	}
	if m.ReduceOnly {
		n += 2
	}
	if m.ClientMetadata != 0 {
		n += 1 + sovOrder(uint64(m.ClientMetadata))
	}
	if m.ConditionType != 0 {
		n += 1 + sovOrder(uint64(m.ConditionType))
	}
	if m.ConditionalOrderTriggerSubticks != 0 {
		n += 1 + sovOrder(uint64(m.ConditionalOrderTriggerSubticks))
	}
	return n
}

func (m *Order_GoodTilBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOrder(uint64(m.GoodTilBlock))
	return n
}
func (m *Order_GoodTilBlockTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *TransactionOrdering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovOrder(uint64(m.BlockHeight))
	}
	if m.TransactionIndex != 0 {
		n += 1 + sovOrder(uint64(m.TransactionIndex))
	}
	return n
}

func sovOrder(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrder(x uint64) (n int) {
	return sovOrder(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OrderId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderFlags", wireType)
			}
			m.OrderFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderFlags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrdersFilledDuringLatestBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrdersFilledDuringLatestBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrdersFilledDuringLatestBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderIds = append(m.OrderIds, OrderId{})
			if err := m.OrderIds[len(m.OrderIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PotentiallyPrunableOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PotentiallyPrunableOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PotentiallyPrunableOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderIds = append(m.OrderIds, OrderId{})
			if err := m.OrderIds[len(m.OrderIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFillState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFillState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFillState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillAmount", wireType)
			}
			m.FillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrunableBlockHeight", wireType)
			}
			m.PrunableBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrunableBlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderTimeSliceValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderTimeSliceValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderTimeSliceValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderIds = append(m.OrderIds, OrderId{})
			if err := m.OrderIds[len(m.OrderIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongTermOrderPlacement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongTermOrderPlacement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongTermOrderPlacement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PlacementIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionalOrderPlacement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalOrderPlacement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalOrderPlacement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PlacementIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggerIndex == nil {
				m.TriggerIndex = &TransactionOrdering{}
			}
			if err := m.TriggerIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= Order_Side(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantums", wireType)
			}
			m.Quantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subticks", wireType)
			}
			m.Subticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subticks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlock", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GoodTilOneof = &Order_GoodTilBlock{v}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlockTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GoodTilOneof = &Order_GoodTilBlockTime{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeInForce", wireType)
			}
			m.TimeInForce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeInForce |= Order_TimeInForce(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReduceOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReduceOnly = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientMetadata", wireType)
			}
			m.ClientMetadata = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientMetadata |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			m.ConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionType |= Order_ConditionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalOrderTriggerSubticks", wireType)
			}
			m.ConditionalOrderTriggerSubticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionalOrderTriggerSubticks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionOrdering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionOrdering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionOrdering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			m.TransactionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrder(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrder
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrder
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrder
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrder        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrder          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrder = fmt.Errorf("proto: unexpected end of group")
)
