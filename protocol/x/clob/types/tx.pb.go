// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/clob/tx.proto

package types

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/dydxprotocol/v4-chain/protocol/x/subaccounts/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateClobPair is a message used by x/gov for creating a new clob pair.
type MsgCreateClobPair struct {
	// The address that controls the module.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// `clob_pair` defines parameters for the new clob pair.
	ClobPair ClobPair `protobuf:"bytes,2,opt,name=clob_pair,json=clobPair,proto3" json:"clob_pair"`
}

func (m *MsgCreateClobPair) Reset()         { *m = MsgCreateClobPair{} }
func (m *MsgCreateClobPair) String() string { return proto.CompactTextString(m) }
func (*MsgCreateClobPair) ProtoMessage()    {}
func (*MsgCreateClobPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{0}
}
func (m *MsgCreateClobPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateClobPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateClobPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateClobPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateClobPair.Merge(m, src)
}
func (m *MsgCreateClobPair) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateClobPair) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateClobPair.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateClobPair proto.InternalMessageInfo

func (m *MsgCreateClobPair) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgCreateClobPair) GetClobPair() ClobPair {
	if m != nil {
		return m.ClobPair
	}
	return ClobPair{}
}

// MsgCreateClobPairResponse defines the CreateClobPair response type.
type MsgCreateClobPairResponse struct {
}

func (m *MsgCreateClobPairResponse) Reset()         { *m = MsgCreateClobPairResponse{} }
func (m *MsgCreateClobPairResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateClobPairResponse) ProtoMessage()    {}
func (*MsgCreateClobPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{1}
}
func (m *MsgCreateClobPairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateClobPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateClobPairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateClobPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateClobPairResponse.Merge(m, src)
}
func (m *MsgCreateClobPairResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateClobPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateClobPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateClobPairResponse proto.InternalMessageInfo

// MsgProposedOperations is a message injected by block proposers to
// specify the operations that occurred in a block.
type MsgProposedOperations struct {
	// The list of operations proposed by the block proposer.
	OperationsQueue []OperationRaw `protobuf:"bytes,1,rep,name=operations_queue,json=operationsQueue,proto3" json:"operations_queue"`
}

func (m *MsgProposedOperations) Reset()         { *m = MsgProposedOperations{} }
func (m *MsgProposedOperations) String() string { return proto.CompactTextString(m) }
func (*MsgProposedOperations) ProtoMessage()    {}
func (*MsgProposedOperations) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{2}
}
func (m *MsgProposedOperations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposedOperations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposedOperations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposedOperations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposedOperations.Merge(m, src)
}
func (m *MsgProposedOperations) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposedOperations) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposedOperations.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposedOperations proto.InternalMessageInfo

func (m *MsgProposedOperations) GetOperationsQueue() []OperationRaw {
	if m != nil {
		return m.OperationsQueue
	}
	return nil
}

// MsgProposedOperationsResponse is the response type of the message injected
// by block proposers to specify the operations that occurred in a block.
type MsgProposedOperationsResponse struct {
}

func (m *MsgProposedOperationsResponse) Reset()         { *m = MsgProposedOperationsResponse{} }
func (m *MsgProposedOperationsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposedOperationsResponse) ProtoMessage()    {}
func (*MsgProposedOperationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{3}
}
func (m *MsgProposedOperationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposedOperationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposedOperationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposedOperationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposedOperationsResponse.Merge(m, src)
}
func (m *MsgProposedOperationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposedOperationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposedOperationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposedOperationsResponse proto.InternalMessageInfo

// MsgPlaceOrder is a request type used for placing orders.
type MsgPlaceOrder struct {
	Order Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order"`
}

func (m *MsgPlaceOrder) Reset()         { *m = MsgPlaceOrder{} }
func (m *MsgPlaceOrder) String() string { return proto.CompactTextString(m) }
func (*MsgPlaceOrder) ProtoMessage()    {}
func (*MsgPlaceOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{4}
}
func (m *MsgPlaceOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlaceOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlaceOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlaceOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlaceOrder.Merge(m, src)
}
func (m *MsgPlaceOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlaceOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlaceOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlaceOrder proto.InternalMessageInfo

func (m *MsgPlaceOrder) GetOrder() Order {
	if m != nil {
		return m.Order
	}
	return Order{}
}

// MsgPlaceOrderResponse is a response type used for placing orders.
type MsgPlaceOrderResponse struct {
}

func (m *MsgPlaceOrderResponse) Reset()         { *m = MsgPlaceOrderResponse{} }
func (m *MsgPlaceOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPlaceOrderResponse) ProtoMessage()    {}
func (*MsgPlaceOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{5}
}
func (m *MsgPlaceOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlaceOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlaceOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlaceOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlaceOrderResponse.Merge(m, src)
}
func (m *MsgPlaceOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlaceOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlaceOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlaceOrderResponse proto.InternalMessageInfo

// MsgCancelOrder is a request type used for canceling orders.
type MsgCancelOrder struct {
	OrderId OrderId `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	// Information about when the order cancellation expires.
	//
	// Types that are valid to be assigned to GoodTilOneof:
	//	*MsgCancelOrder_GoodTilBlock
	//	*MsgCancelOrder_GoodTilBlockTime
	GoodTilOneof isMsgCancelOrder_GoodTilOneof `protobuf_oneof:"good_til_oneof"`
}

func (m *MsgCancelOrder) Reset()         { *m = MsgCancelOrder{} }
func (m *MsgCancelOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelOrder) ProtoMessage()    {}
func (*MsgCancelOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{6}
}
func (m *MsgCancelOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelOrder.Merge(m, src)
}
func (m *MsgCancelOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelOrder proto.InternalMessageInfo

type isMsgCancelOrder_GoodTilOneof interface {
	isMsgCancelOrder_GoodTilOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgCancelOrder_GoodTilBlock struct {
	GoodTilBlock uint32 `protobuf:"varint,2,opt,name=good_til_block,json=goodTilBlock,proto3,oneof" json:"good_til_block,omitempty"`
}
type MsgCancelOrder_GoodTilBlockTime struct {
	GoodTilBlockTime uint32 `protobuf:"fixed32,3,opt,name=good_til_block_time,json=goodTilBlockTime,proto3,oneof" json:"good_til_block_time,omitempty"`
}

func (*MsgCancelOrder_GoodTilBlock) isMsgCancelOrder_GoodTilOneof()     {}
func (*MsgCancelOrder_GoodTilBlockTime) isMsgCancelOrder_GoodTilOneof() {}

func (m *MsgCancelOrder) GetGoodTilOneof() isMsgCancelOrder_GoodTilOneof {
	if m != nil {
		return m.GoodTilOneof
	}
	return nil
}

func (m *MsgCancelOrder) GetOrderId() OrderId {
	if m != nil {
		return m.OrderId
	}
	return OrderId{}
}

func (m *MsgCancelOrder) GetGoodTilBlock() uint32 {
	if x, ok := m.GetGoodTilOneof().(*MsgCancelOrder_GoodTilBlock); ok {
		return x.GoodTilBlock
	}
	return 0
}

func (m *MsgCancelOrder) GetGoodTilBlockTime() uint32 {
	if x, ok := m.GetGoodTilOneof().(*MsgCancelOrder_GoodTilBlockTime); ok {
		return x.GoodTilBlockTime
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgCancelOrder) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgCancelOrder_GoodTilBlock)(nil),
		(*MsgCancelOrder_GoodTilBlockTime)(nil),
	}
}

// MsgCancelOrderResponse is a response type used for canceling orders.
type MsgCancelOrderResponse struct {
}

func (m *MsgCancelOrderResponse) Reset()         { *m = MsgCancelOrderResponse{} }
func (m *MsgCancelOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelOrderResponse) ProtoMessage()    {}
func (*MsgCancelOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{7}
}
func (m *MsgCancelOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelOrderResponse.Merge(m, src)
}
func (m *MsgCancelOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelOrderResponse proto.InternalMessageInfo

// MsgBatchCancel is a request type used for batch canceling orders.
// This msg is not atomic. Cancels will be performed optimistically even
// if some cancels are invalid or fail.
type MsgBatchCancel struct {
	// The subaccount this batch cancel will be applied for.
	SubaccountId types.SubaccountId `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id"`
	// The batch of short term orders that will be cancelled.
	ShortTermCancels []OrderBatch `protobuf:"bytes,2,rep,name=short_term_cancels,json=shortTermCancels,proto3" json:"short_term_cancels"`
	// The last block the short term order cancellations can be executed at.
	GoodTilBlock uint32 `protobuf:"varint,3,opt,name=good_til_block,json=goodTilBlock,proto3" json:"good_til_block,omitempty"`
}

func (m *MsgBatchCancel) Reset()         { *m = MsgBatchCancel{} }
func (m *MsgBatchCancel) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancel) ProtoMessage()    {}
func (*MsgBatchCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{8}
}
func (m *MsgBatchCancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancel.Merge(m, src)
}
func (m *MsgBatchCancel) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancel.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancel proto.InternalMessageInfo

func (m *MsgBatchCancel) GetSubaccountId() types.SubaccountId {
	if m != nil {
		return m.SubaccountId
	}
	return types.SubaccountId{}
}

func (m *MsgBatchCancel) GetShortTermCancels() []OrderBatch {
	if m != nil {
		return m.ShortTermCancels
	}
	return nil
}

func (m *MsgBatchCancel) GetGoodTilBlock() uint32 {
	if m != nil {
		return m.GoodTilBlock
	}
	return 0
}

// OrderBatch represents a batch of orders all belonging to a single clob pair
// id. Along with a subaccount id and an order flag, is used to represent a
// batch of orders that share the same subaccount, order flag, and clob pair id.
type OrderBatch struct {
	// The Clob Pair ID all orders in this order batch belong to.
	ClobPairId uint32 `protobuf:"varint,1,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// List of client ids in this order batch.
	// Note that this is serialized as a uint32 instead of a fixed32 to
	// avoid issues when decoding repeated packed fixed32.
	ClientIds []uint32 `protobuf:"varint,2,rep,packed,name=client_ids,json=clientIds,proto3" json:"client_ids,omitempty"`
}

func (m *OrderBatch) Reset()         { *m = OrderBatch{} }
func (m *OrderBatch) String() string { return proto.CompactTextString(m) }
func (*OrderBatch) ProtoMessage()    {}
func (*OrderBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{9}
}
func (m *OrderBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBatch.Merge(m, src)
}
func (m *OrderBatch) XXX_Size() int {
	return m.Size()
}
func (m *OrderBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBatch.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBatch proto.InternalMessageInfo

func (m *OrderBatch) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *OrderBatch) GetClientIds() []uint32 {
	if m != nil {
		return m.ClientIds
	}
	return nil
}

// MsgBatchCancelResponse is a response type used for batch canceling orders.
// It indicates which cancel orders have succeeded or failed.
type MsgBatchCancelResponse struct {
	// A batch of short term cancel orders that have succeeded.
	ShortTermSucceeded []*OrderBatch `protobuf:"bytes,1,rep,name=short_term_succeeded,json=shortTermSucceeded,proto3" json:"short_term_succeeded,omitempty"`
	// A batch of short term cancel orders that have failed.
	ShortTermFailed []*OrderBatch `protobuf:"bytes,2,rep,name=short_term_failed,json=shortTermFailed,proto3" json:"short_term_failed,omitempty"`
}

func (m *MsgBatchCancelResponse) Reset()         { *m = MsgBatchCancelResponse{} }
func (m *MsgBatchCancelResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelResponse) ProtoMessage()    {}
func (*MsgBatchCancelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{10}
}
func (m *MsgBatchCancelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelResponse.Merge(m, src)
}
func (m *MsgBatchCancelResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelResponse proto.InternalMessageInfo

func (m *MsgBatchCancelResponse) GetShortTermSucceeded() []*OrderBatch {
	if m != nil {
		return m.ShortTermSucceeded
	}
	return nil
}

func (m *MsgBatchCancelResponse) GetShortTermFailed() []*OrderBatch {
	if m != nil {
		return m.ShortTermFailed
	}
	return nil
}

// MsgUpdateClobPair is a request type used for updating a ClobPair in state.
type MsgUpdateClobPair struct {
	// Authority is the address that may send this message.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// `clob_pair` is the ClobPair to write to state.
	ClobPair ClobPair `protobuf:"bytes,2,opt,name=clob_pair,json=clobPair,proto3" json:"clob_pair"`
}

func (m *MsgUpdateClobPair) Reset()         { *m = MsgUpdateClobPair{} }
func (m *MsgUpdateClobPair) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClobPair) ProtoMessage()    {}
func (*MsgUpdateClobPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{11}
}
func (m *MsgUpdateClobPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClobPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClobPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClobPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClobPair.Merge(m, src)
}
func (m *MsgUpdateClobPair) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClobPair) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClobPair.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClobPair proto.InternalMessageInfo

func (m *MsgUpdateClobPair) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateClobPair) GetClobPair() ClobPair {
	if m != nil {
		return m.ClobPair
	}
	return ClobPair{}
}

// MsgUpdateClobPairResponse is a response type used for setting a ClobPair's
// status.
type MsgUpdateClobPairResponse struct {
}

func (m *MsgUpdateClobPairResponse) Reset()         { *m = MsgUpdateClobPairResponse{} }
func (m *MsgUpdateClobPairResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClobPairResponse) ProtoMessage()    {}
func (*MsgUpdateClobPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{12}
}
func (m *MsgUpdateClobPairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClobPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClobPairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClobPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClobPairResponse.Merge(m, src)
}
func (m *MsgUpdateClobPairResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClobPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClobPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClobPairResponse proto.InternalMessageInfo

// OperationRaw represents an operation in the proposed operations.
// Note that the `order_placement` operation is a signed message.
type OperationRaw struct {
	// operationRaw represents an operation that occurred, which can be a match,
	// a signed order placement, or an order removal.
	//
	// Types that are valid to be assigned to Operation:
	//	*OperationRaw_Match
	//	*OperationRaw_ShortTermOrderPlacement
	//	*OperationRaw_OrderRemoval
	Operation isOperationRaw_Operation `protobuf_oneof:"operation"`
}

func (m *OperationRaw) Reset()         { *m = OperationRaw{} }
func (m *OperationRaw) String() string { return proto.CompactTextString(m) }
func (*OperationRaw) ProtoMessage()    {}
func (*OperationRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{13}
}
func (m *OperationRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperationRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperationRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperationRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationRaw.Merge(m, src)
}
func (m *OperationRaw) XXX_Size() int {
	return m.Size()
}
func (m *OperationRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationRaw.DiscardUnknown(m)
}

var xxx_messageInfo_OperationRaw proto.InternalMessageInfo

type isOperationRaw_Operation interface {
	isOperationRaw_Operation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OperationRaw_Match struct {
	Match *ClobMatch `protobuf:"bytes,1,opt,name=match,proto3,oneof" json:"match,omitempty"`
}
type OperationRaw_ShortTermOrderPlacement struct {
	ShortTermOrderPlacement []byte `protobuf:"bytes,2,opt,name=short_term_order_placement,json=shortTermOrderPlacement,proto3,oneof" json:"short_term_order_placement,omitempty"`
}
type OperationRaw_OrderRemoval struct {
	OrderRemoval *OrderRemoval `protobuf:"bytes,3,opt,name=order_removal,json=orderRemoval,proto3,oneof" json:"order_removal,omitempty"`
}

func (*OperationRaw_Match) isOperationRaw_Operation()                   {}
func (*OperationRaw_ShortTermOrderPlacement) isOperationRaw_Operation() {}
func (*OperationRaw_OrderRemoval) isOperationRaw_Operation()            {}

func (m *OperationRaw) GetOperation() isOperationRaw_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *OperationRaw) GetMatch() *ClobMatch {
	if x, ok := m.GetOperation().(*OperationRaw_Match); ok {
		return x.Match
	}
	return nil
}

func (m *OperationRaw) GetShortTermOrderPlacement() []byte {
	if x, ok := m.GetOperation().(*OperationRaw_ShortTermOrderPlacement); ok {
		return x.ShortTermOrderPlacement
	}
	return nil
}

func (m *OperationRaw) GetOrderRemoval() *OrderRemoval {
	if x, ok := m.GetOperation().(*OperationRaw_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OperationRaw) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OperationRaw_Match)(nil),
		(*OperationRaw_ShortTermOrderPlacement)(nil),
		(*OperationRaw_OrderRemoval)(nil),
	}
}

// MsgUpdateEquityTierLimitConfiguration is the Msg/EquityTierLimitConfiguration
// request type.
type MsgUpdateEquityTierLimitConfiguration struct {
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Defines the equity tier limit configuration to update to. All fields must
	// be set.
	EquityTierLimitConfig EquityTierLimitConfiguration `protobuf:"bytes,2,opt,name=equity_tier_limit_config,json=equityTierLimitConfig,proto3" json:"equity_tier_limit_config"`
}

func (m *MsgUpdateEquityTierLimitConfiguration) Reset()         { *m = MsgUpdateEquityTierLimitConfiguration{} }
func (m *MsgUpdateEquityTierLimitConfiguration) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateEquityTierLimitConfiguration) ProtoMessage()    {}
func (*MsgUpdateEquityTierLimitConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{14}
}
func (m *MsgUpdateEquityTierLimitConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateEquityTierLimitConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateEquityTierLimitConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateEquityTierLimitConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateEquityTierLimitConfiguration.Merge(m, src)
}
func (m *MsgUpdateEquityTierLimitConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateEquityTierLimitConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateEquityTierLimitConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateEquityTierLimitConfiguration proto.InternalMessageInfo

func (m *MsgUpdateEquityTierLimitConfiguration) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateEquityTierLimitConfiguration) GetEquityTierLimitConfig() EquityTierLimitConfiguration {
	if m != nil {
		return m.EquityTierLimitConfig
	}
	return EquityTierLimitConfiguration{}
}

// MsgUpdateEquityTierLimitConfiguration is the Msg/EquityTierLimitConfiguration
// response type.
type MsgUpdateEquityTierLimitConfigurationResponse struct {
}

func (m *MsgUpdateEquityTierLimitConfigurationResponse) Reset() {
	*m = MsgUpdateEquityTierLimitConfigurationResponse{}
}
func (m *MsgUpdateEquityTierLimitConfigurationResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgUpdateEquityTierLimitConfigurationResponse) ProtoMessage() {}
func (*MsgUpdateEquityTierLimitConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{15}
}
func (m *MsgUpdateEquityTierLimitConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateEquityTierLimitConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateEquityTierLimitConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateEquityTierLimitConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateEquityTierLimitConfigurationResponse.Merge(m, src)
}
func (m *MsgUpdateEquityTierLimitConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateEquityTierLimitConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateEquityTierLimitConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateEquityTierLimitConfigurationResponse proto.InternalMessageInfo

// MsgUpdateBlockRateLimitConfiguration is the Msg/BlockRateLimitConfiguration
// request type.
type MsgUpdateBlockRateLimitConfiguration struct {
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Defines the block rate limit configuration to update to. All fields must be
	// set.
	BlockRateLimitConfig BlockRateLimitConfiguration `protobuf:"bytes,3,opt,name=block_rate_limit_config,json=blockRateLimitConfig,proto3" json:"block_rate_limit_config"`
}

func (m *MsgUpdateBlockRateLimitConfiguration) Reset()         { *m = MsgUpdateBlockRateLimitConfiguration{} }
func (m *MsgUpdateBlockRateLimitConfiguration) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBlockRateLimitConfiguration) ProtoMessage()    {}
func (*MsgUpdateBlockRateLimitConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{16}
}
func (m *MsgUpdateBlockRateLimitConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBlockRateLimitConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBlockRateLimitConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBlockRateLimitConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBlockRateLimitConfiguration.Merge(m, src)
}
func (m *MsgUpdateBlockRateLimitConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBlockRateLimitConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBlockRateLimitConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBlockRateLimitConfiguration proto.InternalMessageInfo

func (m *MsgUpdateBlockRateLimitConfiguration) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateBlockRateLimitConfiguration) GetBlockRateLimitConfig() BlockRateLimitConfiguration {
	if m != nil {
		return m.BlockRateLimitConfig
	}
	return BlockRateLimitConfiguration{}
}

// MsgUpdateBlockRateLimitConfiguration is a response type for updating the
// liquidations config.
type MsgUpdateBlockRateLimitConfigurationResponse struct {
}

func (m *MsgUpdateBlockRateLimitConfigurationResponse) Reset() {
	*m = MsgUpdateBlockRateLimitConfigurationResponse{}
}
func (m *MsgUpdateBlockRateLimitConfigurationResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgUpdateBlockRateLimitConfigurationResponse) ProtoMessage() {}
func (*MsgUpdateBlockRateLimitConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{17}
}
func (m *MsgUpdateBlockRateLimitConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBlockRateLimitConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBlockRateLimitConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBlockRateLimitConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBlockRateLimitConfigurationResponse.Merge(m, src)
}
func (m *MsgUpdateBlockRateLimitConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBlockRateLimitConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBlockRateLimitConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBlockRateLimitConfigurationResponse proto.InternalMessageInfo

// MsgUpdateLiquidationsConfig is a request type for updating the liquidations
// config.
type MsgUpdateLiquidationsConfig struct {
	// Authority is the address that may send this message.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Defines the liquidations configuration to update to. All fields must
	// be set.
	LiquidationsConfig LiquidationsConfig `protobuf:"bytes,2,opt,name=liquidations_config,json=liquidationsConfig,proto3" json:"liquidations_config"`
}

func (m *MsgUpdateLiquidationsConfig) Reset()         { *m = MsgUpdateLiquidationsConfig{} }
func (m *MsgUpdateLiquidationsConfig) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateLiquidationsConfig) ProtoMessage()    {}
func (*MsgUpdateLiquidationsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{18}
}
func (m *MsgUpdateLiquidationsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateLiquidationsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateLiquidationsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateLiquidationsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateLiquidationsConfig.Merge(m, src)
}
func (m *MsgUpdateLiquidationsConfig) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateLiquidationsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateLiquidationsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateLiquidationsConfig proto.InternalMessageInfo

func (m *MsgUpdateLiquidationsConfig) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateLiquidationsConfig) GetLiquidationsConfig() LiquidationsConfig {
	if m != nil {
		return m.LiquidationsConfig
	}
	return LiquidationsConfig{}
}

// MsgUpdateLiquidationsConfig is the Msg/LiquidationsConfig response type.
type MsgUpdateLiquidationsConfigResponse struct {
}

func (m *MsgUpdateLiquidationsConfigResponse) Reset()         { *m = MsgUpdateLiquidationsConfigResponse{} }
func (m *MsgUpdateLiquidationsConfigResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateLiquidationsConfigResponse) ProtoMessage()    {}
func (*MsgUpdateLiquidationsConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{19}
}
func (m *MsgUpdateLiquidationsConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateLiquidationsConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateLiquidationsConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateLiquidationsConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateLiquidationsConfigResponse.Merge(m, src)
}
func (m *MsgUpdateLiquidationsConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateLiquidationsConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateLiquidationsConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateLiquidationsConfigResponse proto.InternalMessageInfo

// LeverageEntry represents a single clob pair leverage setting.
type LeverageEntry struct {
	// The clob pair ID.
	ClobPairId uint32 `protobuf:"varint,1,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// The user selected imf.
	CustomImfPpm uint32 `protobuf:"varint,2,opt,name=custom_imf_ppm,json=customImfPpm,proto3" json:"custom_imf_ppm,omitempty"`
}

func (m *LeverageEntry) Reset()         { *m = LeverageEntry{} }
func (m *LeverageEntry) String() string { return proto.CompactTextString(m) }
func (*LeverageEntry) ProtoMessage()    {}
func (*LeverageEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{20}
}
func (m *LeverageEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeverageEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeverageEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeverageEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeverageEntry.Merge(m, src)
}
func (m *LeverageEntry) XXX_Size() int {
	return m.Size()
}
func (m *LeverageEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LeverageEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LeverageEntry proto.InternalMessageInfo

func (m *LeverageEntry) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *LeverageEntry) GetCustomImfPpm() uint32 {
	if m != nil {
		return m.CustomImfPpm
	}
	return 0
}

// MsgUpdateLeverage is a request type used for updating leverage for
// clob pairs.
type MsgUpdateLeverage struct {
	// The subaccount that is updating leverage.
	SubaccountId *types.SubaccountId `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// List of clob pair leverage settings.
	ClobPairLeverage []*LeverageEntry `protobuf:"bytes,2,rep,name=clob_pair_leverage,json=clobPairLeverage,proto3" json:"clob_pair_leverage,omitempty"`
}

func (m *MsgUpdateLeverage) Reset()         { *m = MsgUpdateLeverage{} }
func (m *MsgUpdateLeverage) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateLeverage) ProtoMessage()    {}
func (*MsgUpdateLeverage) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{21}
}
func (m *MsgUpdateLeverage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateLeverage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateLeverage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateLeverage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateLeverage.Merge(m, src)
}
func (m *MsgUpdateLeverage) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateLeverage) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateLeverage.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateLeverage proto.InternalMessageInfo

func (m *MsgUpdateLeverage) GetSubaccountId() *types.SubaccountId {
	if m != nil {
		return m.SubaccountId
	}
	return nil
}

func (m *MsgUpdateLeverage) GetClobPairLeverage() []*LeverageEntry {
	if m != nil {
		return m.ClobPairLeverage
	}
	return nil
}

// MsgUpdateLeverageResponse is a response type used for updating leverage.
type MsgUpdateLeverageResponse struct {
}

func (m *MsgUpdateLeverageResponse) Reset()         { *m = MsgUpdateLeverageResponse{} }
func (m *MsgUpdateLeverageResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateLeverageResponse) ProtoMessage()    {}
func (*MsgUpdateLeverageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{22}
}
func (m *MsgUpdateLeverageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateLeverageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateLeverageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateLeverageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateLeverageResponse.Merge(m, src)
}
func (m *MsgUpdateLeverageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateLeverageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateLeverageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateLeverageResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreateClobPair)(nil), "dydxprotocol.clob.MsgCreateClobPair")
	proto.RegisterType((*MsgCreateClobPairResponse)(nil), "dydxprotocol.clob.MsgCreateClobPairResponse")
	proto.RegisterType((*MsgProposedOperations)(nil), "dydxprotocol.clob.MsgProposedOperations")
	proto.RegisterType((*MsgProposedOperationsResponse)(nil), "dydxprotocol.clob.MsgProposedOperationsResponse")
	proto.RegisterType((*MsgPlaceOrder)(nil), "dydxprotocol.clob.MsgPlaceOrder")
	proto.RegisterType((*MsgPlaceOrderResponse)(nil), "dydxprotocol.clob.MsgPlaceOrderResponse")
	proto.RegisterType((*MsgCancelOrder)(nil), "dydxprotocol.clob.MsgCancelOrder")
	proto.RegisterType((*MsgCancelOrderResponse)(nil), "dydxprotocol.clob.MsgCancelOrderResponse")
	proto.RegisterType((*MsgBatchCancel)(nil), "dydxprotocol.clob.MsgBatchCancel")
	proto.RegisterType((*OrderBatch)(nil), "dydxprotocol.clob.OrderBatch")
	proto.RegisterType((*MsgBatchCancelResponse)(nil), "dydxprotocol.clob.MsgBatchCancelResponse")
	proto.RegisterType((*MsgUpdateClobPair)(nil), "dydxprotocol.clob.MsgUpdateClobPair")
	proto.RegisterType((*MsgUpdateClobPairResponse)(nil), "dydxprotocol.clob.MsgUpdateClobPairResponse")
	proto.RegisterType((*OperationRaw)(nil), "dydxprotocol.clob.OperationRaw")
	proto.RegisterType((*MsgUpdateEquityTierLimitConfiguration)(nil), "dydxprotocol.clob.MsgUpdateEquityTierLimitConfiguration")
	proto.RegisterType((*MsgUpdateEquityTierLimitConfigurationResponse)(nil), "dydxprotocol.clob.MsgUpdateEquityTierLimitConfigurationResponse")
	proto.RegisterType((*MsgUpdateBlockRateLimitConfiguration)(nil), "dydxprotocol.clob.MsgUpdateBlockRateLimitConfiguration")
	proto.RegisterType((*MsgUpdateBlockRateLimitConfigurationResponse)(nil), "dydxprotocol.clob.MsgUpdateBlockRateLimitConfigurationResponse")
	proto.RegisterType((*MsgUpdateLiquidationsConfig)(nil), "dydxprotocol.clob.MsgUpdateLiquidationsConfig")
	proto.RegisterType((*MsgUpdateLiquidationsConfigResponse)(nil), "dydxprotocol.clob.MsgUpdateLiquidationsConfigResponse")
	proto.RegisterType((*LeverageEntry)(nil), "dydxprotocol.clob.LeverageEntry")
	proto.RegisterType((*MsgUpdateLeverage)(nil), "dydxprotocol.clob.MsgUpdateLeverage")
	proto.RegisterType((*MsgUpdateLeverageResponse)(nil), "dydxprotocol.clob.MsgUpdateLeverageResponse")
}

func init() { proto.RegisterFile("dydxprotocol/clob/tx.proto", fileDescriptor_19b9e2c0de4ab64a) }

var fileDescriptor_19b9e2c0de4ab64a = []byte{
	// 1250 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xf7, 0xb6, 0x40, 0xeb, 0x17, 0x3b, 0x4d, 0xa7, 0x29, 0x71, 0xb7, 0xc4, 0x71, 0x4c, 0x12,
	0xb9, 0xd0, 0xd8, 0x25, 0x54, 0x01, 0x15, 0xf1, 0xe5, 0x28, 0x55, 0x22, 0x12, 0xe2, 0x6c, 0x82,
	0x40, 0x80, 0xb4, 0x5a, 0xef, 0x4e, 0x9c, 0x51, 0x77, 0x3d, 0x9b, 0xdd, 0x75, 0x48, 0xae, 0x95,
	0xb8, 0x73, 0x47, 0x48, 0xfc, 0x09, 0x1c, 0x7a, 0xe0, 0x0e, 0x87, 0x1e, 0x2b, 0x4e, 0x95, 0x40,
	0x80, 0x92, 0x03, 0xff, 0x06, 0xda, 0x9d, 0xdd, 0xf1, 0x6c, 0xf6, 0x23, 0x26, 0x70, 0xe0, 0x92,
	0xec, 0xcc, 0xfc, 0xde, 0xd7, 0xef, 0xbd, 0x79, 0x6f, 0x64, 0x90, 0x8d, 0x63, 0xe3, 0xc8, 0x76,
	0xa8, 0x47, 0x75, 0x6a, 0xb6, 0x74, 0x93, 0x76, 0x5b, 0xde, 0x51, 0x33, 0xd8, 0x40, 0xd7, 0xc5,
	0xb3, 0xa6, 0x7f, 0x26, 0xdf, 0xd2, 0xa9, 0x6b, 0x51, 0x57, 0x0d, 0x76, 0x5b, 0x6c, 0xc1, 0xd0,
	0xf2, 0x14, 0x5b, 0xb5, 0x2c, 0xb7, 0xd7, 0x3a, 0x7c, 0xc3, 0xff, 0x17, 0x1e, 0x4c, 0xf6, 0x68,
	0x8f, 0x32, 0x01, 0xff, 0x2b, 0xdc, 0x6d, 0x25, 0x0d, 0x77, 0x4d, 0xaa, 0x3f, 0x52, 0x1d, 0xcd,
	0xc3, 0xaa, 0x49, 0x2c, 0xe2, 0xa9, 0x3a, 0xed, 0xef, 0x91, 0x48, 0xcd, 0x6c, 0x52, 0xc0, 0xff,
	0xa3, 0xda, 0x1a, 0x71, 0x42, 0xc8, 0xbd, 0x24, 0x04, 0x1f, 0x0c, 0x88, 0x77, 0xac, 0x7a, 0x04,
	0x3b, 0x69, 0x4a, 0x67, 0x92, 0x12, 0x96, 0xe6, 0xe9, 0xfb, 0x38, 0x8a, 0x6a, 0x3a, 0x09, 0xa0,
	0x8e, 0x81, 0x23, 0x8b, 0x0b, 0x19, 0xc7, 0xaa, 0x83, 0x2d, 0x7a, 0xa8, 0x99, 0x91, 0x9a, 0xd7,
	0x93, 0x38, 0x93, 0x1c, 0x0c, 0x88, 0xa1, 0x79, 0x84, 0xf6, 0xdd, 0xb8, 0x53, 0x77, 0x62, 0x60,
	0x77, 0xd0, 0xd5, 0x74, 0x9d, 0x0e, 0xfa, 0x9e, 0x2b, 0x7c, 0x33, 0x68, 0xfd, 0x5b, 0x09, 0xae,
	0x6f, 0xba, 0xbd, 0x15, 0x07, 0x6b, 0x1e, 0x5e, 0x31, 0x69, 0xb7, 0xa3, 0x11, 0x07, 0x2d, 0x43,
	0x51, 0x1b, 0x78, 0xfb, 0xd4, 0x21, 0xde, 0x71, 0x45, 0xaa, 0x49, 0x8d, 0x62, 0xbb, 0xf2, 0xcb,
	0x93, 0xc5, 0xc9, 0x30, 0x5f, 0x1f, 0x1a, 0x86, 0x83, 0x5d, 0x77, 0xc7, 0x73, 0x48, 0xbf, 0xa7,
	0x0c, 0xa1, 0xe8, 0x3d, 0x28, 0x72, 0x4a, 0x2b, 0x97, 0x6a, 0x52, 0x63, 0x6c, 0xe9, 0x76, 0x33,
	0x51, 0x04, 0xcd, 0xc8, 0x4e, 0xfb, 0x85, 0xa7, 0xbf, 0xcf, 0x14, 0x94, 0xab, 0x7a, 0xb8, 0x7e,
	0x30, 0xfe, 0xf8, 0xaf, 0x1f, 0x5e, 0x1b, 0xea, 0xab, 0xdf, 0x86, 0x5b, 0x09, 0xe7, 0x14, 0xec,
	0xda, 0xb4, 0xef, 0xe2, 0x3a, 0x81, 0x9b, 0x9b, 0x6e, 0xaf, 0xe3, 0x50, 0x9b, 0xba, 0xd8, 0xd8,
	0xb2, 0xb1, 0xc3, 0xb8, 0x40, 0x1d, 0x98, 0xa0, 0x7c, 0xa5, 0x1e, 0x0c, 0xf0, 0x00, 0x57, 0xa4,
	0xda, 0xe5, 0xc6, 0xd8, 0xd2, 0x4c, 0x8a, 0x33, 0x5c, 0x50, 0xd1, 0xbe, 0x0a, 0x1d, 0xba, 0x36,
	0x14, 0xdf, 0xf6, 0xa5, 0xeb, 0x33, 0x30, 0x9d, 0x6a, 0x8a, 0xfb, 0xb2, 0x0a, 0x65, 0x1f, 0x60,
	0x6a, 0x3a, 0xde, 0xf2, 0xd3, 0x87, 0xee, 0xc3, 0x8b, 0x41, 0x1e, 0x03, 0xf6, 0xc6, 0x96, 0x2a,
	0x69, 0x86, 0xfd, 0xf3, 0xd0, 0x22, 0x03, 0xd7, 0xa7, 0x58, 0x48, 0x5c, 0x0d, 0xd7, 0xff, 0xa3,
	0x04, 0xe3, 0x3e, 0x13, 0x5a, 0x5f, 0xc7, 0x26, 0xb3, 0xf0, 0x0e, 0x5c, 0x65, 0x95, 0x42, 0x8c,
	0xd0, 0x88, 0x9c, 0x65, 0x64, 0xdd, 0x08, 0xcd, 0x5c, 0xa1, 0x6c, 0x89, 0x16, 0x60, 0xbc, 0x47,
	0xa9, 0xa1, 0x7a, 0xc4, 0x54, 0x83, 0x5b, 0x13, 0x64, 0xab, 0xbc, 0x56, 0x50, 0x4a, 0xfe, 0xfe,
	0x2e, 0x31, 0xdb, 0xfe, 0x2e, 0x6a, 0xc1, 0x8d, 0x38, 0x4e, 0xf5, 0x88, 0x85, 0x2b, 0x97, 0x6b,
	0x52, 0xe3, 0xca, 0x5a, 0x41, 0x99, 0x10, 0xc1, 0xbb, 0xc4, 0xc2, 0xed, 0x09, 0x41, 0x31, 0xed,
	0x63, 0xba, 0x57, 0xaf, 0xc0, 0xcb, 0x71, 0xcf, 0x79, 0x50, 0xbf, 0xb1, 0xa0, 0xda, 0xfe, 0x7d,
	0x61, 0xe7, 0x68, 0x1b, 0xca, 0xc3, 0x12, 0x1d, 0x46, 0xb6, 0x10, 0x8f, 0x4c, 0xa8, 0xe8, 0xe6,
	0x0e, 0xff, 0xe6, 0x51, 0x96, 0x5c, 0x61, 0x0f, 0x6d, 0x03, 0x72, 0xf7, 0xa9, 0xe3, 0xa9, 0x1e,
	0x76, 0x2c, 0x55, 0x0f, 0xec, 0xb8, 0x95, 0x4b, 0x41, 0x3d, 0x4c, 0x67, 0xa6, 0xc5, 0xf7, 0x29,
	0x54, 0x37, 0x11, 0x88, 0xef, 0x62, 0xc7, 0x62, 0x4e, 0xba, 0x68, 0x2e, 0xc1, 0x9e, 0x4f, 0x48,
	0x39, 0xce, 0x5d, 0x7d, 0x13, 0x60, 0xa8, 0x0b, 0xd5, 0xa0, 0xc4, 0xaf, 0x46, 0x14, 0x58, 0x59,
	0x81, 0xa8, 0xf4, 0xd7, 0x0d, 0x34, 0x0d, 0xa0, 0x9b, 0x04, 0x07, 0x71, 0x33, 0x07, 0xcb, 0x4a,
	0x91, 0xed, 0xac, 0x1b, 0x6e, 0xfd, 0x89, 0x14, 0x10, 0x29, 0xb0, 0x15, 0x11, 0x89, 0xb6, 0x60,
	0x52, 0x08, 0xd1, 0x1d, 0xe8, 0x3a, 0xc6, 0x06, 0x36, 0xc2, 0xa2, 0xcf, 0x0f, 0x52, 0x41, 0x3c,
	0xbc, 0x9d, 0x48, 0x10, 0xad, 0xc3, 0x75, 0x41, 0xe1, 0x9e, 0x46, 0x4c, 0x6c, 0x8c, 0x44, 0x99,
	0x72, 0x8d, 0x6b, 0x7b, 0x18, 0x48, 0x45, 0x0d, 0xe6, 0x13, 0xdb, 0xf8, 0xff, 0x36, 0x98, 0xb8,
	0x73, 0xbc, 0x3e, 0x9f, 0x4b, 0x50, 0x12, 0xbb, 0x83, 0x7f, 0xa9, 0x83, 0xe6, 0x1e, 0x56, 0xe5,
	0x2b, 0x19, 0x96, 0x37, 0x7d, 0xcc, 0x5a, 0x41, 0x61, 0x60, 0xf4, 0x2e, 0xc8, 0x02, 0x99, 0xec,
	0xce, 0xda, 0xfe, 0x15, 0xb7, 0x70, 0xdf, 0x0b, 0x82, 0x28, 0xad, 0x15, 0x94, 0x29, 0x4e, 0x5c,
	0xc0, 0x66, 0x27, 0x02, 0xa0, 0x87, 0x50, 0x8e, 0x4d, 0x84, 0xa0, 0xd6, 0x32, 0x5a, 0x19, 0xbb,
	0x5e, 0x01, 0xcc, 0xbf, 0xca, 0x54, 0x58, 0xb7, 0xc7, 0xa0, 0xc8, 0xdb, 0x5a, 0xfd, 0x0f, 0x09,
	0xe6, 0x79, 0xe0, 0xab, 0xc1, 0x88, 0xdb, 0x25, 0xd8, 0xd9, 0xf0, 0x07, 0xdc, 0x4a, 0x30, 0x4a,
	0x06, 0x0c, 0x79, 0xe1, 0x4c, 0xf5, 0xa1, 0x92, 0x35, 0x3a, 0xc3, 0xc4, 0xb5, 0x52, 0x22, 0xc8,
	0x73, 0x25, 0x4c, 0xe6, 0x4d, 0x9c, 0x86, 0x49, 0x64, 0xb6, 0x05, 0x8b, 0x23, 0x05, 0xc8, 0xb3,
	0xfd, 0xab, 0x04, 0x73, 0x5c, 0x22, 0xb8, 0xc1, 0x8a, 0xe6, 0xe1, 0xff, 0x90, 0x91, 0x47, 0x30,
	0x95, 0xf1, 0x40, 0x09, 0x53, 0xda, 0x4c, 0x21, 0x24, 0xc7, 0x91, 0x90, 0x8f, 0xc9, 0x6e, 0x0a,
	0x24, 0x41, 0x47, 0x13, 0xee, 0x8e, 0x12, 0x1c, 0x67, 0xe3, 0x27, 0x09, 0x6e, 0x73, 0x81, 0x0d,
	0xe1, 0xa5, 0xc1, 0xe0, 0x17, 0x26, 0xe1, 0x4b, 0xb8, 0x91, 0xf2, 0x6e, 0x09, 0x2b, 0x62, 0x3e,
	0x85, 0x80, 0xa4, 0xed, 0x30, 0x6e, 0x64, 0x26, 0x4e, 0x12, 0x51, 0xcf, 0xc3, 0xab, 0x39, 0x41,
	0xf0, 0x60, 0x3f, 0x85, 0xf2, 0x06, 0x3e, 0xc4, 0x8e, 0xd6, 0xc3, 0xab, 0x7d, 0xcf, 0x39, 0x1e,
	0xa1, 0x59, 0xcf, 0xc1, 0xb8, 0x3e, 0x70, 0x3d, 0x6a, 0xa9, 0xc4, 0xda, 0x53, 0x6d, 0xdb, 0x62,
	0x03, 0x54, 0x29, 0xb1, 0xdd, 0x75, 0x6b, 0xaf, 0x63, 0x5b, 0xf5, 0x9f, 0xc5, 0xe6, 0x17, 0x99,
	0x40, 0x1f, 0xfd, 0xab, 0x21, 0x77, 0x66, 0xbc, 0x7d, 0x0c, 0x68, 0xe8, 0xaa, 0x19, 0x9a, 0x08,
	0x7b, 0x75, 0x2d, 0x8d, 0x4f, 0x31, 0x50, 0x65, 0x22, 0x0a, 0x29, 0xda, 0x7e, 0x80, 0x7c, 0x0a,
	0xe3, 0xfe, 0xc5, 0xba, 0x64, 0x04, 0x8c, 0xc8, 0x5b, 0xfa, 0xba, 0x08, 0x97, 0x37, 0xdd, 0x1e,
	0xb2, 0x01, 0xa5, 0xbc, 0xc5, 0x1a, 0x29, 0x2e, 0xa4, 0x3e, 0xa5, 0xe4, 0x7b, 0xa3, 0x22, 0xf9,
	0xd8, 0xfb, 0x0c, 0x40, 0x78, 0x71, 0xd5, 0x32, 0xe4, 0x39, 0x42, 0x6e, 0x9c, 0x87, 0xe0, 0x9a,
	0xbf, 0x80, 0x31, 0xf1, 0xa9, 0x35, 0x9b, 0x2e, 0x28, 0x40, 0xe4, 0x3b, 0xe7, 0x42, 0x44, 0xe5,
	0xe2, 0x93, 0x27, 0x43, 0xb9, 0x00, 0xc9, 0x52, 0x9e, 0xf6, 0x14, 0x30, 0x60, 0xfc, 0xcc, 0x5b,
	0x7e, 0x2e, 0xc3, 0xb3, 0x18, 0x4a, 0xbe, 0x3b, 0x0a, 0x4a, 0xb4, 0x72, 0x66, 0xa0, 0x67, 0x58,
	0x89, 0xa3, 0xb2, 0xac, 0xa4, 0xcf, 0x5f, 0xf4, 0xbd, 0x04, 0xf5, 0x11, 0x26, 0xd4, 0xdb, 0x79,
	0x4a, 0xf3, 0x24, 0xe5, 0x0f, 0x2e, 0x2a, 0xc9, 0x5d, 0xfc, 0x4e, 0x82, 0xd9, 0xf3, 0x27, 0xc6,
	0x5b, 0x79, 0x76, 0x72, 0x04, 0xe5, 0xf7, 0x2f, 0x28, 0xc8, 0xfd, 0x7b, 0x2c, 0x41, 0x25, 0xb3,
	0x87, 0x37, 0xf3, 0xb4, 0x27, 0xf1, 0xf2, 0xf2, 0x3f, 0xc3, 0x27, 0xab, 0x85, 0x77, 0xc0, 0xdc,
	0x6a, 0x89, 0x50, 0xf9, 0xd5, 0x72, 0xb6, 0x0f, 0xb5, 0x3b, 0x4f, 0x4f, 0xaa, 0xd2, 0xb3, 0x93,
	0xaa, 0xf4, 0xe7, 0x49, 0x55, 0xfa, 0xe6, 0xb4, 0x5a, 0x78, 0x76, 0x5a, 0x2d, 0x3c, 0x3f, 0xad,
	0x16, 0x3e, 0x5f, 0xee, 0x11, 0x6f, 0x7f, 0xd0, 0x6d, 0xea, 0xd4, 0x8a, 0xff, 0x68, 0x70, 0x78,
	0x7f, 0x51, 0xdf, 0xd7, 0x48, 0xbf, 0xc5, 0x77, 0x8e, 0xc2, 0x5f, 0x30, 0x8e, 0x6d, 0xec, 0x76,
	0x5f, 0x0a, 0xb6, 0xdf, 0xfc, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xcd, 0x24, 0x47, 0xbc, 0xe3, 0x10,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// ProposedOperations is a temporary message used by block proposers
	// for matching orders as part of the ABCI++ workaround.
	ProposedOperations(ctx context.Context, in *MsgProposedOperations, opts ...grpc.CallOption) (*MsgProposedOperationsResponse, error)
	// PlaceOrder allows accounts to place orders on the orderbook.
	PlaceOrder(ctx context.Context, in *MsgPlaceOrder, opts ...grpc.CallOption) (*MsgPlaceOrderResponse, error)
	// CancelOrder allows accounts to cancel existing orders on the orderbook.
	CancelOrder(ctx context.Context, in *MsgCancelOrder, opts ...grpc.CallOption) (*MsgCancelOrderResponse, error)
	// BatchCancel allows accounts to cancel a batch of orders on the orderbook.
	BatchCancel(ctx context.Context, in *MsgBatchCancel, opts ...grpc.CallOption) (*MsgBatchCancelResponse, error)
	// CreateClobPair creates a new clob pair.
	CreateClobPair(ctx context.Context, in *MsgCreateClobPair, opts ...grpc.CallOption) (*MsgCreateClobPairResponse, error)
	// UpdateClobPair sets the status of a clob pair. Should return an error
	// if the authority is not in the clob keeper's set of authorities,
	// if the ClobPair id is not found in state, or if the update includes
	// an unsupported status transition.
	UpdateClobPair(ctx context.Context, in *MsgUpdateClobPair, opts ...grpc.CallOption) (*MsgUpdateClobPairResponse, error)
	// UpdateEquityTierLimitConfiguration updates the equity tier limit
	// configuration in state.
	UpdateEquityTierLimitConfiguration(ctx context.Context, in *MsgUpdateEquityTierLimitConfiguration, opts ...grpc.CallOption) (*MsgUpdateEquityTierLimitConfigurationResponse, error)
	// UpdateBlockRateLimitConfiguration updates the block rate limit
	// configuration in state.
	UpdateBlockRateLimitConfiguration(ctx context.Context, in *MsgUpdateBlockRateLimitConfiguration, opts ...grpc.CallOption) (*MsgUpdateBlockRateLimitConfigurationResponse, error)
	// UpdateLiquidationsConfig updates the liquidations configuration in state.
	UpdateLiquidationsConfig(ctx context.Context, in *MsgUpdateLiquidationsConfig, opts ...grpc.CallOption) (*MsgUpdateLiquidationsConfigResponse, error)
	// UpdateLeverage allows accounts to update their desired leverage for
	// clob pairs.
	UpdateLeverage(ctx context.Context, in *MsgUpdateLeverage, opts ...grpc.CallOption) (*MsgUpdateLeverageResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) ProposedOperations(ctx context.Context, in *MsgProposedOperations, opts ...grpc.CallOption) (*MsgProposedOperationsResponse, error) {
	out := new(MsgProposedOperationsResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/ProposedOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PlaceOrder(ctx context.Context, in *MsgPlaceOrder, opts ...grpc.CallOption) (*MsgPlaceOrderResponse, error) {
	out := new(MsgPlaceOrderResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/PlaceOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelOrder(ctx context.Context, in *MsgCancelOrder, opts ...grpc.CallOption) (*MsgCancelOrderResponse, error) {
	out := new(MsgCancelOrderResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancel(ctx context.Context, in *MsgBatchCancel, opts ...grpc.CallOption) (*MsgBatchCancelResponse, error) {
	out := new(MsgBatchCancelResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/BatchCancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateClobPair(ctx context.Context, in *MsgCreateClobPair, opts ...grpc.CallOption) (*MsgCreateClobPairResponse, error) {
	out := new(MsgCreateClobPairResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/CreateClobPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClobPair(ctx context.Context, in *MsgUpdateClobPair, opts ...grpc.CallOption) (*MsgUpdateClobPairResponse, error) {
	out := new(MsgUpdateClobPairResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/UpdateClobPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateEquityTierLimitConfiguration(ctx context.Context, in *MsgUpdateEquityTierLimitConfiguration, opts ...grpc.CallOption) (*MsgUpdateEquityTierLimitConfigurationResponse, error) {
	out := new(MsgUpdateEquityTierLimitConfigurationResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/UpdateEquityTierLimitConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateBlockRateLimitConfiguration(ctx context.Context, in *MsgUpdateBlockRateLimitConfiguration, opts ...grpc.CallOption) (*MsgUpdateBlockRateLimitConfigurationResponse, error) {
	out := new(MsgUpdateBlockRateLimitConfigurationResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/UpdateBlockRateLimitConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateLiquidationsConfig(ctx context.Context, in *MsgUpdateLiquidationsConfig, opts ...grpc.CallOption) (*MsgUpdateLiquidationsConfigResponse, error) {
	out := new(MsgUpdateLiquidationsConfigResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/UpdateLiquidationsConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateLeverage(ctx context.Context, in *MsgUpdateLeverage, opts ...grpc.CallOption) (*MsgUpdateLeverageResponse, error) {
	out := new(MsgUpdateLeverageResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/UpdateLeverage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// ProposedOperations is a temporary message used by block proposers
	// for matching orders as part of the ABCI++ workaround.
	ProposedOperations(context.Context, *MsgProposedOperations) (*MsgProposedOperationsResponse, error)
	// PlaceOrder allows accounts to place orders on the orderbook.
	PlaceOrder(context.Context, *MsgPlaceOrder) (*MsgPlaceOrderResponse, error)
	// CancelOrder allows accounts to cancel existing orders on the orderbook.
	CancelOrder(context.Context, *MsgCancelOrder) (*MsgCancelOrderResponse, error)
	// BatchCancel allows accounts to cancel a batch of orders on the orderbook.
	BatchCancel(context.Context, *MsgBatchCancel) (*MsgBatchCancelResponse, error)
	// CreateClobPair creates a new clob pair.
	CreateClobPair(context.Context, *MsgCreateClobPair) (*MsgCreateClobPairResponse, error)
	// UpdateClobPair sets the status of a clob pair. Should return an error
	// if the authority is not in the clob keeper's set of authorities,
	// if the ClobPair id is not found in state, or if the update includes
	// an unsupported status transition.
	UpdateClobPair(context.Context, *MsgUpdateClobPair) (*MsgUpdateClobPairResponse, error)
	// UpdateEquityTierLimitConfiguration updates the equity tier limit
	// configuration in state.
	UpdateEquityTierLimitConfiguration(context.Context, *MsgUpdateEquityTierLimitConfiguration) (*MsgUpdateEquityTierLimitConfigurationResponse, error)
	// UpdateBlockRateLimitConfiguration updates the block rate limit
	// configuration in state.
	UpdateBlockRateLimitConfiguration(context.Context, *MsgUpdateBlockRateLimitConfiguration) (*MsgUpdateBlockRateLimitConfigurationResponse, error)
	// UpdateLiquidationsConfig updates the liquidations configuration in state.
	UpdateLiquidationsConfig(context.Context, *MsgUpdateLiquidationsConfig) (*MsgUpdateLiquidationsConfigResponse, error)
	// UpdateLeverage allows accounts to update their desired leverage for
	// clob pairs.
	UpdateLeverage(context.Context, *MsgUpdateLeverage) (*MsgUpdateLeverageResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) ProposedOperations(ctx context.Context, req *MsgProposedOperations) (*MsgProposedOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposedOperations not implemented")
}
func (*UnimplementedMsgServer) PlaceOrder(ctx context.Context, req *MsgPlaceOrder) (*MsgPlaceOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceOrder not implemented")
}
func (*UnimplementedMsgServer) CancelOrder(ctx context.Context, req *MsgCancelOrder) (*MsgCancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCancel(ctx context.Context, req *MsgBatchCancel) (*MsgBatchCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancel not implemented")
}
func (*UnimplementedMsgServer) CreateClobPair(ctx context.Context, req *MsgCreateClobPair) (*MsgCreateClobPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClobPair not implemented")
}
func (*UnimplementedMsgServer) UpdateClobPair(ctx context.Context, req *MsgUpdateClobPair) (*MsgUpdateClobPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClobPair not implemented")
}
func (*UnimplementedMsgServer) UpdateEquityTierLimitConfiguration(ctx context.Context, req *MsgUpdateEquityTierLimitConfiguration) (*MsgUpdateEquityTierLimitConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEquityTierLimitConfiguration not implemented")
}
func (*UnimplementedMsgServer) UpdateBlockRateLimitConfiguration(ctx context.Context, req *MsgUpdateBlockRateLimitConfiguration) (*MsgUpdateBlockRateLimitConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBlockRateLimitConfiguration not implemented")
}
func (*UnimplementedMsgServer) UpdateLiquidationsConfig(ctx context.Context, req *MsgUpdateLiquidationsConfig) (*MsgUpdateLiquidationsConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLiquidationsConfig not implemented")
}
func (*UnimplementedMsgServer) UpdateLeverage(ctx context.Context, req *MsgUpdateLeverage) (*MsgUpdateLeverageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLeverage not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_ProposedOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProposedOperations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProposedOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/ProposedOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProposedOperations(ctx, req.(*MsgProposedOperations))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PlaceOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPlaceOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PlaceOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/PlaceOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PlaceOrder(ctx, req.(*MsgPlaceOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelOrder(ctx, req.(*MsgCancelOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/BatchCancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancel(ctx, req.(*MsgBatchCancel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateClobPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateClobPair)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateClobPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/CreateClobPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateClobPair(ctx, req.(*MsgCreateClobPair))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClobPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClobPair)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClobPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/UpdateClobPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClobPair(ctx, req.(*MsgUpdateClobPair))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateEquityTierLimitConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateEquityTierLimitConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateEquityTierLimitConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/UpdateEquityTierLimitConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateEquityTierLimitConfiguration(ctx, req.(*MsgUpdateEquityTierLimitConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateBlockRateLimitConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateBlockRateLimitConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateBlockRateLimitConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/UpdateBlockRateLimitConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateBlockRateLimitConfiguration(ctx, req.(*MsgUpdateBlockRateLimitConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateLiquidationsConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateLiquidationsConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateLiquidationsConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/UpdateLiquidationsConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateLiquidationsConfig(ctx, req.(*MsgUpdateLiquidationsConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateLeverage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateLeverage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateLeverage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/UpdateLeverage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateLeverage(ctx, req.(*MsgUpdateLeverage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dydxprotocol.clob.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProposedOperations",
			Handler:    _Msg_ProposedOperations_Handler,
		},
		{
			MethodName: "PlaceOrder",
			Handler:    _Msg_PlaceOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Msg_CancelOrder_Handler,
		},
		{
			MethodName: "BatchCancel",
			Handler:    _Msg_BatchCancel_Handler,
		},
		{
			MethodName: "CreateClobPair",
			Handler:    _Msg_CreateClobPair_Handler,
		},
		{
			MethodName: "UpdateClobPair",
			Handler:    _Msg_UpdateClobPair_Handler,
		},
		{
			MethodName: "UpdateEquityTierLimitConfiguration",
			Handler:    _Msg_UpdateEquityTierLimitConfiguration_Handler,
		},
		{
			MethodName: "UpdateBlockRateLimitConfiguration",
			Handler:    _Msg_UpdateBlockRateLimitConfiguration_Handler,
		},
		{
			MethodName: "UpdateLiquidationsConfig",
			Handler:    _Msg_UpdateLiquidationsConfig_Handler,
		},
		{
			MethodName: "UpdateLeverage",
			Handler:    _Msg_UpdateLeverage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dydxprotocol/clob/tx.proto",
}

func (m *MsgCreateClobPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateClobPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateClobPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ClobPair.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateClobPairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateClobPairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateClobPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgProposedOperations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposedOperations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposedOperations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperationsQueue) > 0 {
		for iNdEx := len(m.OperationsQueue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperationsQueue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposedOperationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposedOperationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposedOperationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPlaceOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlaceOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlaceOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPlaceOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlaceOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlaceOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCancelOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GoodTilOneof != nil {
		{
			size := m.GoodTilOneof.Size()
			i -= size
			if _, err := m.GoodTilOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	{
		size, err := m.OrderId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCancelOrder_GoodTilBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder_GoodTilBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTx(dAtA, i, uint64(m.GoodTilBlock))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *MsgCancelOrder_GoodTilBlockTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder_GoodTilBlockTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.GoodTilBlockTime))
	i--
	dAtA[i] = 0x1d
	return len(dAtA) - i, nil
}
func (m *MsgCancelOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GoodTilBlock != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GoodTilBlock))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ShortTermCancels) > 0 {
		for iNdEx := len(m.ShortTermCancels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShortTermCancels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.SubaccountId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OrderBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientIds) > 0 {
		dAtA6 := make([]byte, len(m.ClientIds)*10)
		var j5 int
		for _, num := range m.ClientIds {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTx(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if m.ClobPairId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShortTermFailed) > 0 {
		for iNdEx := len(m.ShortTermFailed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShortTermFailed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ShortTermSucceeded) > 0 {
		for iNdEx := len(m.ShortTermSucceeded) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShortTermSucceeded[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClobPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClobPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClobPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ClobPair.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClobPairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClobPairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClobPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OperationRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationRaw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		{
			size := m.Operation.Size()
			i -= size
			if _, err := m.Operation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OperationRaw_Match) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OperationRaw_ShortTermOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_ShortTermOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShortTermOrderPlacement != nil {
		i -= len(m.ShortTermOrderPlacement)
		copy(dAtA[i:], m.ShortTermOrderPlacement)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShortTermOrderPlacement)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OperationRaw_OrderRemoval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_OrderRemoval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderRemoval != nil {
		{
			size, err := m.OrderRemoval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MsgUpdateEquityTierLimitConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateEquityTierLimitConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateEquityTierLimitConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.EquityTierLimitConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateEquityTierLimitConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateEquityTierLimitConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateEquityTierLimitConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBlockRateLimitConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBlockRateLimitConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBlockRateLimitConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BlockRateLimitConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBlockRateLimitConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBlockRateLimitConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBlockRateLimitConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateLiquidationsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateLiquidationsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateLiquidationsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LiquidationsConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateLiquidationsConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateLiquidationsConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateLiquidationsConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LeverageEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeverageEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeverageEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CustomImfPpm != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CustomImfPpm))
		i--
		dAtA[i] = 0x10
	}
	if m.ClobPairId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateLeverage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateLeverage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateLeverage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClobPairLeverage) > 0 {
		for iNdEx := len(m.ClobPairLeverage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClobPairLeverage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SubaccountId != nil {
		{
			size, err := m.SubaccountId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateLeverageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateLeverageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateLeverageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateClobPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.ClobPair.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateClobPairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgProposedOperations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OperationsQueue) > 0 {
		for _, e := range m.OperationsQueue {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgProposedOperationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPlaceOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPlaceOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCancelOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OrderId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.GoodTilOneof != nil {
		n += m.GoodTilOneof.Size()
	}
	return n
}

func (m *MsgCancelOrder_GoodTilBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTx(uint64(m.GoodTilBlock))
	return n
}
func (m *MsgCancelOrder_GoodTilBlockTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *MsgCancelOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBatchCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SubaccountId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.ShortTermCancels) > 0 {
		for _, e := range m.ShortTermCancels {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.GoodTilBlock != 0 {
		n += 1 + sovTx(uint64(m.GoodTilBlock))
	}
	return n
}

func (m *OrderBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClobPairId != 0 {
		n += 1 + sovTx(uint64(m.ClobPairId))
	}
	if len(m.ClientIds) > 0 {
		l = 0
		for _, e := range m.ClientIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	return n
}

func (m *MsgBatchCancelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ShortTermSucceeded) > 0 {
		for _, e := range m.ShortTermSucceeded {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.ShortTermFailed) > 0 {
		for _, e := range m.ShortTermFailed {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateClobPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.ClobPair.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateClobPairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OperationRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		n += m.Operation.Size()
	}
	return n
}

func (m *OperationRaw_Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *OperationRaw_ShortTermOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShortTermOrderPlacement != nil {
		l = len(m.ShortTermOrderPlacement)
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *OperationRaw_OrderRemoval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderRemoval != nil {
		l = m.OrderRemoval.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *MsgUpdateEquityTierLimitConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.EquityTierLimitConfig.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateEquityTierLimitConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateBlockRateLimitConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.BlockRateLimitConfig.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateBlockRateLimitConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateLiquidationsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.LiquidationsConfig.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateLiquidationsConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LeverageEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClobPairId != 0 {
		n += 1 + sovTx(uint64(m.ClobPairId))
	}
	if m.CustomImfPpm != 0 {
		n += 1 + sovTx(uint64(m.CustomImfPpm))
	}
	return n
}

func (m *MsgUpdateLeverage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubaccountId != nil {
		l = m.SubaccountId.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ClobPairLeverage) > 0 {
		for _, e := range m.ClobPairLeverage {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateLeverageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateClobPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateClobPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateClobPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClobPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateClobPairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateClobPairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateClobPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposedOperations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposedOperations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposedOperations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationsQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationsQueue = append(m.OperationsQueue, OperationRaw{})
			if err := m.OperationsQueue[len(m.OperationsQueue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposedOperationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposedOperationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposedOperationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlaceOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlaceOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlaceOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlaceOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlaceOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlaceOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlock", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GoodTilOneof = &MsgCancelOrder_GoodTilBlock{v}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlockTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GoodTilOneof = &MsgCancelOrder_GoodTilBlockTime{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortTermCancels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortTermCancels = append(m.ShortTermCancels, OrderBatch{})
			if err := m.ShortTermCancels[len(m.ShortTermCancels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlock", wireType)
			}
			m.GoodTilBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodTilBlock |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClientIds = append(m.ClientIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ClientIds) == 0 {
					m.ClientIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClientIds = append(m.ClientIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortTermSucceeded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortTermSucceeded = append(m.ShortTermSucceeded, &OrderBatch{})
			if err := m.ShortTermSucceeded[len(m.ShortTermSucceeded)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortTermFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortTermFailed = append(m.ShortTermFailed, &OrderBatch{})
			if err := m.ShortTermFailed[len(m.ShortTermFailed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClobPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClobPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClobPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClobPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClobPairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClobPairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClobPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClobMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &OperationRaw_Match{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortTermOrderPlacement", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Operation = &OperationRaw_ShortTermOrderPlacement{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRemoval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderRemoval{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &OperationRaw_OrderRemoval{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateEquityTierLimitConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateEquityTierLimitConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateEquityTierLimitConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquityTierLimitConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EquityTierLimitConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateEquityTierLimitConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateEquityTierLimitConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateEquityTierLimitConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBlockRateLimitConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBlockRateLimitConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBlockRateLimitConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRateLimitConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockRateLimitConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBlockRateLimitConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBlockRateLimitConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBlockRateLimitConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateLiquidationsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateLiquidationsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateLiquidationsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidationsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateLiquidationsConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateLiquidationsConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateLiquidationsConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeverageEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeverageEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeverageEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomImfPpm", wireType)
			}
			m.CustomImfPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomImfPpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateLeverage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateLeverage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateLeverage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubaccountId == nil {
				m.SubaccountId = &types.SubaccountId{}
			}
			if err := m.SubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairLeverage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClobPairLeverage = append(m.ClobPairLeverage, &LeverageEntry{})
			if err := m.ClobPairLeverage[len(m.ClobPairLeverage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateLeverageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateLeverageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateLeverageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
