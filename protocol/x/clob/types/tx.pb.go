// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/clob/tx.proto

package types

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateClobPair is a message used by x/gov for creating a new clob pair.
type MsgCreateClobPair struct {
	// The address that controls the module.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// `clob_pair` defines parameters for the new clob pair.
	ClobPair *ClobPair `protobuf:"bytes,2,opt,name=clob_pair,json=clobPair,proto3" json:"clob_pair,omitempty"`
}

func (m *MsgCreateClobPair) Reset()         { *m = MsgCreateClobPair{} }
func (m *MsgCreateClobPair) String() string { return proto.CompactTextString(m) }
func (*MsgCreateClobPair) ProtoMessage()    {}
func (*MsgCreateClobPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{0}
}
func (m *MsgCreateClobPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateClobPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateClobPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateClobPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateClobPair.Merge(m, src)
}
func (m *MsgCreateClobPair) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateClobPair) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateClobPair.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateClobPair proto.InternalMessageInfo

func (m *MsgCreateClobPair) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgCreateClobPair) GetClobPair() *ClobPair {
	if m != nil {
		return m.ClobPair
	}
	return nil
}

// MsgCreateClobPairResponse defines the CreateClobPair response type.
type MsgCreateClobPairResponse struct {
}

func (m *MsgCreateClobPairResponse) Reset()         { *m = MsgCreateClobPairResponse{} }
func (m *MsgCreateClobPairResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateClobPairResponse) ProtoMessage()    {}
func (*MsgCreateClobPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{1}
}
func (m *MsgCreateClobPairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateClobPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateClobPairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateClobPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateClobPairResponse.Merge(m, src)
}
func (m *MsgCreateClobPairResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateClobPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateClobPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateClobPairResponse proto.InternalMessageInfo

// MsgProposedOperations is a message injected by block proposers to
// specify the operations that occurred in a block.
type MsgProposedOperations struct {
	// The list of operations proposed by the block proposer.
	OperationsQueue []OperationRaw `protobuf:"bytes,1,rep,name=operations_queue,json=operationsQueue,proto3" json:"operations_queue"`
}

func (m *MsgProposedOperations) Reset()         { *m = MsgProposedOperations{} }
func (m *MsgProposedOperations) String() string { return proto.CompactTextString(m) }
func (*MsgProposedOperations) ProtoMessage()    {}
func (*MsgProposedOperations) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{2}
}
func (m *MsgProposedOperations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposedOperations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposedOperations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposedOperations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposedOperations.Merge(m, src)
}
func (m *MsgProposedOperations) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposedOperations) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposedOperations.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposedOperations proto.InternalMessageInfo

func (m *MsgProposedOperations) GetOperationsQueue() []OperationRaw {
	if m != nil {
		return m.OperationsQueue
	}
	return nil
}

// MsgProposedOperationsResponse is the response type of the message injected
// by block proposers to specify the operations that occurred in a block.
type MsgProposedOperationsResponse struct {
}

func (m *MsgProposedOperationsResponse) Reset()         { *m = MsgProposedOperationsResponse{} }
func (m *MsgProposedOperationsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposedOperationsResponse) ProtoMessage()    {}
func (*MsgProposedOperationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{3}
}
func (m *MsgProposedOperationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposedOperationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposedOperationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposedOperationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposedOperationsResponse.Merge(m, src)
}
func (m *MsgProposedOperationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposedOperationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposedOperationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposedOperationsResponse proto.InternalMessageInfo

// MsgPlaceOrder is a request type used for placing orders.
type MsgPlaceOrder struct {
	Order Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order"`
}

func (m *MsgPlaceOrder) Reset()         { *m = MsgPlaceOrder{} }
func (m *MsgPlaceOrder) String() string { return proto.CompactTextString(m) }
func (*MsgPlaceOrder) ProtoMessage()    {}
func (*MsgPlaceOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{4}
}
func (m *MsgPlaceOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlaceOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlaceOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlaceOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlaceOrder.Merge(m, src)
}
func (m *MsgPlaceOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlaceOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlaceOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlaceOrder proto.InternalMessageInfo

func (m *MsgPlaceOrder) GetOrder() Order {
	if m != nil {
		return m.Order
	}
	return Order{}
}

// MsgPlaceOrderResponse is a response type used for placing orders.
type MsgPlaceOrderResponse struct {
}

func (m *MsgPlaceOrderResponse) Reset()         { *m = MsgPlaceOrderResponse{} }
func (m *MsgPlaceOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPlaceOrderResponse) ProtoMessage()    {}
func (*MsgPlaceOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{5}
}
func (m *MsgPlaceOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlaceOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlaceOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlaceOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlaceOrderResponse.Merge(m, src)
}
func (m *MsgPlaceOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlaceOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlaceOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlaceOrderResponse proto.InternalMessageInfo

// MsgCancelOrder is a request type used for canceling orders.
type MsgCancelOrder struct {
	OrderId OrderId `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	// Information about when the order cancellation expires.
	//
	// Types that are valid to be assigned to GoodTilOneof:
	//	*MsgCancelOrder_GoodTilBlock
	//	*MsgCancelOrder_GoodTilBlockTime
	GoodTilOneof isMsgCancelOrder_GoodTilOneof `protobuf_oneof:"good_til_oneof"`
}

func (m *MsgCancelOrder) Reset()         { *m = MsgCancelOrder{} }
func (m *MsgCancelOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelOrder) ProtoMessage()    {}
func (*MsgCancelOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{6}
}
func (m *MsgCancelOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelOrder.Merge(m, src)
}
func (m *MsgCancelOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelOrder proto.InternalMessageInfo

type isMsgCancelOrder_GoodTilOneof interface {
	isMsgCancelOrder_GoodTilOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgCancelOrder_GoodTilBlock struct {
	GoodTilBlock uint32 `protobuf:"varint,2,opt,name=good_til_block,json=goodTilBlock,proto3,oneof" json:"good_til_block,omitempty"`
}
type MsgCancelOrder_GoodTilBlockTime struct {
	GoodTilBlockTime uint32 `protobuf:"fixed32,3,opt,name=good_til_block_time,json=goodTilBlockTime,proto3,oneof" json:"good_til_block_time,omitempty"`
}

func (*MsgCancelOrder_GoodTilBlock) isMsgCancelOrder_GoodTilOneof()     {}
func (*MsgCancelOrder_GoodTilBlockTime) isMsgCancelOrder_GoodTilOneof() {}

func (m *MsgCancelOrder) GetGoodTilOneof() isMsgCancelOrder_GoodTilOneof {
	if m != nil {
		return m.GoodTilOneof
	}
	return nil
}

func (m *MsgCancelOrder) GetOrderId() OrderId {
	if m != nil {
		return m.OrderId
	}
	return OrderId{}
}

func (m *MsgCancelOrder) GetGoodTilBlock() uint32 {
	if x, ok := m.GetGoodTilOneof().(*MsgCancelOrder_GoodTilBlock); ok {
		return x.GoodTilBlock
	}
	return 0
}

func (m *MsgCancelOrder) GetGoodTilBlockTime() uint32 {
	if x, ok := m.GetGoodTilOneof().(*MsgCancelOrder_GoodTilBlockTime); ok {
		return x.GoodTilBlockTime
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgCancelOrder) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgCancelOrder_GoodTilBlock)(nil),
		(*MsgCancelOrder_GoodTilBlockTime)(nil),
	}
}

// MsgCancelOrderResponse is a response type used for canceling orders.
type MsgCancelOrderResponse struct {
}

func (m *MsgCancelOrderResponse) Reset()         { *m = MsgCancelOrderResponse{} }
func (m *MsgCancelOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelOrderResponse) ProtoMessage()    {}
func (*MsgCancelOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{7}
}
func (m *MsgCancelOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelOrderResponse.Merge(m, src)
}
func (m *MsgCancelOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelOrderResponse proto.InternalMessageInfo

// OperationRaw represents an operation in the proposed operations.
// Note that the `order_placement` operation is a signed message.
type OperationRaw struct {
	// operationRaw represents an operation that occurred, which can be a match,
	// a signed order placement, or an order removal.
	//
	// Types that are valid to be assigned to Operation:
	//	*OperationRaw_Match
	//	*OperationRaw_ShortTermOrderPlacement
	//	*OperationRaw_OrderRemoval
	Operation isOperationRaw_Operation `protobuf_oneof:"operation"`
}

func (m *OperationRaw) Reset()         { *m = OperationRaw{} }
func (m *OperationRaw) String() string { return proto.CompactTextString(m) }
func (*OperationRaw) ProtoMessage()    {}
func (*OperationRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{8}
}
func (m *OperationRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperationRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperationRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperationRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationRaw.Merge(m, src)
}
func (m *OperationRaw) XXX_Size() int {
	return m.Size()
}
func (m *OperationRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationRaw.DiscardUnknown(m)
}

var xxx_messageInfo_OperationRaw proto.InternalMessageInfo

type isOperationRaw_Operation interface {
	isOperationRaw_Operation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OperationRaw_Match struct {
	Match *ClobMatch `protobuf:"bytes,1,opt,name=match,proto3,oneof" json:"match,omitempty"`
}
type OperationRaw_ShortTermOrderPlacement struct {
	ShortTermOrderPlacement []byte `protobuf:"bytes,2,opt,name=short_term_order_placement,json=shortTermOrderPlacement,proto3,oneof" json:"short_term_order_placement,omitempty"`
}
type OperationRaw_OrderRemoval struct {
	OrderRemoval *OrderRemoval `protobuf:"bytes,3,opt,name=order_removal,json=orderRemoval,proto3,oneof" json:"order_removal,omitempty"`
}

func (*OperationRaw_Match) isOperationRaw_Operation()                   {}
func (*OperationRaw_ShortTermOrderPlacement) isOperationRaw_Operation() {}
func (*OperationRaw_OrderRemoval) isOperationRaw_Operation()            {}

func (m *OperationRaw) GetOperation() isOperationRaw_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *OperationRaw) GetMatch() *ClobMatch {
	if x, ok := m.GetOperation().(*OperationRaw_Match); ok {
		return x.Match
	}
	return nil
}

func (m *OperationRaw) GetShortTermOrderPlacement() []byte {
	if x, ok := m.GetOperation().(*OperationRaw_ShortTermOrderPlacement); ok {
		return x.ShortTermOrderPlacement
	}
	return nil
}

func (m *OperationRaw) GetOrderRemoval() *OrderRemoval {
	if x, ok := m.GetOperation().(*OperationRaw_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OperationRaw) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OperationRaw_Match)(nil),
		(*OperationRaw_ShortTermOrderPlacement)(nil),
		(*OperationRaw_OrderRemoval)(nil),
	}
}

func init() {
	proto.RegisterType((*MsgCreateClobPair)(nil), "dydxprotocol.clob.MsgCreateClobPair")
	proto.RegisterType((*MsgCreateClobPairResponse)(nil), "dydxprotocol.clob.MsgCreateClobPairResponse")
	proto.RegisterType((*MsgProposedOperations)(nil), "dydxprotocol.clob.MsgProposedOperations")
	proto.RegisterType((*MsgProposedOperationsResponse)(nil), "dydxprotocol.clob.MsgProposedOperationsResponse")
	proto.RegisterType((*MsgPlaceOrder)(nil), "dydxprotocol.clob.MsgPlaceOrder")
	proto.RegisterType((*MsgPlaceOrderResponse)(nil), "dydxprotocol.clob.MsgPlaceOrderResponse")
	proto.RegisterType((*MsgCancelOrder)(nil), "dydxprotocol.clob.MsgCancelOrder")
	proto.RegisterType((*MsgCancelOrderResponse)(nil), "dydxprotocol.clob.MsgCancelOrderResponse")
	proto.RegisterType((*OperationRaw)(nil), "dydxprotocol.clob.OperationRaw")
}

func init() { proto.RegisterFile("dydxprotocol/clob/tx.proto", fileDescriptor_19b9e2c0de4ab64a) }

var fileDescriptor_19b9e2c0de4ab64a = []byte{
	// 693 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x95, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0xed, 0x2f, 0xdf, 0xf7, 0xb5, 0xd9, 0xb4, 0xa1, 0x35, 0x85, 0xba, 0x2e, 0x4d, 0xd2,
	0x08, 0x55, 0x01, 0xd1, 0x18, 0x42, 0x55, 0x21, 0x10, 0x07, 0x52, 0x81, 0xc2, 0x21, 0x6a, 0x30,
	0x3d, 0x20, 0x38, 0x58, 0x8e, 0xbd, 0x38, 0x2b, 0x6c, 0x8f, 0xd9, 0xdd, 0x94, 0xf6, 0xca, 0x13,
	0x70, 0x80, 0xf7, 0xe0, 0xc0, 0x81, 0x47, 0xe8, 0xb1, 0xe2, 0xd4, 0x13, 0x42, 0xed, 0x81, 0xd7,
	0x40, 0x6b, 0x3b, 0xae, 0x43, 0x1c, 0xb5, 0x97, 0xc4, 0x3b, 0xf3, 0x9b, 0xf9, 0xcf, 0xcc, 0x4e,
	0x1c, 0xa4, 0x39, 0x87, 0xce, 0x41, 0x48, 0x81, 0x83, 0x0d, 0x9e, 0x6e, 0x7b, 0xd0, 0xd7, 0xf9,
	0x41, 0x33, 0x32, 0x28, 0x8b, 0x59, 0x5f, 0x53, 0xf8, 0xb4, 0x15, 0x1b, 0x98, 0x0f, 0xcc, 0x8c,
	0xac, 0x7a, 0x7c, 0x88, 0x69, 0x6d, 0x39, 0x3e, 0xe9, 0x3e, 0x73, 0xf5, 0xfd, 0x7b, 0xe2, 0x2b,
	0x71, 0x2c, 0xb9, 0xe0, 0x42, 0x1c, 0x20, 0x9e, 0x12, 0xeb, 0xda, 0xa4, 0x30, 0x50, 0x07, 0xd3,
	0xc4, 0xbd, 0x31, 0xc5, 0x6d, 0x52, 0xec, 0xc3, 0xbe, 0xe5, 0x8d, 0x54, 0xab, 0x93, 0x9c, 0x6f,
	0x71, 0x7b, 0x80, 0x47, 0xc0, 0xfa, 0x24, 0x20, 0x3e, 0xcc, 0xd0, 0x22, 0x89, 0x56, 0xfd, 0x8b,
	0x8c, 0x16, 0xbb, 0xcc, 0xdd, 0xa1, 0xd8, 0xe2, 0x78, 0xc7, 0x83, 0x7e, 0xcf, 0x22, 0x54, 0xd9,
	0x46, 0x45, 0x6b, 0xc8, 0x07, 0x40, 0x09, 0x3f, 0x54, 0xe5, 0x9a, 0xdc, 0x28, 0xb6, 0xd5, 0x1f,
	0xdf, 0x36, 0x97, 0x92, 0xa6, 0x9f, 0x38, 0x0e, 0xc5, 0x8c, 0xbd, 0xe4, 0x94, 0x04, 0xae, 0x71,
	0x8e, 0x2a, 0x0f, 0x50, 0x31, 0x15, 0x50, 0xff, 0xa9, 0xc9, 0x8d, 0x52, 0x6b, 0xb5, 0x39, 0x31,
	0xc9, 0xe6, 0x48, 0xc7, 0x98, 0xb5, 0x93, 0xa7, 0x87, 0xe5, 0x8f, 0xbf, 0xbf, 0xde, 0x3e, 0xcf,
	0x54, 0x5f, 0x45, 0x2b, 0x13, 0x65, 0x19, 0x98, 0x85, 0x10, 0x30, 0x5c, 0x27, 0xe8, 0x5a, 0x97,
	0xb9, 0x3d, 0x0a, 0x21, 0x30, 0xec, 0xec, 0x86, 0x98, 0x5a, 0x9c, 0x40, 0xc0, 0x94, 0x1e, 0x5a,
	0x80, 0xf4, 0x64, 0xbe, 0x1f, 0xe2, 0x21, 0x56, 0xe5, 0x5a, 0xa1, 0x51, 0x6a, 0x55, 0x73, 0xca,
	0x48, 0x03, 0x0d, 0xeb, 0x43, 0xfb, 0xdf, 0xa3, 0x9f, 0x55, 0xc9, 0xb8, 0x72, 0x1e, 0xfe, 0x42,
	0x44, 0xd7, 0xab, 0x68, 0x2d, 0x57, 0x2a, 0xad, 0xe5, 0x29, 0x9a, 0x17, 0x80, 0x67, 0xd9, 0x78,
	0x57, 0x5c, 0x92, 0xb2, 0x85, 0xfe, 0x8b, 0x6e, 0x2b, 0x9a, 0x5b, 0xa9, 0xa5, 0xe6, 0x09, 0x0b,
	0x7f, 0xa2, 0x18, 0xc3, 0xf5, 0xe5, 0xb8, 0xa5, 0x34, 0x4d, 0x9a, 0xff, 0xbb, 0x8c, 0xca, 0x62,
	0x12, 0x56, 0x60, 0x63, 0x2f, 0x56, 0x78, 0x84, 0x66, 0xe3, 0x7d, 0x20, 0x4e, 0x22, 0xa2, 0x4d,
	0x13, 0x79, 0xee, 0x24, 0x32, 0x33, 0x10, 0x1f, 0x95, 0x0d, 0x54, 0x76, 0x01, 0x1c, 0x93, 0x13,
	0xcf, 0xec, 0x7b, 0x60, 0xbf, 0x8b, 0xee, 0x69, 0xbe, 0x23, 0x19, 0x73, 0xc2, 0xbe, 0x47, 0xbc,
	0xb6, 0xb0, 0x2a, 0x3a, 0xba, 0x3a, 0xce, 0x99, 0x9c, 0xf8, 0x58, 0x2d, 0xd4, 0xe4, 0xc6, 0x4c,
	0x47, 0x32, 0x16, 0xb2, 0xf0, 0x1e, 0xf1, 0x71, 0x7b, 0x21, 0x93, 0x18, 0x02, 0x0c, 0x6f, 0xeb,
	0x2a, 0xba, 0x3e, 0x5e, 0x79, 0xda, 0xd4, 0x89, 0x8c, 0xe6, 0xb2, 0xd3, 0x17, 0x43, 0x8b, 0x56,
	0x37, 0xe9, 0xe7, 0xc6, 0x94, 0xa5, 0xe9, 0x0a, 0xa6, 0x23, 0x19, 0x31, 0xac, 0x3c, 0x46, 0x1a,
	0x1b, 0x00, 0xe5, 0x26, 0xc7, 0xd4, 0x37, 0xe3, 0x99, 0x84, 0x62, 0x84, 0x3e, 0x0e, 0x78, 0xd4,
	0xd7, 0x5c, 0x47, 0x32, 0x96, 0x23, 0x66, 0x0f, 0x53, 0x3f, 0x2a, 0xa2, 0x37, 0x02, 0x94, 0x67,
	0x68, 0x7e, 0xec, 0x77, 0x15, 0x35, 0x37, 0x65, 0x55, 0xe2, 0xf2, 0x23, 0x4c, 0x8c, 0x0a, 0x32,
	0xe7, 0x76, 0x09, 0x15, 0xd3, 0xb5, 0x69, 0x7d, 0x2e, 0xa0, 0x42, 0x97, 0xb9, 0x4a, 0x88, 0x94,
	0x9c, 0x05, 0x6d, 0xe4, 0xe4, 0xce, 0xdd, 0x2f, 0xed, 0xee, 0x65, 0xc9, 0xd1, 0x50, 0x95, 0x57,
	0x08, 0x65, 0xd6, 0xb0, 0x36, 0x25, 0x3e, 0x25, 0xb4, 0xc6, 0x45, 0x44, 0x9a, 0xf9, 0x0d, 0x2a,
	0x65, 0xf7, 0x6f, 0x3d, 0x3f, 0x30, 0x83, 0x68, 0xb7, 0x2e, 0x44, 0xd2, 0xe4, 0x0e, 0x2a, 0xff,
	0xf5, 0xf6, 0xb9, 0x39, 0x25, 0x78, 0x8c, 0xd2, 0xee, 0x5c, 0x86, 0x1a, 0xa9, 0xb4, 0x7b, 0x47,
	0xa7, 0x15, 0xf9, 0xf8, 0xb4, 0x22, 0xff, 0x3a, 0xad, 0xc8, 0x9f, 0xce, 0x2a, 0xd2, 0xf1, 0x59,
	0x45, 0x3a, 0x39, 0xab, 0x48, 0xaf, 0xb7, 0x5d, 0xc2, 0x07, 0xc3, 0x7e, 0xd3, 0x06, 0x5f, 0x1f,
	0x7b, 0x5f, 0xee, 0x6f, 0x6d, 0xda, 0x03, 0x8b, 0x04, 0x7a, 0x6a, 0x39, 0x48, 0xfe, 0x24, 0x0e,
	0x43, 0xcc, 0xfa, 0xff, 0x47, 0xe6, 0xfb, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x4d, 0xa2, 0x16,
	0x82, 0x46, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// ProposedOperations is a temporary message used by block proposers
	// for matching orders as part of the ABCI++ workaround.
	ProposedOperations(ctx context.Context, in *MsgProposedOperations, opts ...grpc.CallOption) (*MsgProposedOperationsResponse, error)
	// PlaceOrder allows accounts to place orders on the orderbook.
	PlaceOrder(ctx context.Context, in *MsgPlaceOrder, opts ...grpc.CallOption) (*MsgPlaceOrderResponse, error)
	// CancelOrder allows accounts to cancel existing orders on the orderbook.
	CancelOrder(ctx context.Context, in *MsgCancelOrder, opts ...grpc.CallOption) (*MsgCancelOrderResponse, error)
	// CreateClobPair creates a new clob pair.
	CreateClobPair(ctx context.Context, in *MsgCreateClobPair, opts ...grpc.CallOption) (*MsgCreateClobPairResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) ProposedOperations(ctx context.Context, in *MsgProposedOperations, opts ...grpc.CallOption) (*MsgProposedOperationsResponse, error) {
	out := new(MsgProposedOperationsResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/ProposedOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PlaceOrder(ctx context.Context, in *MsgPlaceOrder, opts ...grpc.CallOption) (*MsgPlaceOrderResponse, error) {
	out := new(MsgPlaceOrderResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/PlaceOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelOrder(ctx context.Context, in *MsgCancelOrder, opts ...grpc.CallOption) (*MsgCancelOrderResponse, error) {
	out := new(MsgCancelOrderResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateClobPair(ctx context.Context, in *MsgCreateClobPair, opts ...grpc.CallOption) (*MsgCreateClobPairResponse, error) {
	out := new(MsgCreateClobPairResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/CreateClobPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// ProposedOperations is a temporary message used by block proposers
	// for matching orders as part of the ABCI++ workaround.
	ProposedOperations(context.Context, *MsgProposedOperations) (*MsgProposedOperationsResponse, error)
	// PlaceOrder allows accounts to place orders on the orderbook.
	PlaceOrder(context.Context, *MsgPlaceOrder) (*MsgPlaceOrderResponse, error)
	// CancelOrder allows accounts to cancel existing orders on the orderbook.
	CancelOrder(context.Context, *MsgCancelOrder) (*MsgCancelOrderResponse, error)
	// CreateClobPair creates a new clob pair.
	CreateClobPair(context.Context, *MsgCreateClobPair) (*MsgCreateClobPairResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) ProposedOperations(ctx context.Context, req *MsgProposedOperations) (*MsgProposedOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposedOperations not implemented")
}
func (*UnimplementedMsgServer) PlaceOrder(ctx context.Context, req *MsgPlaceOrder) (*MsgPlaceOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceOrder not implemented")
}
func (*UnimplementedMsgServer) CancelOrder(ctx context.Context, req *MsgCancelOrder) (*MsgCancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (*UnimplementedMsgServer) CreateClobPair(ctx context.Context, req *MsgCreateClobPair) (*MsgCreateClobPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClobPair not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_ProposedOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProposedOperations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProposedOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/ProposedOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProposedOperations(ctx, req.(*MsgProposedOperations))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PlaceOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPlaceOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PlaceOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/PlaceOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PlaceOrder(ctx, req.(*MsgPlaceOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelOrder(ctx, req.(*MsgCancelOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateClobPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateClobPair)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateClobPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/CreateClobPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateClobPair(ctx, req.(*MsgCreateClobPair))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dydxprotocol.clob.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProposedOperations",
			Handler:    _Msg_ProposedOperations_Handler,
		},
		{
			MethodName: "PlaceOrder",
			Handler:    _Msg_PlaceOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Msg_CancelOrder_Handler,
		},
		{
			MethodName: "CreateClobPair",
			Handler:    _Msg_CreateClobPair_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dydxprotocol/clob/tx.proto",
}

func (m *MsgCreateClobPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateClobPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateClobPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClobPair != nil {
		{
			size, err := m.ClobPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateClobPairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateClobPairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateClobPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgProposedOperations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposedOperations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposedOperations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperationsQueue) > 0 {
		for iNdEx := len(m.OperationsQueue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperationsQueue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposedOperationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposedOperationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposedOperationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPlaceOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlaceOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlaceOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPlaceOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlaceOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlaceOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCancelOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GoodTilOneof != nil {
		{
			size := m.GoodTilOneof.Size()
			i -= size
			if _, err := m.GoodTilOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	{
		size, err := m.OrderId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCancelOrder_GoodTilBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder_GoodTilBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTx(dAtA, i, uint64(m.GoodTilBlock))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *MsgCancelOrder_GoodTilBlockTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder_GoodTilBlockTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.GoodTilBlockTime))
	i--
	dAtA[i] = 0x1d
	return len(dAtA) - i, nil
}
func (m *MsgCancelOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OperationRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationRaw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		{
			size := m.Operation.Size()
			i -= size
			if _, err := m.Operation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OperationRaw_Match) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OperationRaw_ShortTermOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_ShortTermOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShortTermOrderPlacement != nil {
		i -= len(m.ShortTermOrderPlacement)
		copy(dAtA[i:], m.ShortTermOrderPlacement)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShortTermOrderPlacement)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OperationRaw_OrderRemoval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_OrderRemoval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderRemoval != nil {
		{
			size, err := m.OrderRemoval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateClobPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ClobPair != nil {
		l = m.ClobPair.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateClobPairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgProposedOperations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OperationsQueue) > 0 {
		for _, e := range m.OperationsQueue {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgProposedOperationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPlaceOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPlaceOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCancelOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OrderId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.GoodTilOneof != nil {
		n += m.GoodTilOneof.Size()
	}
	return n
}

func (m *MsgCancelOrder_GoodTilBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTx(uint64(m.GoodTilBlock))
	return n
}
func (m *MsgCancelOrder_GoodTilBlockTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *MsgCancelOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OperationRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		n += m.Operation.Size()
	}
	return n
}

func (m *OperationRaw_Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *OperationRaw_ShortTermOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShortTermOrderPlacement != nil {
		l = len(m.ShortTermOrderPlacement)
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *OperationRaw_OrderRemoval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderRemoval != nil {
		l = m.OrderRemoval.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateClobPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateClobPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateClobPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClobPair == nil {
				m.ClobPair = &ClobPair{}
			}
			if err := m.ClobPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateClobPairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateClobPairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateClobPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposedOperations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposedOperations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposedOperations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationsQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationsQueue = append(m.OperationsQueue, OperationRaw{})
			if err := m.OperationsQueue[len(m.OperationsQueue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposedOperationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposedOperationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposedOperationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlaceOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlaceOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlaceOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlaceOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlaceOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlaceOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlock", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GoodTilOneof = &MsgCancelOrder_GoodTilBlock{v}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlockTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GoodTilOneof = &MsgCancelOrder_GoodTilBlockTime{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClobMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &OperationRaw_Match{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortTermOrderPlacement", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Operation = &OperationRaw_ShortTermOrderPlacement{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRemoval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderRemoval{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &OperationRaw_OrderRemoval{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
