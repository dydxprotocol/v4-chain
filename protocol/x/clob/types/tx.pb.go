// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/clob/tx.proto

package types

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgProposedOperations is a message injected by block proposers to
// specify the operations that occurred in a block.
type MsgProposedOperations struct {
	// The list of operations proposed by the block proposer.
	OperationsQueue []OperationRaw `protobuf:"bytes,1,rep,name=operations_queue,json=operationsQueue,proto3" json:"operations_queue"`
}

func (m *MsgProposedOperations) Reset()         { *m = MsgProposedOperations{} }
func (m *MsgProposedOperations) String() string { return proto.CompactTextString(m) }
func (*MsgProposedOperations) ProtoMessage()    {}
func (*MsgProposedOperations) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{0}
}
func (m *MsgProposedOperations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposedOperations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposedOperations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposedOperations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposedOperations.Merge(m, src)
}
func (m *MsgProposedOperations) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposedOperations) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposedOperations.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposedOperations proto.InternalMessageInfo

func (m *MsgProposedOperations) GetOperationsQueue() []OperationRaw {
	if m != nil {
		return m.OperationsQueue
	}
	return nil
}

// MsgProposedOperationsResponse is the response type of the message injected
// by block proposers to specify the operations that occurred in a block.
type MsgProposedOperationsResponse struct {
}

func (m *MsgProposedOperationsResponse) Reset()         { *m = MsgProposedOperationsResponse{} }
func (m *MsgProposedOperationsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposedOperationsResponse) ProtoMessage()    {}
func (*MsgProposedOperationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{1}
}
func (m *MsgProposedOperationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposedOperationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposedOperationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposedOperationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposedOperationsResponse.Merge(m, src)
}
func (m *MsgProposedOperationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposedOperationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposedOperationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposedOperationsResponse proto.InternalMessageInfo

// MsgPlaceOrder is a request type used for placing orders.
type MsgPlaceOrder struct {
	Order Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order"`
}

func (m *MsgPlaceOrder) Reset()         { *m = MsgPlaceOrder{} }
func (m *MsgPlaceOrder) String() string { return proto.CompactTextString(m) }
func (*MsgPlaceOrder) ProtoMessage()    {}
func (*MsgPlaceOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{2}
}
func (m *MsgPlaceOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlaceOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlaceOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlaceOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlaceOrder.Merge(m, src)
}
func (m *MsgPlaceOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlaceOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlaceOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlaceOrder proto.InternalMessageInfo

func (m *MsgPlaceOrder) GetOrder() Order {
	if m != nil {
		return m.Order
	}
	return Order{}
}

// MsgPlaceOrderResponse is a response type used for placing orders.
type MsgPlaceOrderResponse struct {
}

func (m *MsgPlaceOrderResponse) Reset()         { *m = MsgPlaceOrderResponse{} }
func (m *MsgPlaceOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPlaceOrderResponse) ProtoMessage()    {}
func (*MsgPlaceOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{3}
}
func (m *MsgPlaceOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlaceOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlaceOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlaceOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlaceOrderResponse.Merge(m, src)
}
func (m *MsgPlaceOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlaceOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlaceOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlaceOrderResponse proto.InternalMessageInfo

// MsgCancelOrder is a request type used for canceling orders.
type MsgCancelOrder struct {
	OrderId OrderId `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	// Information about when the order cancellation expires.
	//
	// Types that are valid to be assigned to GoodTilOneof:
	//	*MsgCancelOrder_GoodTilBlock
	//	*MsgCancelOrder_GoodTilBlockTime
	GoodTilOneof isMsgCancelOrder_GoodTilOneof `protobuf_oneof:"good_til_oneof"`
}

func (m *MsgCancelOrder) Reset()         { *m = MsgCancelOrder{} }
func (m *MsgCancelOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelOrder) ProtoMessage()    {}
func (*MsgCancelOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{4}
}
func (m *MsgCancelOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelOrder.Merge(m, src)
}
func (m *MsgCancelOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelOrder proto.InternalMessageInfo

type isMsgCancelOrder_GoodTilOneof interface {
	isMsgCancelOrder_GoodTilOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgCancelOrder_GoodTilBlock struct {
	GoodTilBlock uint32 `protobuf:"varint,2,opt,name=good_til_block,json=goodTilBlock,proto3,oneof" json:"good_til_block,omitempty"`
}
type MsgCancelOrder_GoodTilBlockTime struct {
	GoodTilBlockTime uint32 `protobuf:"fixed32,3,opt,name=good_til_block_time,json=goodTilBlockTime,proto3,oneof" json:"good_til_block_time,omitempty"`
}

func (*MsgCancelOrder_GoodTilBlock) isMsgCancelOrder_GoodTilOneof()     {}
func (*MsgCancelOrder_GoodTilBlockTime) isMsgCancelOrder_GoodTilOneof() {}

func (m *MsgCancelOrder) GetGoodTilOneof() isMsgCancelOrder_GoodTilOneof {
	if m != nil {
		return m.GoodTilOneof
	}
	return nil
}

func (m *MsgCancelOrder) GetOrderId() OrderId {
	if m != nil {
		return m.OrderId
	}
	return OrderId{}
}

func (m *MsgCancelOrder) GetGoodTilBlock() uint32 {
	if x, ok := m.GetGoodTilOneof().(*MsgCancelOrder_GoodTilBlock); ok {
		return x.GoodTilBlock
	}
	return 0
}

func (m *MsgCancelOrder) GetGoodTilBlockTime() uint32 {
	if x, ok := m.GetGoodTilOneof().(*MsgCancelOrder_GoodTilBlockTime); ok {
		return x.GoodTilBlockTime
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgCancelOrder) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgCancelOrder_GoodTilBlock)(nil),
		(*MsgCancelOrder_GoodTilBlockTime)(nil),
	}
}

// MsgCancelOrderResponse is a response type used for canceling orders.
type MsgCancelOrderResponse struct {
}

func (m *MsgCancelOrderResponse) Reset()         { *m = MsgCancelOrderResponse{} }
func (m *MsgCancelOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelOrderResponse) ProtoMessage()    {}
func (*MsgCancelOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{5}
}
func (m *MsgCancelOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelOrderResponse.Merge(m, src)
}
func (m *MsgCancelOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelOrderResponse proto.InternalMessageInfo

// MsgSetClobPairStatus is a request type used for setting a ClobPair's status.
type MsgSetClobPairStatus struct {
	ClobPairId uint32          `protobuf:"varint,1,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	Status     ClobPair_Status `protobuf:"varint,2,opt,name=status,proto3,enum=dydxprotocol.clob.ClobPair_Status" json:"status,omitempty"`
}

func (m *MsgSetClobPairStatus) Reset()         { *m = MsgSetClobPairStatus{} }
func (m *MsgSetClobPairStatus) String() string { return proto.CompactTextString(m) }
func (*MsgSetClobPairStatus) ProtoMessage()    {}
func (*MsgSetClobPairStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{6}
}
func (m *MsgSetClobPairStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetClobPairStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetClobPairStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetClobPairStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetClobPairStatus.Merge(m, src)
}
func (m *MsgSetClobPairStatus) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetClobPairStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetClobPairStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetClobPairStatus proto.InternalMessageInfo

func (m *MsgSetClobPairStatus) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *MsgSetClobPairStatus) GetStatus() ClobPair_Status {
	if m != nil {
		return m.Status
	}
	return ClobPair_STATUS_UNSPECIFIED
}

// MsgSetClobPairStatusResponse is a response type used for setting ClobPair's status.
type MsgSetClobPairStatusResponse struct {
}

func (m *MsgSetClobPairStatusResponse) Reset()         { *m = MsgSetClobPairStatusResponse{} }
func (m *MsgSetClobPairStatusResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetClobPairStatusResponse) ProtoMessage()    {}
func (*MsgSetClobPairStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{7}
}
func (m *MsgSetClobPairStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetClobPairStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetClobPairStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetClobPairStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetClobPairStatusResponse.Merge(m, src)
}
func (m *MsgSetClobPairStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetClobPairStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetClobPairStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetClobPairStatusResponse proto.InternalMessageInfo

// OperationRaw represents an operation in the proposed operations.
// Note that the `order_placement` operation is a signed message.
type OperationRaw struct {
	// operationRaw represents an operation that occurred, which can be a match,
	// a signed order placement, or an order removal.
	//
	// Types that are valid to be assigned to Operation:
	//	*OperationRaw_Match
	//	*OperationRaw_ShortTermOrderPlacement
	//	*OperationRaw_OrderRemoval
	Operation isOperationRaw_Operation `protobuf_oneof:"operation"`
}

func (m *OperationRaw) Reset()         { *m = OperationRaw{} }
func (m *OperationRaw) String() string { return proto.CompactTextString(m) }
func (*OperationRaw) ProtoMessage()    {}
func (*OperationRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_19b9e2c0de4ab64a, []int{8}
}
func (m *OperationRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperationRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperationRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperationRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationRaw.Merge(m, src)
}
func (m *OperationRaw) XXX_Size() int {
	return m.Size()
}
func (m *OperationRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationRaw.DiscardUnknown(m)
}

var xxx_messageInfo_OperationRaw proto.InternalMessageInfo

type isOperationRaw_Operation interface {
	isOperationRaw_Operation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OperationRaw_Match struct {
	Match *ClobMatch `protobuf:"bytes,1,opt,name=match,proto3,oneof" json:"match,omitempty"`
}
type OperationRaw_ShortTermOrderPlacement struct {
	ShortTermOrderPlacement []byte `protobuf:"bytes,2,opt,name=short_term_order_placement,json=shortTermOrderPlacement,proto3,oneof" json:"short_term_order_placement,omitempty"`
}
type OperationRaw_OrderRemoval struct {
	OrderRemoval *OrderRemoval `protobuf:"bytes,3,opt,name=order_removal,json=orderRemoval,proto3,oneof" json:"order_removal,omitempty"`
}

func (*OperationRaw_Match) isOperationRaw_Operation()                   {}
func (*OperationRaw_ShortTermOrderPlacement) isOperationRaw_Operation() {}
func (*OperationRaw_OrderRemoval) isOperationRaw_Operation()            {}

func (m *OperationRaw) GetOperation() isOperationRaw_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *OperationRaw) GetMatch() *ClobMatch {
	if x, ok := m.GetOperation().(*OperationRaw_Match); ok {
		return x.Match
	}
	return nil
}

func (m *OperationRaw) GetShortTermOrderPlacement() []byte {
	if x, ok := m.GetOperation().(*OperationRaw_ShortTermOrderPlacement); ok {
		return x.ShortTermOrderPlacement
	}
	return nil
}

func (m *OperationRaw) GetOrderRemoval() *OrderRemoval {
	if x, ok := m.GetOperation().(*OperationRaw_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OperationRaw) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OperationRaw_Match)(nil),
		(*OperationRaw_ShortTermOrderPlacement)(nil),
		(*OperationRaw_OrderRemoval)(nil),
	}
}

func init() {
	proto.RegisterType((*MsgProposedOperations)(nil), "dydxprotocol.clob.MsgProposedOperations")
	proto.RegisterType((*MsgProposedOperationsResponse)(nil), "dydxprotocol.clob.MsgProposedOperationsResponse")
	proto.RegisterType((*MsgPlaceOrder)(nil), "dydxprotocol.clob.MsgPlaceOrder")
	proto.RegisterType((*MsgPlaceOrderResponse)(nil), "dydxprotocol.clob.MsgPlaceOrderResponse")
	proto.RegisterType((*MsgCancelOrder)(nil), "dydxprotocol.clob.MsgCancelOrder")
	proto.RegisterType((*MsgCancelOrderResponse)(nil), "dydxprotocol.clob.MsgCancelOrderResponse")
	proto.RegisterType((*MsgSetClobPairStatus)(nil), "dydxprotocol.clob.MsgSetClobPairStatus")
	proto.RegisterType((*MsgSetClobPairStatusResponse)(nil), "dydxprotocol.clob.MsgSetClobPairStatusResponse")
	proto.RegisterType((*OperationRaw)(nil), "dydxprotocol.clob.OperationRaw")
}

func init() { proto.RegisterFile("dydxprotocol/clob/tx.proto", fileDescriptor_19b9e2c0de4ab64a) }

var fileDescriptor_19b9e2c0de4ab64a = []byte{
	// 635 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0xed, 0x2f, 0x1f, 0x2d, 0x4c, 0x92, 0xd2, 0x2e, 0x85, 0x46, 0x56, 0xeb, 0xa4, 0x3e,
	0x94, 0x70, 0x20, 0x46, 0xa1, 0xe2, 0x00, 0xe2, 0x92, 0x0a, 0x94, 0x1e, 0xa2, 0x06, 0xb7, 0x07,
	0x04, 0x07, 0xcb, 0xb1, 0x17, 0xc7, 0xc2, 0xce, 0x1a, 0xef, 0xa6, 0xb4, 0x6f, 0xc1, 0x0b, 0xf0,
	0x1e, 0x3c, 0x42, 0x8f, 0x3d, 0xf6, 0x84, 0x50, 0xfb, 0x22, 0x68, 0xd7, 0xf6, 0xe2, 0xc8, 0x8e,
	0xda, 0x4b, 0x94, 0x9d, 0xfd, 0xcd, 0xff, 0xbf, 0x33, 0x3b, 0x6b, 0xd0, 0xbc, 0x73, 0xef, 0x2c,
	0x4e, 0x08, 0x23, 0x2e, 0x09, 0x4d, 0x37, 0x24, 0x13, 0x93, 0x9d, 0xf5, 0x44, 0x00, 0x6d, 0x14,
	0xf7, 0x7a, 0x7c, 0x4f, 0xdb, 0xf4, 0x89, 0x4f, 0x44, 0xc8, 0xe4, 0xff, 0x52, 0x50, 0xdb, 0x2d,
	0x8b, 0xf0, 0x1f, 0x3b, 0x76, 0x82, 0x24, 0x43, 0x76, 0xca, 0x08, 0x49, 0x3c, 0x9c, 0x6f, 0xef,
	0x2d, 0xd9, 0xb6, 0x13, 0x1c, 0x91, 0x53, 0x27, 0xa4, 0x19, 0xd7, 0x2e, 0x73, 0x91, 0xc3, 0xdc,
	0x29, 0xce, 0x00, 0x23, 0x80, 0xc7, 0x23, 0xea, 0x8f, 0x13, 0x12, 0x13, 0x8a, 0xbd, 0xa3, 0x18,
	0x27, 0x0e, 0x0b, 0xc8, 0x8c, 0xa2, 0x31, 0xac, 0x13, 0xb9, 0xb2, 0xbf, 0xcd, 0xf1, 0x1c, 0xb7,
	0xd4, 0x4e, 0xad, 0x5b, 0xef, 0xb7, 0x7b, 0xa5, 0x3a, 0x7b, 0x32, 0xd1, 0x72, 0xbe, 0x0f, 0xfe,
	0xbf, 0xf8, 0xdd, 0x56, 0xac, 0x87, 0xff, 0xd2, 0x3f, 0xf0, 0x6c, 0xa3, 0x0d, 0x3b, 0x95, 0x56,
	0x16, 0xa6, 0x31, 0x99, 0x51, 0x6c, 0xbc, 0x83, 0x26, 0x07, 0x42, 0xc7, 0xc5, 0x47, 0xbc, 0x18,
	0xb4, 0x0f, 0xf7, 0x44, 0x55, 0x2d, 0xb5, 0xa3, 0x76, 0xeb, 0xfd, 0x56, 0x95, 0x31, 0xdf, 0xcf,
	0x1c, 0x53, 0xd8, 0xd8, 0x4a, 0x4b, 0x92, 0x32, 0x52, 0xff, 0x97, 0x0a, 0x6b, 0x23, 0xea, 0x1f,
	0x38, 0x33, 0x17, 0x87, 0xa9, 0xc3, 0x1b, 0xb8, 0x9f, 0xf6, 0x2d, 0xf0, 0x32, 0x13, 0x6d, 0x99,
	0xc9, 0xa1, 0x97, 0xd9, 0xac, 0x92, 0x74, 0x89, 0xf6, 0x60, 0xcd, 0x27, 0xc4, 0xb3, 0x59, 0x10,
	0xda, 0x93, 0x90, 0xb8, 0x5f, 0x5b, 0xff, 0x75, 0xd4, 0x6e, 0x73, 0xa8, 0x58, 0x0d, 0x1e, 0x3f,
	0x09, 0xc2, 0x01, 0x8f, 0x22, 0x13, 0x1e, 0x2d, 0x72, 0x36, 0x0b, 0x22, 0xdc, 0xaa, 0x75, 0xd4,
	0xee, 0xea, 0x50, 0xb1, 0xd6, 0x8b, 0xf0, 0x49, 0x10, 0xe1, 0xc1, 0x7a, 0x41, 0x98, 0xcc, 0x30,
	0xf9, 0x62, 0xb4, 0xe0, 0xc9, 0xe2, 0xc9, 0x65, 0x51, 0x0c, 0x36, 0x47, 0xd4, 0x3f, 0xc6, 0xec,
	0x20, 0x24, 0x93, 0xb1, 0x13, 0x24, 0xc7, 0xcc, 0x61, 0x73, 0x8a, 0x3a, 0xd0, 0x90, 0x33, 0x95,
	0x57, 0xd7, 0xb4, 0xc0, 0xcd, 0xa8, 0x43, 0x0f, 0xbd, 0x86, 0x15, 0x2a, 0x58, 0x71, 0xec, 0xb5,
	0xbe, 0x51, 0x51, 0x79, 0x2e, 0xda, 0x4b, 0x55, 0xad, 0x2c, 0xc3, 0xd0, 0x61, 0xbb, 0xca, 0x55,
	0x9e, 0xea, 0x4a, 0x85, 0x46, 0x71, 0x26, 0xf8, 0x55, 0x8a, 0xc1, 0xcb, 0xba, 0xbc, 0xbd, 0xc4,
	0x6b, 0xc4, 0x99, 0xa1, 0x62, 0xa5, 0x30, 0x7a, 0x0b, 0x1a, 0x9d, 0x92, 0x84, 0xd9, 0x0c, 0x27,
	0x91, 0x9d, 0xde, 0x54, 0xcc, 0x2f, 0x36, 0xc2, 0x33, 0x26, 0x8e, 0xdd, 0x18, 0x2a, 0xd6, 0x96,
	0x60, 0x4e, 0x70, 0x12, 0x89, 0xd6, 0x8c, 0x73, 0x00, 0xbd, 0x87, 0xe6, 0xc2, 0xab, 0x10, 0x2d,
	0x5f, 0x32, 0xc0, 0x69, 0x53, 0x05, 0xc6, 0x2f, 0x90, 0x14, 0xd6, 0x83, 0x3a, 0x3c, 0x90, 0xc3,
	0xdc, 0xff, 0x59, 0x83, 0xda, 0x88, 0xfa, 0x28, 0x06, 0x54, 0xf1, 0x6c, 0xba, 0x15, 0xda, 0x95,
	0x53, 0xaf, 0xbd, 0xb8, 0x2b, 0x99, 0x37, 0x15, 0x7d, 0x04, 0x28, 0x3c, 0x8e, 0xce, 0x92, 0x7c,
	0x49, 0x68, 0xdd, 0xdb, 0x08, 0xa9, 0xfc, 0x19, 0xea, 0xc5, 0x57, 0xb1, 0x5b, 0x9d, 0x58, 0x40,
	0xb4, 0x67, 0xb7, 0x22, 0x52, 0x3c, 0x82, 0x8d, 0xf2, 0x78, 0x3e, 0xad, 0xce, 0x2f, 0x81, 0x9a,
	0x79, 0x47, 0x30, 0xb7, 0x1b, 0x8c, 0x2f, 0xae, 0x75, 0xf5, 0xf2, 0x5a, 0x57, 0xff, 0x5c, 0xeb,
	0xea, 0x8f, 0x1b, 0x5d, 0xb9, 0xbc, 0xd1, 0x95, 0xab, 0x1b, 0x5d, 0xf9, 0xf4, 0xca, 0x0f, 0xd8,
	0x74, 0x3e, 0xe9, 0xb9, 0x24, 0x32, 0x17, 0xbe, 0x8b, 0xa7, 0xfb, 0xcf, 0xdd, 0xa9, 0x13, 0xcc,
	0x4c, 0x19, 0x39, 0xcb, 0x3e, 0xed, 0xe7, 0x31, 0xa6, 0x93, 0x15, 0x11, 0x7e, 0xf9, 0x37, 0x00,
	0x00, 0xff, 0xff, 0x8f, 0xa9, 0x8f, 0x1b, 0xfc, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// ProposedOperations is a temporary message used by block proposers
	// for matching orders as part of the ABCI++ workaround.
	ProposedOperations(ctx context.Context, in *MsgProposedOperations, opts ...grpc.CallOption) (*MsgProposedOperationsResponse, error)
	// PlaceOrder allows accounts to place orders on the orderbook.
	PlaceOrder(ctx context.Context, in *MsgPlaceOrder, opts ...grpc.CallOption) (*MsgPlaceOrderResponse, error)
	// CancelOrder allows accounts to cancel existing orders on the orderbook.
	CancelOrder(ctx context.Context, in *MsgCancelOrder, opts ...grpc.CallOption) (*MsgCancelOrderResponse, error)
	// SetClobPairStatus
	SetClobPairStatus(ctx context.Context, in *MsgSetClobPairStatus, opts ...grpc.CallOption) (*MsgSetClobPairStatusResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) ProposedOperations(ctx context.Context, in *MsgProposedOperations, opts ...grpc.CallOption) (*MsgProposedOperationsResponse, error) {
	out := new(MsgProposedOperationsResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/ProposedOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PlaceOrder(ctx context.Context, in *MsgPlaceOrder, opts ...grpc.CallOption) (*MsgPlaceOrderResponse, error) {
	out := new(MsgPlaceOrderResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/PlaceOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelOrder(ctx context.Context, in *MsgCancelOrder, opts ...grpc.CallOption) (*MsgCancelOrderResponse, error) {
	out := new(MsgCancelOrderResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetClobPairStatus(ctx context.Context, in *MsgSetClobPairStatus, opts ...grpc.CallOption) (*MsgSetClobPairStatusResponse, error) {
	out := new(MsgSetClobPairStatusResponse)
	err := c.cc.Invoke(ctx, "/dydxprotocol.clob.Msg/SetClobPairStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// ProposedOperations is a temporary message used by block proposers
	// for matching orders as part of the ABCI++ workaround.
	ProposedOperations(context.Context, *MsgProposedOperations) (*MsgProposedOperationsResponse, error)
	// PlaceOrder allows accounts to place orders on the orderbook.
	PlaceOrder(context.Context, *MsgPlaceOrder) (*MsgPlaceOrderResponse, error)
	// CancelOrder allows accounts to cancel existing orders on the orderbook.
	CancelOrder(context.Context, *MsgCancelOrder) (*MsgCancelOrderResponse, error)
	// SetClobPairStatus
	SetClobPairStatus(context.Context, *MsgSetClobPairStatus) (*MsgSetClobPairStatusResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) ProposedOperations(ctx context.Context, req *MsgProposedOperations) (*MsgProposedOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposedOperations not implemented")
}
func (*UnimplementedMsgServer) PlaceOrder(ctx context.Context, req *MsgPlaceOrder) (*MsgPlaceOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceOrder not implemented")
}
func (*UnimplementedMsgServer) CancelOrder(ctx context.Context, req *MsgCancelOrder) (*MsgCancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (*UnimplementedMsgServer) SetClobPairStatus(ctx context.Context, req *MsgSetClobPairStatus) (*MsgSetClobPairStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetClobPairStatus not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_ProposedOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProposedOperations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProposedOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/ProposedOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProposedOperations(ctx, req.(*MsgProposedOperations))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PlaceOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPlaceOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PlaceOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/PlaceOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PlaceOrder(ctx, req.(*MsgPlaceOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelOrder(ctx, req.(*MsgCancelOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetClobPairStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetClobPairStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetClobPairStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dydxprotocol.clob.Msg/SetClobPairStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetClobPairStatus(ctx, req.(*MsgSetClobPairStatus))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dydxprotocol.clob.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProposedOperations",
			Handler:    _Msg_ProposedOperations_Handler,
		},
		{
			MethodName: "PlaceOrder",
			Handler:    _Msg_PlaceOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Msg_CancelOrder_Handler,
		},
		{
			MethodName: "SetClobPairStatus",
			Handler:    _Msg_SetClobPairStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dydxprotocol/clob/tx.proto",
}

func (m *MsgProposedOperations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposedOperations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposedOperations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperationsQueue) > 0 {
		for iNdEx := len(m.OperationsQueue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperationsQueue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposedOperationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposedOperationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposedOperationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPlaceOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlaceOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlaceOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPlaceOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlaceOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlaceOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCancelOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GoodTilOneof != nil {
		{
			size := m.GoodTilOneof.Size()
			i -= size
			if _, err := m.GoodTilOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	{
		size, err := m.OrderId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCancelOrder_GoodTilBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder_GoodTilBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTx(dAtA, i, uint64(m.GoodTilBlock))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *MsgCancelOrder_GoodTilBlockTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrder_GoodTilBlockTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.GoodTilBlockTime))
	i--
	dAtA[i] = 0x1d
	return len(dAtA) - i, nil
}
func (m *MsgCancelOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetClobPairStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetClobPairStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetClobPairStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.ClobPairId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetClobPairStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetClobPairStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetClobPairStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OperationRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationRaw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		{
			size := m.Operation.Size()
			i -= size
			if _, err := m.Operation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OperationRaw_Match) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OperationRaw_ShortTermOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_ShortTermOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShortTermOrderPlacement != nil {
		i -= len(m.ShortTermOrderPlacement)
		copy(dAtA[i:], m.ShortTermOrderPlacement)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShortTermOrderPlacement)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OperationRaw_OrderRemoval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRaw_OrderRemoval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderRemoval != nil {
		{
			size, err := m.OrderRemoval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgProposedOperations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OperationsQueue) > 0 {
		for _, e := range m.OperationsQueue {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgProposedOperationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPlaceOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPlaceOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCancelOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OrderId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.GoodTilOneof != nil {
		n += m.GoodTilOneof.Size()
	}
	return n
}

func (m *MsgCancelOrder_GoodTilBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTx(uint64(m.GoodTilBlock))
	return n
}
func (m *MsgCancelOrder_GoodTilBlockTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *MsgCancelOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetClobPairStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClobPairId != 0 {
		n += 1 + sovTx(uint64(m.ClobPairId))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	return n
}

func (m *MsgSetClobPairStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OperationRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		n += m.Operation.Size()
	}
	return n
}

func (m *OperationRaw_Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *OperationRaw_ShortTermOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShortTermOrderPlacement != nil {
		l = len(m.ShortTermOrderPlacement)
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *OperationRaw_OrderRemoval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderRemoval != nil {
		l = m.OrderRemoval.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgProposedOperations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposedOperations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposedOperations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationsQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationsQueue = append(m.OperationsQueue, OperationRaw{})
			if err := m.OperationsQueue[len(m.OperationsQueue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposedOperationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposedOperationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposedOperationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlaceOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlaceOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlaceOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlaceOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlaceOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlaceOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlock", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GoodTilOneof = &MsgCancelOrder_GoodTilBlock{v}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlockTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GoodTilOneof = &MsgCancelOrder_GoodTilBlockTime{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetClobPairStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetClobPairStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetClobPairStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ClobPair_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetClobPairStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetClobPairStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetClobPairStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClobMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &OperationRaw_Match{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortTermOrderPlacement", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Operation = &OperationRaw_ShortTermOrderPlacement{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRemoval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderRemoval{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &OperationRaw_OrderRemoval{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
