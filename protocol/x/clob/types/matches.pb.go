// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/clob/matches.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/dydxprotocol/v4-chain/protocol/x/subaccounts/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ClobMatch represents an operations queue entry around all different types
// of matches, specifically regular matches, liquidation matches, and
// deleveraging matches.
type ClobMatch struct {
	// The match type that this message includes.
	//
	// Types that are valid to be assigned to Match:
	//	*ClobMatch_MatchOrders
	//	*ClobMatch_MatchPerpetualLiquidation
	//	*ClobMatch_MatchPerpetualDeleveraging
	Match isClobMatch_Match `protobuf_oneof:"match"`
}

func (m *ClobMatch) Reset()         { *m = ClobMatch{} }
func (m *ClobMatch) String() string { return proto.CompactTextString(m) }
func (*ClobMatch) ProtoMessage()    {}
func (*ClobMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5aa660bc05a1de4, []int{0}
}
func (m *ClobMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClobMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClobMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClobMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClobMatch.Merge(m, src)
}
func (m *ClobMatch) XXX_Size() int {
	return m.Size()
}
func (m *ClobMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ClobMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ClobMatch proto.InternalMessageInfo

type isClobMatch_Match interface {
	isClobMatch_Match()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClobMatch_MatchOrders struct {
	MatchOrders *MatchOrders `protobuf:"bytes,1,opt,name=match_orders,json=matchOrders,proto3,oneof" json:"match_orders,omitempty"`
}
type ClobMatch_MatchPerpetualLiquidation struct {
	MatchPerpetualLiquidation *MatchPerpetualLiquidation `protobuf:"bytes,2,opt,name=match_perpetual_liquidation,json=matchPerpetualLiquidation,proto3,oneof" json:"match_perpetual_liquidation,omitempty"`
}
type ClobMatch_MatchPerpetualDeleveraging struct {
	MatchPerpetualDeleveraging *MatchPerpetualDeleveraging `protobuf:"bytes,3,opt,name=match_perpetual_deleveraging,json=matchPerpetualDeleveraging,proto3,oneof" json:"match_perpetual_deleveraging,omitempty"`
}

func (*ClobMatch_MatchOrders) isClobMatch_Match()                {}
func (*ClobMatch_MatchPerpetualLiquidation) isClobMatch_Match()  {}
func (*ClobMatch_MatchPerpetualDeleveraging) isClobMatch_Match() {}

func (m *ClobMatch) GetMatch() isClobMatch_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ClobMatch) GetMatchOrders() *MatchOrders {
	if x, ok := m.GetMatch().(*ClobMatch_MatchOrders); ok {
		return x.MatchOrders
	}
	return nil
}

func (m *ClobMatch) GetMatchPerpetualLiquidation() *MatchPerpetualLiquidation {
	if x, ok := m.GetMatch().(*ClobMatch_MatchPerpetualLiquidation); ok {
		return x.MatchPerpetualLiquidation
	}
	return nil
}

func (m *ClobMatch) GetMatchPerpetualDeleveraging() *MatchPerpetualDeleveraging {
	if x, ok := m.GetMatch().(*ClobMatch_MatchPerpetualDeleveraging); ok {
		return x.MatchPerpetualDeleveraging
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClobMatch) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClobMatch_MatchOrders)(nil),
		(*ClobMatch_MatchPerpetualLiquidation)(nil),
		(*ClobMatch_MatchPerpetualDeleveraging)(nil),
	}
}

// MakerFill represents the filled amount of a matched maker order.
type MakerFill struct {
	// The filled amount of the matched maker order, in base quantums.
	// TODO(CLOB-571): update to use SerializableInt.
	FillAmount uint64 `protobuf:"varint,1,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty"`
	// The `OrderId` of the matched maker order.
	MakerOrderId OrderId `protobuf:"bytes,2,opt,name=maker_order_id,json=makerOrderId,proto3" json:"maker_order_id"`
}

func (m *MakerFill) Reset()         { *m = MakerFill{} }
func (m *MakerFill) String() string { return proto.CompactTextString(m) }
func (*MakerFill) ProtoMessage()    {}
func (*MakerFill) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5aa660bc05a1de4, []int{1}
}
func (m *MakerFill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MakerFill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MakerFill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MakerFill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MakerFill.Merge(m, src)
}
func (m *MakerFill) XXX_Size() int {
	return m.Size()
}
func (m *MakerFill) XXX_DiscardUnknown() {
	xxx_messageInfo_MakerFill.DiscardUnknown(m)
}

var xxx_messageInfo_MakerFill proto.InternalMessageInfo

func (m *MakerFill) GetFillAmount() uint64 {
	if m != nil {
		return m.FillAmount
	}
	return 0
}

func (m *MakerFill) GetMakerOrderId() OrderId {
	if m != nil {
		return m.MakerOrderId
	}
	return OrderId{}
}

// MatchOrders is an injected message used for matching orders.
type MatchOrders struct {
	// The `OrderId` of the taker order.
	TakerOrderId OrderId `protobuf:"bytes,1,opt,name=taker_order_id,json=takerOrderId,proto3" json:"taker_order_id"`
	// An ordered list of fills created by this taker order.
	Fills []MakerFill `protobuf:"bytes,2,rep,name=fills,proto3" json:"fills"`
}

func (m *MatchOrders) Reset()         { *m = MatchOrders{} }
func (m *MatchOrders) String() string { return proto.CompactTextString(m) }
func (*MatchOrders) ProtoMessage()    {}
func (*MatchOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5aa660bc05a1de4, []int{2}
}
func (m *MatchOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchOrders.Merge(m, src)
}
func (m *MatchOrders) XXX_Size() int {
	return m.Size()
}
func (m *MatchOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MatchOrders proto.InternalMessageInfo

func (m *MatchOrders) GetTakerOrderId() OrderId {
	if m != nil {
		return m.TakerOrderId
	}
	return OrderId{}
}

func (m *MatchOrders) GetFills() []MakerFill {
	if m != nil {
		return m.Fills
	}
	return nil
}

// MatchPerpetualLiquidation is an injected message used for liquidating a
// subaccount.
type MatchPerpetualLiquidation struct {
	// ID of the subaccount that was liquidated.
	Liquidated types.SubaccountId `protobuf:"bytes,1,opt,name=liquidated,proto3" json:"liquidated"`
	// The ID of the clob pair involved in the liquidation.
	ClobPairId uint32 `protobuf:"varint,2,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// The ID of the perpetual involved in the liquidation.
	PerpetualId uint32 `protobuf:"varint,3,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// The total size of the liquidation order including any unfilled size.
	TotalSize uint64 `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	// `true` if liquidating a short position, `false` otherwise.
	IsBuy bool `protobuf:"varint,5,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	// An ordered list of fills created by this liquidation.
	Fills []MakerFill `protobuf:"bytes,6,rep,name=fills,proto3" json:"fills"`
}

func (m *MatchPerpetualLiquidation) Reset()         { *m = MatchPerpetualLiquidation{} }
func (m *MatchPerpetualLiquidation) String() string { return proto.CompactTextString(m) }
func (*MatchPerpetualLiquidation) ProtoMessage()    {}
func (*MatchPerpetualLiquidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5aa660bc05a1de4, []int{3}
}
func (m *MatchPerpetualLiquidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchPerpetualLiquidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchPerpetualLiquidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchPerpetualLiquidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchPerpetualLiquidation.Merge(m, src)
}
func (m *MatchPerpetualLiquidation) XXX_Size() int {
	return m.Size()
}
func (m *MatchPerpetualLiquidation) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchPerpetualLiquidation.DiscardUnknown(m)
}

var xxx_messageInfo_MatchPerpetualLiquidation proto.InternalMessageInfo

func (m *MatchPerpetualLiquidation) GetLiquidated() types.SubaccountId {
	if m != nil {
		return m.Liquidated
	}
	return types.SubaccountId{}
}

func (m *MatchPerpetualLiquidation) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *MatchPerpetualLiquidation) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *MatchPerpetualLiquidation) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *MatchPerpetualLiquidation) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *MatchPerpetualLiquidation) GetFills() []MakerFill {
	if m != nil {
		return m.Fills
	}
	return nil
}

// MatchPerpetualDeleveraging is an injected message used for deleveraging a
// subaccount.
type MatchPerpetualDeleveraging struct {
	// ID of the subaccount that was liquidated.
	Liquidated types.SubaccountId `protobuf:"bytes,1,opt,name=liquidated,proto3" json:"liquidated"`
	// The ID of the perpetual that was liquidated.
	PerpetualId uint32 `protobuf:"varint,2,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// An ordered list of fills created by this liquidation.
	Fills []MatchPerpetualDeleveraging_Fill `protobuf:"bytes,3,rep,name=fills,proto3" json:"fills"`
	// Flag denoting whether the deleveraging operation was for the purpose
	// of final settlement. Final settlement matches are at the oracle price,
	// whereas deleveraging happens at the bankruptcy price of the deleveraged
	// subaccount.
	IsFinalSettlement bool `protobuf:"varint,4,opt,name=is_final_settlement,json=isFinalSettlement,proto3" json:"is_final_settlement,omitempty"`
}

func (m *MatchPerpetualDeleveraging) Reset()         { *m = MatchPerpetualDeleveraging{} }
func (m *MatchPerpetualDeleveraging) String() string { return proto.CompactTextString(m) }
func (*MatchPerpetualDeleveraging) ProtoMessage()    {}
func (*MatchPerpetualDeleveraging) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5aa660bc05a1de4, []int{4}
}
func (m *MatchPerpetualDeleveraging) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchPerpetualDeleveraging) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchPerpetualDeleveraging.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchPerpetualDeleveraging) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchPerpetualDeleveraging.Merge(m, src)
}
func (m *MatchPerpetualDeleveraging) XXX_Size() int {
	return m.Size()
}
func (m *MatchPerpetualDeleveraging) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchPerpetualDeleveraging.DiscardUnknown(m)
}

var xxx_messageInfo_MatchPerpetualDeleveraging proto.InternalMessageInfo

func (m *MatchPerpetualDeleveraging) GetLiquidated() types.SubaccountId {
	if m != nil {
		return m.Liquidated
	}
	return types.SubaccountId{}
}

func (m *MatchPerpetualDeleveraging) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *MatchPerpetualDeleveraging) GetFills() []MatchPerpetualDeleveraging_Fill {
	if m != nil {
		return m.Fills
	}
	return nil
}

func (m *MatchPerpetualDeleveraging) GetIsFinalSettlement() bool {
	if m != nil {
		return m.IsFinalSettlement
	}
	return false
}

// Fill represents a fill between the liquidated and offsetting subaccount.
type MatchPerpetualDeleveraging_Fill struct {
	// ID of the subaccount that was used to offset the liquidated subaccount's
	// position.
	OffsettingSubaccountId types.SubaccountId `protobuf:"bytes,1,opt,name=offsetting_subaccount_id,json=offsettingSubaccountId,proto3" json:"offsetting_subaccount_id"`
	// The amount filled between the liquidated and offsetting position, in
	// base quantums.
	// TODO(CLOB-571): update to use SerializableInt.
	FillAmount uint64 `protobuf:"varint,2,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty"`
}

func (m *MatchPerpetualDeleveraging_Fill) Reset()         { *m = MatchPerpetualDeleveraging_Fill{} }
func (m *MatchPerpetualDeleveraging_Fill) String() string { return proto.CompactTextString(m) }
func (*MatchPerpetualDeleveraging_Fill) ProtoMessage()    {}
func (*MatchPerpetualDeleveraging_Fill) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5aa660bc05a1de4, []int{4, 0}
}
func (m *MatchPerpetualDeleveraging_Fill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchPerpetualDeleveraging_Fill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchPerpetualDeleveraging_Fill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchPerpetualDeleveraging_Fill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchPerpetualDeleveraging_Fill.Merge(m, src)
}
func (m *MatchPerpetualDeleveraging_Fill) XXX_Size() int {
	return m.Size()
}
func (m *MatchPerpetualDeleveraging_Fill) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchPerpetualDeleveraging_Fill.DiscardUnknown(m)
}

var xxx_messageInfo_MatchPerpetualDeleveraging_Fill proto.InternalMessageInfo

func (m *MatchPerpetualDeleveraging_Fill) GetOffsettingSubaccountId() types.SubaccountId {
	if m != nil {
		return m.OffsettingSubaccountId
	}
	return types.SubaccountId{}
}

func (m *MatchPerpetualDeleveraging_Fill) GetFillAmount() uint64 {
	if m != nil {
		return m.FillAmount
	}
	return 0
}

func init() {
	proto.RegisterType((*ClobMatch)(nil), "dydxprotocol.clob.ClobMatch")
	proto.RegisterType((*MakerFill)(nil), "dydxprotocol.clob.MakerFill")
	proto.RegisterType((*MatchOrders)(nil), "dydxprotocol.clob.MatchOrders")
	proto.RegisterType((*MatchPerpetualLiquidation)(nil), "dydxprotocol.clob.MatchPerpetualLiquidation")
	proto.RegisterType((*MatchPerpetualDeleveraging)(nil), "dydxprotocol.clob.MatchPerpetualDeleveraging")
	proto.RegisterType((*MatchPerpetualDeleveraging_Fill)(nil), "dydxprotocol.clob.MatchPerpetualDeleveraging.Fill")
}

func init() { proto.RegisterFile("dydxprotocol/clob/matches.proto", fileDescriptor_a5aa660bc05a1de4) }

var fileDescriptor_a5aa660bc05a1de4 = []byte{
	// 615 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x4e, 0xdb, 0x40,
	0x10, 0xb6, 0xf3, 0x43, 0x61, 0x1c, 0x2a, 0xb1, 0xfd, 0x91, 0x71, 0xc1, 0xa4, 0x39, 0x54, 0x54,
	0x2a, 0x8e, 0x44, 0xab, 0xaa, 0xd7, 0x86, 0x0a, 0x81, 0x04, 0x2d, 0x32, 0xb7, 0x5e, 0x2c, 0xff,
	0x6c, 0xcc, 0xaa, 0x6b, 0x6f, 0xb0, 0xd7, 0x88, 0xf0, 0x12, 0xf4, 0x09, 0xda, 0x17, 0xe9, 0x03,
	0x70, 0xe4, 0xd8, 0x53, 0x55, 0xc1, 0x8b, 0x54, 0xbb, 0x4e, 0x6c, 0x27, 0x21, 0x6a, 0x91, 0x7a,
	0x5b, 0x7f, 0x33, 0xf3, 0xed, 0x7c, 0xdf, 0xce, 0x18, 0x36, 0x82, 0x61, 0x70, 0x3e, 0x48, 0x18,
	0x67, 0x3e, 0xa3, 0x5d, 0x9f, 0x32, 0xaf, 0x1b, 0xb9, 0xdc, 0x3f, 0xc1, 0xa9, 0x25, 0x51, 0xb4,
	0x52, 0x4d, 0xb0, 0x44, 0x82, 0xf1, 0x38, 0x64, 0x21, 0x93, 0x50, 0x57, 0x9c, 0xf2, 0x44, 0xe3,
	0xe5, 0x04, 0x53, 0x9a, 0x79, 0xae, 0xef, 0xb3, 0x2c, 0xe6, 0x69, 0xe5, 0x3c, 0x4a, 0x5d, 0x9f,
	0xbd, 0x94, 0x25, 0x01, 0x4e, 0xf2, 0x70, 0xe7, 0x47, 0x0d, 0x96, 0x76, 0x28, 0xf3, 0x0e, 0x45,
	0x23, 0x68, 0x07, 0x5a, 0xb2, 0x23, 0x47, 0xa6, 0xa4, 0xba, 0xda, 0x56, 0x37, 0xb5, 0x6d, 0xd3,
	0x9a, 0xe9, 0xcb, 0x92, 0xf9, 0x9f, 0x64, 0xd6, 0x9e, 0x62, 0x6b, 0x51, 0xf9, 0x89, 0x62, 0x78,
	0x96, 0x93, 0x0c, 0x70, 0x32, 0xc0, 0x3c, 0x73, 0xa9, 0x43, 0xc9, 0x69, 0x46, 0x02, 0x97, 0x13,
	0x16, 0xeb, 0x35, 0xc9, 0xf9, 0x6a, 0x1e, 0xe7, 0xd1, 0xb8, 0xe8, 0xa0, 0xac, 0xd9, 0x53, 0xec,
	0xd5, 0x68, 0x5e, 0x10, 0x9d, 0xc2, 0xda, 0xf4, 0x7d, 0x01, 0xa6, 0xf8, 0x0c, 0x27, 0x6e, 0x48,
	0xe2, 0x50, 0xaf, 0xcb, 0x0b, 0xb7, 0xfe, 0x7a, 0xe1, 0x87, 0x4a, 0xd1, 0x9e, 0x62, 0x1b, 0xd1,
	0xdc, 0x68, 0xef, 0x01, 0x34, 0x65, 0xb4, 0xc3, 0x61, 0xe9, 0xd0, 0xfd, 0x82, 0x93, 0x5d, 0x42,
	0x29, 0xda, 0x00, 0xad, 0x4f, 0x28, 0x75, 0xdc, 0x48, 0xf8, 0x2f, 0xcd, 0x6b, 0xd8, 0x20, 0xa0,
	0xf7, 0x12, 0x41, 0xbb, 0xf0, 0x30, 0x12, 0xd9, 0xb9, 0xbd, 0x0e, 0x09, 0x46, 0x66, 0x18, 0x77,
	0xf4, 0x26, 0xcd, 0xdc, 0x0f, 0x7a, 0x8d, 0xab, 0x5f, 0x1b, 0x8a, 0xdd, 0x92, 0x75, 0x23, 0xac,
	0x73, 0xa9, 0x82, 0x56, 0x79, 0x00, 0xc1, 0xcb, 0x27, 0x79, 0xd5, 0x7f, 0xe5, 0xe5, 0x15, 0x5e,
	0xf4, 0x0e, 0x9a, 0xa2, 0xdb, 0x54, 0xaf, 0xb5, 0xeb, 0x9b, 0xda, 0xf6, 0xda, 0x9d, 0x96, 0x8d,
	0xd4, 0x8e, 0x08, 0xf2, 0x82, 0xce, 0xb7, 0x1a, 0xac, 0xce, 0x7d, 0x3e, 0x74, 0x00, 0x30, 0x9e,
	0x00, 0x3c, 0xee, 0xed, 0xc5, 0x24, 0x79, 0x65, 0x86, 0xad, 0xe3, 0xe2, 0x5c, 0xf4, 0x59, 0xa9,
	0x47, 0x6d, 0x68, 0x89, 0x56, 0x9c, 0x81, 0x4b, 0x0a, 0x0f, 0x97, 0x6d, 0x10, 0xd8, 0x91, 0x4b,
	0x84, 0x8e, 0xe7, 0xd0, 0x2a, 0x67, 0x81, 0x04, 0x72, 0x02, 0x96, 0x6d, 0xad, 0xc0, 0xf6, 0x03,
	0xb4, 0x0e, 0xc0, 0x19, 0x77, 0xa9, 0x93, 0x92, 0x0b, 0xac, 0x37, 0xe4, 0x53, 0x2d, 0x49, 0xe4,
	0x98, 0x5c, 0x60, 0xf4, 0x04, 0x16, 0x48, 0xea, 0x78, 0xd9, 0x50, 0x6f, 0xb6, 0xd5, 0xcd, 0x45,
	0xbb, 0x49, 0xd2, 0x5e, 0x36, 0x2c, 0x0d, 0x5a, 0xb8, 0xaf, 0x41, 0xdf, 0xeb, 0x60, 0xcc, 0x1f,
	0xb7, 0xff, 0xec, 0xd0, 0xb4, 0xfe, 0xda, 0xac, 0xfe, 0x8f, 0x63, 0x25, 0x75, 0xa9, 0x64, 0xfb,
	0x5e, 0xdb, 0x61, 0xcd, 0xe8, 0x43, 0x16, 0x3c, 0x22, 0xa9, 0xd3, 0x27, 0xb1, 0xb0, 0x14, 0x73,
	0x4e, 0x71, 0x84, 0x63, 0x2e, 0x8d, 0x5d, 0xb4, 0x57, 0x48, 0xba, 0x2b, 0x22, 0xc7, 0x45, 0xc0,
	0xb8, 0x54, 0xa1, 0x21, 0x97, 0xa6, 0x0f, 0x3a, 0xeb, 0xf7, 0x45, 0x09, 0x89, 0x43, 0xa7, 0x14,
	0x59, 0x4e, 0xf1, 0xfd, 0x7c, 0x78, 0x5a, 0xb2, 0x55, 0xa3, 0xd3, 0xcb, 0x59, 0x9b, 0x5e, 0xce,
	0xde, 0xd1, 0xd5, 0x8d, 0xa9, 0x5e, 0xdf, 0x98, 0xea, 0xef, 0x1b, 0x53, 0xfd, 0x7a, 0x6b, 0x2a,
	0xd7, 0xb7, 0xa6, 0xf2, 0xf3, 0xd6, 0x54, 0x3e, 0xbf, 0x0d, 0x09, 0x3f, 0xc9, 0x3c, 0xcb, 0x67,
	0x51, 0x77, 0xe2, 0x6f, 0x7a, 0xf6, 0x66, 0xcb, 0x3f, 0x71, 0x49, 0xdc, 0x2d, 0x90, 0xf3, 0xfc,
	0x0f, 0xcb, 0x87, 0x03, 0x9c, 0x7a, 0x0b, 0x12, 0x7e, 0xfd, 0x27, 0x00, 0x00, 0xff, 0xff, 0xa0,
	0xfc, 0x47, 0x56, 0xf8, 0x05, 0x00, 0x00,
}

func (m *ClobMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClobMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClobMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClobMatch_MatchOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClobMatch_MatchOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MatchOrders != nil {
		{
			size, err := m.MatchOrders.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMatches(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ClobMatch_MatchPerpetualLiquidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClobMatch_MatchPerpetualLiquidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MatchPerpetualLiquidation != nil {
		{
			size, err := m.MatchPerpetualLiquidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMatches(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ClobMatch_MatchPerpetualDeleveraging) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClobMatch_MatchPerpetualDeleveraging) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MatchPerpetualDeleveraging != nil {
		{
			size, err := m.MatchPerpetualDeleveraging.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMatches(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MakerFill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MakerFill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MakerFill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MakerOrderId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMatches(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FillAmount != 0 {
		i = encodeVarintMatches(dAtA, i, uint64(m.FillAmount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fills) > 0 {
		for iNdEx := len(m.Fills) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fills[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMatches(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.TakerOrderId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMatches(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MatchPerpetualLiquidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchPerpetualLiquidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchPerpetualLiquidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fills) > 0 {
		for iNdEx := len(m.Fills) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fills[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMatches(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TotalSize != 0 {
		i = encodeVarintMatches(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x20
	}
	if m.PerpetualId != 0 {
		i = encodeVarintMatches(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x18
	}
	if m.ClobPairId != 0 {
		i = encodeVarintMatches(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Liquidated.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMatches(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MatchPerpetualDeleveraging) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchPerpetualDeleveraging) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchPerpetualDeleveraging) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFinalSettlement {
		i--
		if m.IsFinalSettlement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Fills) > 0 {
		for iNdEx := len(m.Fills) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fills[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMatches(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PerpetualId != 0 {
		i = encodeVarintMatches(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Liquidated.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMatches(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MatchPerpetualDeleveraging_Fill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchPerpetualDeleveraging_Fill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchPerpetualDeleveraging_Fill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FillAmount != 0 {
		i = encodeVarintMatches(dAtA, i, uint64(m.FillAmount))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.OffsettingSubaccountId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMatches(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintMatches(dAtA []byte, offset int, v uint64) int {
	offset -= sovMatches(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClobMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		n += m.Match.Size()
	}
	return n
}

func (m *ClobMatch_MatchOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchOrders != nil {
		l = m.MatchOrders.Size()
		n += 1 + l + sovMatches(uint64(l))
	}
	return n
}
func (m *ClobMatch_MatchPerpetualLiquidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchPerpetualLiquidation != nil {
		l = m.MatchPerpetualLiquidation.Size()
		n += 1 + l + sovMatches(uint64(l))
	}
	return n
}
func (m *ClobMatch_MatchPerpetualDeleveraging) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchPerpetualDeleveraging != nil {
		l = m.MatchPerpetualDeleveraging.Size()
		n += 1 + l + sovMatches(uint64(l))
	}
	return n
}
func (m *MakerFill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FillAmount != 0 {
		n += 1 + sovMatches(uint64(m.FillAmount))
	}
	l = m.MakerOrderId.Size()
	n += 1 + l + sovMatches(uint64(l))
	return n
}

func (m *MatchOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TakerOrderId.Size()
	n += 1 + l + sovMatches(uint64(l))
	if len(m.Fills) > 0 {
		for _, e := range m.Fills {
			l = e.Size()
			n += 1 + l + sovMatches(uint64(l))
		}
	}
	return n
}

func (m *MatchPerpetualLiquidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Liquidated.Size()
	n += 1 + l + sovMatches(uint64(l))
	if m.ClobPairId != 0 {
		n += 1 + sovMatches(uint64(m.ClobPairId))
	}
	if m.PerpetualId != 0 {
		n += 1 + sovMatches(uint64(m.PerpetualId))
	}
	if m.TotalSize != 0 {
		n += 1 + sovMatches(uint64(m.TotalSize))
	}
	if m.IsBuy {
		n += 2
	}
	if len(m.Fills) > 0 {
		for _, e := range m.Fills {
			l = e.Size()
			n += 1 + l + sovMatches(uint64(l))
		}
	}
	return n
}

func (m *MatchPerpetualDeleveraging) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Liquidated.Size()
	n += 1 + l + sovMatches(uint64(l))
	if m.PerpetualId != 0 {
		n += 1 + sovMatches(uint64(m.PerpetualId))
	}
	if len(m.Fills) > 0 {
		for _, e := range m.Fills {
			l = e.Size()
			n += 1 + l + sovMatches(uint64(l))
		}
	}
	if m.IsFinalSettlement {
		n += 2
	}
	return n
}

func (m *MatchPerpetualDeleveraging_Fill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OffsettingSubaccountId.Size()
	n += 1 + l + sovMatches(uint64(l))
	if m.FillAmount != 0 {
		n += 1 + sovMatches(uint64(m.FillAmount))
	}
	return n
}

func sovMatches(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMatches(x uint64) (n int) {
	return sovMatches(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClobMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatches
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClobMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClobMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatchOrders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ClobMatch_MatchOrders{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchPerpetualLiquidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatchPerpetualLiquidation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ClobMatch_MatchPerpetualLiquidation{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchPerpetualDeleveraging", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatchPerpetualDeleveraging{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ClobMatch_MatchPerpetualDeleveraging{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatches(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMatches
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MakerFill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatches
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MakerFill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MakerFill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillAmount", wireType)
			}
			m.FillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatches(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMatches
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatches
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fills = append(m.Fills, MakerFill{})
			if err := m.Fills[len(m.Fills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatches(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMatches
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchPerpetualLiquidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatches
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchPerpetualLiquidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchPerpetualLiquidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Liquidated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fills = append(m.Fills, MakerFill{})
			if err := m.Fills[len(m.Fills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatches(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMatches
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchPerpetualDeleveraging) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatches
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchPerpetualDeleveraging: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchPerpetualDeleveraging: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Liquidated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fills = append(m.Fills, MatchPerpetualDeleveraging_Fill{})
			if err := m.Fills[len(m.Fills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinalSettlement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFinalSettlement = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMatches(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMatches
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchPerpetualDeleveraging_Fill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatches
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsettingSubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatches
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMatches
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OffsettingSubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillAmount", wireType)
			}
			m.FillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatches(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMatches
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMatches(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMatches
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatches
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMatches
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMatches
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMatches
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMatches        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMatches          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMatches = fmt.Errorf("proto: unexpected end of group")
)
