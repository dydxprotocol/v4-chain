// Code generated by mockery v2.46.0. DO NOT EDIT.

package mocks

import (
	client "github.com/cosmos/cosmos-sdk/client"
	mock "github.com/stretchr/testify/mock"

	signing "github.com/cosmos/cosmos-sdk/types/tx/signing"

	txsigning "cosmossdk.io/x/tx/signing"

	types "github.com/cosmos/cosmos-sdk/types"
)

// TxConfig is an autogenerated mock type for the TxConfig type
type TxConfig struct {
	mock.Mock
}

// MarshalSignatureJSON provides a mock function with given fields: _a0
func (_m *TxConfig) MarshalSignatureJSON(_a0 []signing.SignatureV2) ([]byte, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for MarshalSignatureJSON")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func([]signing.SignatureV2) ([]byte, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func([]signing.SignatureV2) []byte); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]signing.SignatureV2) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewTxBuilder provides a mock function with given fields:
func (_m *TxConfig) NewTxBuilder() client.TxBuilder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewTxBuilder")
	}

	var r0 client.TxBuilder
	if rf, ok := ret.Get(0).(func() client.TxBuilder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.TxBuilder)
		}
	}

	return r0
}

// SignModeHandler provides a mock function with given fields:
func (_m *TxConfig) SignModeHandler() *txsigning.HandlerMap {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SignModeHandler")
	}

	var r0 *txsigning.HandlerMap
	if rf, ok := ret.Get(0).(func() *txsigning.HandlerMap); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*txsigning.HandlerMap)
		}
	}

	return r0
}

// SigningContext provides a mock function with given fields:
func (_m *TxConfig) SigningContext() *txsigning.Context {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SigningContext")
	}

	var r0 *txsigning.Context
	if rf, ok := ret.Get(0).(func() *txsigning.Context); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*txsigning.Context)
		}
	}

	return r0
}

// TxDecoder provides a mock function with given fields:
func (_m *TxConfig) TxDecoder() types.TxDecoder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxDecoder")
	}

	var r0 types.TxDecoder
	if rf, ok := ret.Get(0).(func() types.TxDecoder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TxDecoder)
		}
	}

	return r0
}

// TxEncoder provides a mock function with given fields:
func (_m *TxConfig) TxEncoder() types.TxEncoder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxEncoder")
	}

	var r0 types.TxEncoder
	if rf, ok := ret.Get(0).(func() types.TxEncoder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TxEncoder)
		}
	}

	return r0
}

// TxJSONDecoder provides a mock function with given fields:
func (_m *TxConfig) TxJSONDecoder() types.TxDecoder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxJSONDecoder")
	}

	var r0 types.TxDecoder
	if rf, ok := ret.Get(0).(func() types.TxDecoder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TxDecoder)
		}
	}

	return r0
}

// TxJSONEncoder provides a mock function with given fields:
func (_m *TxConfig) TxJSONEncoder() types.TxEncoder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxJSONEncoder")
	}

	var r0 types.TxEncoder
	if rf, ok := ret.Get(0).(func() types.TxEncoder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TxEncoder)
		}
	}

	return r0
}

// UnmarshalSignatureJSON provides a mock function with given fields: _a0
func (_m *TxConfig) UnmarshalSignatureJSON(_a0 []byte) ([]signing.SignatureV2, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for UnmarshalSignatureJSON")
	}

	var r0 []signing.SignatureV2
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) ([]signing.SignatureV2, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func([]byte) []signing.SignatureV2); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]signing.SignatureV2)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WrapTxBuilder provides a mock function with given fields: _a0
func (_m *TxConfig) WrapTxBuilder(_a0 types.Tx) (client.TxBuilder, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for WrapTxBuilder")
	}

	var r0 client.TxBuilder
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Tx) (client.TxBuilder, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(types.Tx) client.TxBuilder); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.TxBuilder)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Tx) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewTxConfig creates a new instance of TxConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTxConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *TxConfig {
	mock := &TxConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
