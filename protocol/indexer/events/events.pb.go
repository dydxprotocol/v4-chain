// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/indexer/events/events.proto

package events

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_dydxprotocol_v4_chain_protocol_dtypes "github.com/dydxprotocol/v4-chain/protocol/dtypes"
	types "github.com/dydxprotocol/v4-chain/protocol/indexer/protocol/v1/types"
	types1 "github.com/dydxprotocol/v4-chain/protocol/indexer/shared/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Type is the type for funding values.
type FundingEventV1_Type int32

const (
	// Unspecified type.
	FundingEventV1_TYPE_UNSPECIFIED FundingEventV1_Type = 0
	// Premium sample is the combined value from all premium votes during a
	// `funding-sample` epoch.
	FundingEventV1_TYPE_PREMIUM_SAMPLE FundingEventV1_Type = 1
	// Funding rate is the final funding rate combining all premium samples
	// during a `funding-tick` epoch.
	FundingEventV1_TYPE_FUNDING_RATE_AND_INDEX FundingEventV1_Type = 2
	// TODO(DEC-1513): Investigate whether premium vote values need to be
	// sent to indexer.
	FundingEventV1_TYPE_PREMIUM_VOTE FundingEventV1_Type = 3
)

var FundingEventV1_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "TYPE_PREMIUM_SAMPLE",
	2: "TYPE_FUNDING_RATE_AND_INDEX",
	3: "TYPE_PREMIUM_VOTE",
}

var FundingEventV1_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED":            0,
	"TYPE_PREMIUM_SAMPLE":         1,
	"TYPE_FUNDING_RATE_AND_INDEX": 2,
	"TYPE_PREMIUM_VOTE":           3,
}

func (x FundingEventV1_Type) String() string {
	return proto.EnumName(FundingEventV1_Type_name, int32(x))
}

func (FundingEventV1_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{1, 0}
}

// FundingUpdate is used for funding update events and includes a funding
// value and an optional funding index that correspond to a perpetual market.
type FundingUpdateV1 struct {
	// The id of the perpetual market.
	PerpetualId uint32 `protobuf:"varint,1,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// funding value (in parts-per-million) can be premium vote, premium sample,
	// or funding rate.
	FundingValuePpm int32 `protobuf:"varint,2,opt,name=funding_value_ppm,json=fundingValuePpm,proto3" json:"funding_value_ppm,omitempty"`
	// funding index is required if and only if parent `FundingEvent` type is
	// `TYPE_FUNDING_RATE_AND_INDEX`.
	FundingIndex github_com_dydxprotocol_v4_chain_protocol_dtypes.SerializableInt `protobuf:"bytes,3,opt,name=funding_index,json=fundingIndex,proto3,customtype=github.com/dydxprotocol/v4-chain/protocol/dtypes.SerializableInt" json:"funding_index"`
}

func (m *FundingUpdateV1) Reset()         { *m = FundingUpdateV1{} }
func (m *FundingUpdateV1) String() string { return proto.CompactTextString(m) }
func (*FundingUpdateV1) ProtoMessage()    {}
func (*FundingUpdateV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{0}
}
func (m *FundingUpdateV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingUpdateV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingUpdateV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingUpdateV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingUpdateV1.Merge(m, src)
}
func (m *FundingUpdateV1) XXX_Size() int {
	return m.Size()
}
func (m *FundingUpdateV1) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingUpdateV1.DiscardUnknown(m)
}

var xxx_messageInfo_FundingUpdateV1 proto.InternalMessageInfo

func (m *FundingUpdateV1) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *FundingUpdateV1) GetFundingValuePpm() int32 {
	if m != nil {
		return m.FundingValuePpm
	}
	return 0
}

// FundingEvent message contains a list of per-market funding values. The
// funding values in the list is of the same type and the types are: which can
// have one of the following types:
//  1. Premium vote: votes on the premium values injected by block proposers.
//  2. Premium sample: combined value from all premium votes during a
//     `funding-sample` epoch.
//  3. Funding rate and index: final funding rate combining all premium samples
//     during a `funding-tick` epoch and funding index accordingly updated with
//     `funding rate * price`.
type FundingEventV1 struct {
	// updates is a list of per-market funding updates for all existing perpetual
	// markets. The list is sorted by `perpetualId`s which are unique.
	Updates []FundingUpdateV1 `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates"`
	// type stores the type of funding updates.
	Type FundingEventV1_Type `protobuf:"varint,2,opt,name=type,proto3,enum=dydxprotocol.indexer.events.FundingEventV1_Type" json:"type,omitempty"`
}

func (m *FundingEventV1) Reset()         { *m = FundingEventV1{} }
func (m *FundingEventV1) String() string { return proto.CompactTextString(m) }
func (*FundingEventV1) ProtoMessage()    {}
func (*FundingEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{1}
}
func (m *FundingEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingEventV1.Merge(m, src)
}
func (m *FundingEventV1) XXX_Size() int {
	return m.Size()
}
func (m *FundingEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_FundingEventV1 proto.InternalMessageInfo

func (m *FundingEventV1) GetUpdates() []FundingUpdateV1 {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *FundingEventV1) GetType() FundingEventV1_Type {
	if m != nil {
		return m.Type
	}
	return FundingEventV1_TYPE_UNSPECIFIED
}

// MarketEvent message contains all the information about a market event on
// the dYdX chain.
type MarketEventV1 struct {
	// market id.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// either an event for price update, market creation, or market modification.
	//
	// Types that are valid to be assigned to Event:
	//	*MarketEventV1_PriceUpdate
	//	*MarketEventV1_MarketCreate
	//	*MarketEventV1_MarketModify
	Event isMarketEventV1_Event `protobuf_oneof:"event"`
}

func (m *MarketEventV1) Reset()         { *m = MarketEventV1{} }
func (m *MarketEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketEventV1) ProtoMessage()    {}
func (*MarketEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{2}
}
func (m *MarketEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketEventV1.Merge(m, src)
}
func (m *MarketEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketEventV1 proto.InternalMessageInfo

type isMarketEventV1_Event interface {
	isMarketEventV1_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MarketEventV1_PriceUpdate struct {
	PriceUpdate *MarketPriceUpdateEventV1 `protobuf:"bytes,2,opt,name=price_update,json=priceUpdate,proto3,oneof" json:"price_update,omitempty"`
}
type MarketEventV1_MarketCreate struct {
	MarketCreate *MarketCreateEventV1 `protobuf:"bytes,3,opt,name=market_create,json=marketCreate,proto3,oneof" json:"market_create,omitempty"`
}
type MarketEventV1_MarketModify struct {
	MarketModify *MarketModifyEventV1 `protobuf:"bytes,4,opt,name=market_modify,json=marketModify,proto3,oneof" json:"market_modify,omitempty"`
}

func (*MarketEventV1_PriceUpdate) isMarketEventV1_Event()  {}
func (*MarketEventV1_MarketCreate) isMarketEventV1_Event() {}
func (*MarketEventV1_MarketModify) isMarketEventV1_Event() {}

func (m *MarketEventV1) GetEvent() isMarketEventV1_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *MarketEventV1) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *MarketEventV1) GetPriceUpdate() *MarketPriceUpdateEventV1 {
	if x, ok := m.GetEvent().(*MarketEventV1_PriceUpdate); ok {
		return x.PriceUpdate
	}
	return nil
}

func (m *MarketEventV1) GetMarketCreate() *MarketCreateEventV1 {
	if x, ok := m.GetEvent().(*MarketEventV1_MarketCreate); ok {
		return x.MarketCreate
	}
	return nil
}

func (m *MarketEventV1) GetMarketModify() *MarketModifyEventV1 {
	if x, ok := m.GetEvent().(*MarketEventV1_MarketModify); ok {
		return x.MarketModify
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MarketEventV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MarketEventV1_PriceUpdate)(nil),
		(*MarketEventV1_MarketCreate)(nil),
		(*MarketEventV1_MarketModify)(nil),
	}
}

// MarketPriceUpdateEvent message contains all the information about a price
// update on the dYdX chain.
type MarketPriceUpdateEventV1 struct {
	// price_with_exponent. Multiply by 10 ^ Exponent to get the human readable
	// price in dollars. For example if `Exponent == -5` then a `exponent_price`
	// of `1,000,000,000` represents “$10,000`.
	PriceWithExponent uint64 `protobuf:"varint,1,opt,name=price_with_exponent,json=priceWithExponent,proto3" json:"price_with_exponent,omitempty"`
}

func (m *MarketPriceUpdateEventV1) Reset()         { *m = MarketPriceUpdateEventV1{} }
func (m *MarketPriceUpdateEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketPriceUpdateEventV1) ProtoMessage()    {}
func (*MarketPriceUpdateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{3}
}
func (m *MarketPriceUpdateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketPriceUpdateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketPriceUpdateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketPriceUpdateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketPriceUpdateEventV1.Merge(m, src)
}
func (m *MarketPriceUpdateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketPriceUpdateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketPriceUpdateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketPriceUpdateEventV1 proto.InternalMessageInfo

func (m *MarketPriceUpdateEventV1) GetPriceWithExponent() uint64 {
	if m != nil {
		return m.PriceWithExponent
	}
	return 0
}

// shared fields between MarketCreateEvent and MarketModifyEvent
type MarketBaseEventV1 struct {
	// String representation of the market pair, e.g. `BTC-USD`
	Pair string `protobuf:"bytes,1,opt,name=pair,proto3" json:"pair,omitempty"`
	// The minimum allowable change in the Price value for a given update.
	// Measured as 1e-6.
	MinPriceChangePpm uint32 `protobuf:"varint,2,opt,name=min_price_change_ppm,json=minPriceChangePpm,proto3" json:"min_price_change_ppm,omitempty"`
}

func (m *MarketBaseEventV1) Reset()         { *m = MarketBaseEventV1{} }
func (m *MarketBaseEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketBaseEventV1) ProtoMessage()    {}
func (*MarketBaseEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{4}
}
func (m *MarketBaseEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketBaseEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketBaseEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketBaseEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketBaseEventV1.Merge(m, src)
}
func (m *MarketBaseEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketBaseEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketBaseEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketBaseEventV1 proto.InternalMessageInfo

func (m *MarketBaseEventV1) GetPair() string {
	if m != nil {
		return m.Pair
	}
	return ""
}

func (m *MarketBaseEventV1) GetMinPriceChangePpm() uint32 {
	if m != nil {
		return m.MinPriceChangePpm
	}
	return 0
}

// MarketCreateEvent message contains all the information about a new market on
// the dYdX chain.
type MarketCreateEventV1 struct {
	Base *MarketBaseEventV1 `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	// Static value. The exponent of the price.
	// For example if Exponent == -5 then a `exponent_price` of 1,000,000,000
	// represents $10,000. Therefore 10 ^ Exponent represents the smallest
	// price step (in dollars) that can be recorded.
	Exponent int32 `protobuf:"zigzag32,2,opt,name=exponent,proto3" json:"exponent,omitempty"`
}

func (m *MarketCreateEventV1) Reset()         { *m = MarketCreateEventV1{} }
func (m *MarketCreateEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketCreateEventV1) ProtoMessage()    {}
func (*MarketCreateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{5}
}
func (m *MarketCreateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketCreateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketCreateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketCreateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketCreateEventV1.Merge(m, src)
}
func (m *MarketCreateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketCreateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketCreateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketCreateEventV1 proto.InternalMessageInfo

func (m *MarketCreateEventV1) GetBase() *MarketBaseEventV1 {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *MarketCreateEventV1) GetExponent() int32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

// MarketModifyEvent message contains all the information about a market update
// on the dYdX chain
type MarketModifyEventV1 struct {
	Base *MarketBaseEventV1 `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
}

func (m *MarketModifyEventV1) Reset()         { *m = MarketModifyEventV1{} }
func (m *MarketModifyEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketModifyEventV1) ProtoMessage()    {}
func (*MarketModifyEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{6}
}
func (m *MarketModifyEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketModifyEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketModifyEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketModifyEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketModifyEventV1.Merge(m, src)
}
func (m *MarketModifyEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketModifyEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketModifyEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketModifyEventV1 proto.InternalMessageInfo

func (m *MarketModifyEventV1) GetBase() *MarketBaseEventV1 {
	if m != nil {
		return m.Base
	}
	return nil
}

// SourceOfFunds is the source of funds in a transfer event.
type SourceOfFunds struct {
	//  one of below
	// - a subaccount ID
	// - a wallet address
	//
	// Types that are valid to be assigned to Source:
	//	*SourceOfFunds_SubaccountId
	//	*SourceOfFunds_Address
	Source isSourceOfFunds_Source `protobuf_oneof:"source"`
}

func (m *SourceOfFunds) Reset()         { *m = SourceOfFunds{} }
func (m *SourceOfFunds) String() string { return proto.CompactTextString(m) }
func (*SourceOfFunds) ProtoMessage()    {}
func (*SourceOfFunds) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{7}
}
func (m *SourceOfFunds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceOfFunds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceOfFunds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceOfFunds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceOfFunds.Merge(m, src)
}
func (m *SourceOfFunds) XXX_Size() int {
	return m.Size()
}
func (m *SourceOfFunds) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceOfFunds.DiscardUnknown(m)
}

var xxx_messageInfo_SourceOfFunds proto.InternalMessageInfo

type isSourceOfFunds_Source interface {
	isSourceOfFunds_Source()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SourceOfFunds_SubaccountId struct {
	SubaccountId *types.IndexerSubaccountId `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3,oneof" json:"subaccount_id,omitempty"`
}
type SourceOfFunds_Address struct {
	Address string `protobuf:"bytes,2,opt,name=address,proto3,oneof" json:"address,omitempty"`
}

func (*SourceOfFunds_SubaccountId) isSourceOfFunds_Source() {}
func (*SourceOfFunds_Address) isSourceOfFunds_Source()      {}

func (m *SourceOfFunds) GetSource() isSourceOfFunds_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *SourceOfFunds) GetSubaccountId() *types.IndexerSubaccountId {
	if x, ok := m.GetSource().(*SourceOfFunds_SubaccountId); ok {
		return x.SubaccountId
	}
	return nil
}

func (m *SourceOfFunds) GetAddress() string {
	if x, ok := m.GetSource().(*SourceOfFunds_Address); ok {
		return x.Address
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SourceOfFunds) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SourceOfFunds_SubaccountId)(nil),
		(*SourceOfFunds_Address)(nil),
	}
}

// TransferEvent message contains all the information about a transfer,
// deposit-to-subaccount, or withdraw-from-subaccount on the dYdX chain.
// When a subaccount is involved, a SubaccountUpdateEvent message will
// be produced with the updated asset positions.
type TransferEventV1 struct {
	SenderSubaccountId    *types.IndexerSubaccountId `protobuf:"bytes,1,opt,name=sender_subaccount_id,json=senderSubaccountId,proto3" json:"sender_subaccount_id,omitempty"`
	RecipientSubaccountId *types.IndexerSubaccountId `protobuf:"bytes,2,opt,name=recipient_subaccount_id,json=recipientSubaccountId,proto3" json:"recipient_subaccount_id,omitempty"`
	// Id of the asset transfered.
	AssetId uint32 `protobuf:"varint,3,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The amount of asset in quantums to transfer.
	Amount uint64 `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
	// The sender is one of below
	// - a subaccount ID (in transfer and withdraw events).
	// - a wallet address (in deposit events).
	Sender *SourceOfFunds `protobuf:"bytes,5,opt,name=sender,proto3" json:"sender,omitempty"`
	// The recipient is one of below
	// - a subaccount ID (in transfer and deposit events).
	// - a wallet address (in withdraw events).
	Recipient *SourceOfFunds `protobuf:"bytes,6,opt,name=recipient,proto3" json:"recipient,omitempty"`
}

func (m *TransferEventV1) Reset()         { *m = TransferEventV1{} }
func (m *TransferEventV1) String() string { return proto.CompactTextString(m) }
func (*TransferEventV1) ProtoMessage()    {}
func (*TransferEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{8}
}
func (m *TransferEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferEventV1.Merge(m, src)
}
func (m *TransferEventV1) XXX_Size() int {
	return m.Size()
}
func (m *TransferEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_TransferEventV1 proto.InternalMessageInfo

func (m *TransferEventV1) GetSenderSubaccountId() *types.IndexerSubaccountId {
	if m != nil {
		return m.SenderSubaccountId
	}
	return nil
}

func (m *TransferEventV1) GetRecipientSubaccountId() *types.IndexerSubaccountId {
	if m != nil {
		return m.RecipientSubaccountId
	}
	return nil
}

func (m *TransferEventV1) GetAssetId() uint32 {
	if m != nil {
		return m.AssetId
	}
	return 0
}

func (m *TransferEventV1) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *TransferEventV1) GetSender() *SourceOfFunds {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *TransferEventV1) GetRecipient() *SourceOfFunds {
	if m != nil {
		return m.Recipient
	}
	return nil
}

// OrderFillEvent message contains all the information from an order match in
// the dYdX chain. This includes the maker/taker orders that matched and the
// amount filled.
type OrderFillEventV1 struct {
	MakerOrder types.IndexerOrder `protobuf:"bytes,1,opt,name=maker_order,json=makerOrder,proto3" json:"maker_order"`
	// The type of order fill this event represents.
	//
	// Types that are valid to be assigned to TakerOrder:
	//
	//	*OrderFillEventV1_Order
	//	*OrderFillEventV1_LiquidationOrder
	TakerOrder isOrderFillEventV1_TakerOrder `protobuf_oneof:"taker_order"`
	// Fill amount in base quantums.
	FillAmount uint64 `protobuf:"varint,3,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty"`
	// Maker fee in USDC quantums.
	MakerFee int64 `protobuf:"zigzag64,5,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Taker fee in USDC quantums. If the taker order is a liquidation, then this
	// represents the special liquidation fee, not the standard taker fee.
	TakerFee int64 `protobuf:"zigzag64,6,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// Total filled of the maker order in base quantums.
	TotalFilledMaker uint64 `protobuf:"varint,7,opt,name=total_filled_maker,json=totalFilledMaker,proto3" json:"total_filled_maker,omitempty"`
	// Total filled of the taker order in base quantums.
	TotalFilledTaker uint64 `protobuf:"varint,8,opt,name=total_filled_taker,json=totalFilledTaker,proto3" json:"total_filled_taker,omitempty"`
	// rev share for affiliates in USDC quantums.
	AffiliateRevShare uint64 `protobuf:"varint,9,opt,name=affiliate_rev_share,json=affiliateRevShare,proto3" json:"affiliate_rev_share,omitempty"`
	// fee for maker builder in USDC quantums.
	MakerBuilderFee uint64 `protobuf:"varint,10,opt,name=maker_builder_fee,json=makerBuilderFee,proto3" json:"maker_builder_fee,omitempty"`
	// fee for taker builder in USDC quantums.
	TakerBuilderFee uint64 `protobuf:"varint,11,opt,name=taker_builder_fee,json=takerBuilderFee,proto3" json:"taker_builder_fee,omitempty"`
	// builder address for maker
	MakerBuilderAddress string `protobuf:"bytes,12,opt,name=maker_builder_address,json=makerBuilderAddress,proto3" json:"maker_builder_address,omitempty"`
	// builder address for taker
	TakerBuilderAddress string `protobuf:"bytes,13,opt,name=taker_builder_address,json=takerBuilderAddress,proto3" json:"taker_builder_address,omitempty"`
	// fee for maker order router in USDC quantums
	MakerOrderRouterFee uint64 `protobuf:"varint,14,opt,name=maker_order_router_fee,json=makerOrderRouterFee,proto3" json:"maker_order_router_fee,omitempty"`
	// fee for taker order router in USDC quantums
	TakerOrderRouterFee uint64 `protobuf:"varint,15,opt,name=taker_order_router_fee,json=takerOrderRouterFee,proto3" json:"taker_order_router_fee,omitempty"`
	// order router address for maker
	MakerOrderRouterAddress string `protobuf:"bytes,16,opt,name=maker_order_router_address,json=makerOrderRouterAddress,proto3" json:"maker_order_router_address,omitempty"`
	// order router address for taker
	TakerOrderRouterAddress string `protobuf:"bytes,17,opt,name=taker_order_router_address,json=takerOrderRouterAddress,proto3" json:"taker_order_router_address,omitempty"`
}

func (m *OrderFillEventV1) Reset()         { *m = OrderFillEventV1{} }
func (m *OrderFillEventV1) String() string { return proto.CompactTextString(m) }
func (*OrderFillEventV1) ProtoMessage()    {}
func (*OrderFillEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{9}
}
func (m *OrderFillEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFillEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFillEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFillEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFillEventV1.Merge(m, src)
}
func (m *OrderFillEventV1) XXX_Size() int {
	return m.Size()
}
func (m *OrderFillEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFillEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFillEventV1 proto.InternalMessageInfo

type isOrderFillEventV1_TakerOrder interface {
	isOrderFillEventV1_TakerOrder()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OrderFillEventV1_Order struct {
	Order *types.IndexerOrder `protobuf:"bytes,2,opt,name=order,proto3,oneof" json:"order,omitempty"`
}
type OrderFillEventV1_LiquidationOrder struct {
	LiquidationOrder *LiquidationOrderV1 `protobuf:"bytes,4,opt,name=liquidation_order,json=liquidationOrder,proto3,oneof" json:"liquidation_order,omitempty"`
}

func (*OrderFillEventV1_Order) isOrderFillEventV1_TakerOrder()            {}
func (*OrderFillEventV1_LiquidationOrder) isOrderFillEventV1_TakerOrder() {}

func (m *OrderFillEventV1) GetTakerOrder() isOrderFillEventV1_TakerOrder {
	if m != nil {
		return m.TakerOrder
	}
	return nil
}

func (m *OrderFillEventV1) GetMakerOrder() types.IndexerOrder {
	if m != nil {
		return m.MakerOrder
	}
	return types.IndexerOrder{}
}

func (m *OrderFillEventV1) GetOrder() *types.IndexerOrder {
	if x, ok := m.GetTakerOrder().(*OrderFillEventV1_Order); ok {
		return x.Order
	}
	return nil
}

func (m *OrderFillEventV1) GetLiquidationOrder() *LiquidationOrderV1 {
	if x, ok := m.GetTakerOrder().(*OrderFillEventV1_LiquidationOrder); ok {
		return x.LiquidationOrder
	}
	return nil
}

func (m *OrderFillEventV1) GetFillAmount() uint64 {
	if m != nil {
		return m.FillAmount
	}
	return 0
}

func (m *OrderFillEventV1) GetMakerFee() int64 {
	if m != nil {
		return m.MakerFee
	}
	return 0
}

func (m *OrderFillEventV1) GetTakerFee() int64 {
	if m != nil {
		return m.TakerFee
	}
	return 0
}

func (m *OrderFillEventV1) GetTotalFilledMaker() uint64 {
	if m != nil {
		return m.TotalFilledMaker
	}
	return 0
}

func (m *OrderFillEventV1) GetTotalFilledTaker() uint64 {
	if m != nil {
		return m.TotalFilledTaker
	}
	return 0
}

func (m *OrderFillEventV1) GetAffiliateRevShare() uint64 {
	if m != nil {
		return m.AffiliateRevShare
	}
	return 0
}

func (m *OrderFillEventV1) GetMakerBuilderFee() uint64 {
	if m != nil {
		return m.MakerBuilderFee
	}
	return 0
}

func (m *OrderFillEventV1) GetTakerBuilderFee() uint64 {
	if m != nil {
		return m.TakerBuilderFee
	}
	return 0
}

func (m *OrderFillEventV1) GetMakerBuilderAddress() string {
	if m != nil {
		return m.MakerBuilderAddress
	}
	return ""
}

func (m *OrderFillEventV1) GetTakerBuilderAddress() string {
	if m != nil {
		return m.TakerBuilderAddress
	}
	return ""
}

func (m *OrderFillEventV1) GetMakerOrderRouterFee() uint64 {
	if m != nil {
		return m.MakerOrderRouterFee
	}
	return 0
}

func (m *OrderFillEventV1) GetTakerOrderRouterFee() uint64 {
	if m != nil {
		return m.TakerOrderRouterFee
	}
	return 0
}

func (m *OrderFillEventV1) GetMakerOrderRouterAddress() string {
	if m != nil {
		return m.MakerOrderRouterAddress
	}
	return ""
}

func (m *OrderFillEventV1) GetTakerOrderRouterAddress() string {
	if m != nil {
		return m.TakerOrderRouterAddress
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrderFillEventV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrderFillEventV1_Order)(nil),
		(*OrderFillEventV1_LiquidationOrder)(nil),
	}
}

// DeleveragingEvent message contains all the information for a deleveraging
// on the dYdX chain. This includes the liquidated/offsetting subaccounts and
// the amount filled.
type DeleveragingEventV1 struct {
	// ID of the subaccount that was liquidated.
	Liquidated types.IndexerSubaccountId `protobuf:"bytes,1,opt,name=liquidated,proto3" json:"liquidated"`
	// ID of the subaccount that was used to offset the position.
	Offsetting types.IndexerSubaccountId `protobuf:"bytes,2,opt,name=offsetting,proto3" json:"offsetting"`
	// The ID of the perpetual that was liquidated.
	PerpetualId uint32 `protobuf:"varint,3,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// The amount filled between the liquidated and offsetting position, in
	// base quantums.
	FillAmount uint64 `protobuf:"varint,4,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty"`
	// Total quote quantums filled.
	TotalQuoteQuantums uint64 `protobuf:"varint,5,opt,name=total_quote_quantums,json=totalQuoteQuantums,proto3" json:"total_quote_quantums,omitempty"`
	// `true` if liquidating a short position, `false` otherwise.
	IsBuy bool `protobuf:"varint,6,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	// `true` if the deleveraging event is for final settlement, indicating
	// the match occurred at the oracle price rather than bankruptcy price.
	// When this flag is `false`, the fill price is the bankruptcy price
	// of the liquidated subaccount.
	IsFinalSettlement bool `protobuf:"varint,7,opt,name=is_final_settlement,json=isFinalSettlement,proto3" json:"is_final_settlement,omitempty"`
}

func (m *DeleveragingEventV1) Reset()         { *m = DeleveragingEventV1{} }
func (m *DeleveragingEventV1) String() string { return proto.CompactTextString(m) }
func (*DeleveragingEventV1) ProtoMessage()    {}
func (*DeleveragingEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{10}
}
func (m *DeleveragingEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleveragingEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleveragingEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleveragingEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleveragingEventV1.Merge(m, src)
}
func (m *DeleveragingEventV1) XXX_Size() int {
	return m.Size()
}
func (m *DeleveragingEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleveragingEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_DeleveragingEventV1 proto.InternalMessageInfo

func (m *DeleveragingEventV1) GetLiquidated() types.IndexerSubaccountId {
	if m != nil {
		return m.Liquidated
	}
	return types.IndexerSubaccountId{}
}

func (m *DeleveragingEventV1) GetOffsetting() types.IndexerSubaccountId {
	if m != nil {
		return m.Offsetting
	}
	return types.IndexerSubaccountId{}
}

func (m *DeleveragingEventV1) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *DeleveragingEventV1) GetFillAmount() uint64 {
	if m != nil {
		return m.FillAmount
	}
	return 0
}

func (m *DeleveragingEventV1) GetTotalQuoteQuantums() uint64 {
	if m != nil {
		return m.TotalQuoteQuantums
	}
	return 0
}

func (m *DeleveragingEventV1) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *DeleveragingEventV1) GetIsFinalSettlement() bool {
	if m != nil {
		return m.IsFinalSettlement
	}
	return false
}

// LiquidationOrder represents the liquidation taker order to be included in a
// liquidation order fill event.
type LiquidationOrderV1 struct {
	// ID of the subaccount that was liquidated.
	Liquidated types.IndexerSubaccountId `protobuf:"bytes,1,opt,name=liquidated,proto3" json:"liquidated"`
	// The ID of the clob pair involved in the liquidation.
	ClobPairId uint32 `protobuf:"varint,2,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// The ID of the perpetual involved in the liquidation.
	PerpetualId uint32 `protobuf:"varint,3,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// The total size of the liquidation order including any unfilled size,
	// in base quantums.
	TotalSize uint64 `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	// `true` if liquidating a short position, `false` otherwise.
	IsBuy bool `protobuf:"varint,5,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	// The fillable price in subticks.
	// This represents the lower-price-bound for liquidating longs
	// and the upper-price-bound for liquidating shorts.
	// Must be a multiple of ClobPair.SubticksPerTick
	// (where `ClobPair.Id = orderId.ClobPairId`).
	Subticks uint64 `protobuf:"varint,6,opt,name=subticks,proto3" json:"subticks,omitempty"`
}

func (m *LiquidationOrderV1) Reset()         { *m = LiquidationOrderV1{} }
func (m *LiquidationOrderV1) String() string { return proto.CompactTextString(m) }
func (*LiquidationOrderV1) ProtoMessage()    {}
func (*LiquidationOrderV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11}
}
func (m *LiquidationOrderV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidationOrderV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidationOrderV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidationOrderV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidationOrderV1.Merge(m, src)
}
func (m *LiquidationOrderV1) XXX_Size() int {
	return m.Size()
}
func (m *LiquidationOrderV1) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidationOrderV1.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidationOrderV1 proto.InternalMessageInfo

func (m *LiquidationOrderV1) GetLiquidated() types.IndexerSubaccountId {
	if m != nil {
		return m.Liquidated
	}
	return types.IndexerSubaccountId{}
}

func (m *LiquidationOrderV1) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *LiquidationOrderV1) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *LiquidationOrderV1) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *LiquidationOrderV1) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *LiquidationOrderV1) GetSubticks() uint64 {
	if m != nil {
		return m.Subticks
	}
	return 0
}

// SubaccountUpdateEvent message contains information about an update to a
// subaccount in the dYdX chain. This includes the list of updated perpetual
// and asset positions for the subaccount.
// Note: This event message will contain all the updates to a subaccount
// at the end of a block which is why multiple asset/perpetual position
// updates may exist.
type SubaccountUpdateEventV1 struct {
	SubaccountId *types.IndexerSubaccountId `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// updated_perpetual_positions will each be for unique perpetuals.
	UpdatedPerpetualPositions []*types.IndexerPerpetualPosition `protobuf:"bytes,3,rep,name=updated_perpetual_positions,json=updatedPerpetualPositions,proto3" json:"updated_perpetual_positions,omitempty"`
	// updated_asset_positions will each be for unique assets.
	UpdatedAssetPositions []*types.IndexerAssetPosition `protobuf:"bytes,4,rep,name=updated_asset_positions,json=updatedAssetPositions,proto3" json:"updated_asset_positions,omitempty"`
}

func (m *SubaccountUpdateEventV1) Reset()         { *m = SubaccountUpdateEventV1{} }
func (m *SubaccountUpdateEventV1) String() string { return proto.CompactTextString(m) }
func (*SubaccountUpdateEventV1) ProtoMessage()    {}
func (*SubaccountUpdateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{12}
}
func (m *SubaccountUpdateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountUpdateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountUpdateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountUpdateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountUpdateEventV1.Merge(m, src)
}
func (m *SubaccountUpdateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountUpdateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountUpdateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountUpdateEventV1 proto.InternalMessageInfo

func (m *SubaccountUpdateEventV1) GetSubaccountId() *types.IndexerSubaccountId {
	if m != nil {
		return m.SubaccountId
	}
	return nil
}

func (m *SubaccountUpdateEventV1) GetUpdatedPerpetualPositions() []*types.IndexerPerpetualPosition {
	if m != nil {
		return m.UpdatedPerpetualPositions
	}
	return nil
}

func (m *SubaccountUpdateEventV1) GetUpdatedAssetPositions() []*types.IndexerAssetPosition {
	if m != nil {
		return m.UpdatedAssetPositions
	}
	return nil
}

// StatefulOrderEvent message contains information about a change to a stateful
// order. Currently, this is either the placement of a long-term order, the
// placement or triggering of a conditional order, or the removal of a
// stateful order.
type StatefulOrderEventV1 struct {
	// The type of event that this StatefulOrderEvent contains.
	//
	// Types that are valid to be assigned to Event:
	//
	//	*StatefulOrderEventV1_OrderPlace
	//	*StatefulOrderEventV1_OrderRemoval
	//	*StatefulOrderEventV1_ConditionalOrderPlacement
	//	*StatefulOrderEventV1_ConditionalOrderTriggered
	//	*StatefulOrderEventV1_LongTermOrderPlacement
	//	*StatefulOrderEventV1_OrderReplacement
	//	*StatefulOrderEventV1_TwapOrderPlacement
	Event isStatefulOrderEventV1_Event `protobuf_oneof:"event"`
}

func (m *StatefulOrderEventV1) Reset()         { *m = StatefulOrderEventV1{} }
func (m *StatefulOrderEventV1) String() string { return proto.CompactTextString(m) }
func (*StatefulOrderEventV1) ProtoMessage()    {}
func (*StatefulOrderEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{13}
}
func (m *StatefulOrderEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1.Merge(m, src)
}
func (m *StatefulOrderEventV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1 proto.InternalMessageInfo

type isStatefulOrderEventV1_Event interface {
	isStatefulOrderEventV1_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StatefulOrderEventV1_OrderPlace struct {
	OrderPlace *StatefulOrderEventV1_StatefulOrderPlacementV1 `protobuf:"bytes,1,opt,name=order_place,json=orderPlace,proto3,oneof" json:"order_place,omitempty"`
}
type StatefulOrderEventV1_OrderRemoval struct {
	OrderRemoval *StatefulOrderEventV1_StatefulOrderRemovalV1 `protobuf:"bytes,4,opt,name=order_removal,json=orderRemoval,proto3,oneof" json:"order_removal,omitempty"`
}
type StatefulOrderEventV1_ConditionalOrderPlacement struct {
	ConditionalOrderPlacement *StatefulOrderEventV1_ConditionalOrderPlacementV1 `protobuf:"bytes,5,opt,name=conditional_order_placement,json=conditionalOrderPlacement,proto3,oneof" json:"conditional_order_placement,omitempty"`
}
type StatefulOrderEventV1_ConditionalOrderTriggered struct {
	ConditionalOrderTriggered *StatefulOrderEventV1_ConditionalOrderTriggeredV1 `protobuf:"bytes,6,opt,name=conditional_order_triggered,json=conditionalOrderTriggered,proto3,oneof" json:"conditional_order_triggered,omitempty"`
}
type StatefulOrderEventV1_LongTermOrderPlacement struct {
	LongTermOrderPlacement *StatefulOrderEventV1_LongTermOrderPlacementV1 `protobuf:"bytes,7,opt,name=long_term_order_placement,json=longTermOrderPlacement,proto3,oneof" json:"long_term_order_placement,omitempty"`
}
type StatefulOrderEventV1_OrderReplacement struct {
	OrderReplacement *StatefulOrderEventV1_LongTermOrderReplacementV1 `protobuf:"bytes,8,opt,name=order_replacement,json=orderReplacement,proto3,oneof" json:"order_replacement,omitempty"`
}
type StatefulOrderEventV1_TwapOrderPlacement struct {
	TwapOrderPlacement *StatefulOrderEventV1_TwapOrderPlacementV1 `protobuf:"bytes,9,opt,name=twap_order_placement,json=twapOrderPlacement,proto3,oneof" json:"twap_order_placement,omitempty"`
}

func (*StatefulOrderEventV1_OrderPlace) isStatefulOrderEventV1_Event()                {}
func (*StatefulOrderEventV1_OrderRemoval) isStatefulOrderEventV1_Event()              {}
func (*StatefulOrderEventV1_ConditionalOrderPlacement) isStatefulOrderEventV1_Event() {}
func (*StatefulOrderEventV1_ConditionalOrderTriggered) isStatefulOrderEventV1_Event() {}
func (*StatefulOrderEventV1_LongTermOrderPlacement) isStatefulOrderEventV1_Event()    {}
func (*StatefulOrderEventV1_OrderReplacement) isStatefulOrderEventV1_Event()          {}
func (*StatefulOrderEventV1_TwapOrderPlacement) isStatefulOrderEventV1_Event()        {}

func (m *StatefulOrderEventV1) GetEvent() isStatefulOrderEventV1_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

// Deprecated: Do not use.
func (m *StatefulOrderEventV1) GetOrderPlace() *StatefulOrderEventV1_StatefulOrderPlacementV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_OrderPlace); ok {
		return x.OrderPlace
	}
	return nil
}

func (m *StatefulOrderEventV1) GetOrderRemoval() *StatefulOrderEventV1_StatefulOrderRemovalV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

func (m *StatefulOrderEventV1) GetConditionalOrderPlacement() *StatefulOrderEventV1_ConditionalOrderPlacementV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_ConditionalOrderPlacement); ok {
		return x.ConditionalOrderPlacement
	}
	return nil
}

func (m *StatefulOrderEventV1) GetConditionalOrderTriggered() *StatefulOrderEventV1_ConditionalOrderTriggeredV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_ConditionalOrderTriggered); ok {
		return x.ConditionalOrderTriggered
	}
	return nil
}

func (m *StatefulOrderEventV1) GetLongTermOrderPlacement() *StatefulOrderEventV1_LongTermOrderPlacementV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_LongTermOrderPlacement); ok {
		return x.LongTermOrderPlacement
	}
	return nil
}

func (m *StatefulOrderEventV1) GetOrderReplacement() *StatefulOrderEventV1_LongTermOrderReplacementV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_OrderReplacement); ok {
		return x.OrderReplacement
	}
	return nil
}

func (m *StatefulOrderEventV1) GetTwapOrderPlacement() *StatefulOrderEventV1_TwapOrderPlacementV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_TwapOrderPlacement); ok {
		return x.TwapOrderPlacement
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StatefulOrderEventV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StatefulOrderEventV1_OrderPlace)(nil),
		(*StatefulOrderEventV1_OrderRemoval)(nil),
		(*StatefulOrderEventV1_ConditionalOrderPlacement)(nil),
		(*StatefulOrderEventV1_ConditionalOrderTriggered)(nil),
		(*StatefulOrderEventV1_LongTermOrderPlacement)(nil),
		(*StatefulOrderEventV1_OrderReplacement)(nil),
		(*StatefulOrderEventV1_TwapOrderPlacement)(nil),
	}
}

// A stateful order placement contains an order.
// Deprecated in favor of LongTermOrderPlacementV1.
type StatefulOrderEventV1_StatefulOrderPlacementV1 struct {
	Order *types.IndexerOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) Reset() {
	*m = StatefulOrderEventV1_StatefulOrderPlacementV1{}
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_StatefulOrderPlacementV1) ProtoMessage() {}
func (*StatefulOrderEventV1_StatefulOrderPlacementV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{13, 0}
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_StatefulOrderPlacementV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderPlacementV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderPlacementV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_StatefulOrderPlacementV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) GetOrder() *types.IndexerOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

// A stateful order removal contains the id of an order that was already
// placed and is now removed and the reason for the removal.
type StatefulOrderEventV1_StatefulOrderRemovalV1 struct {
	RemovedOrderId *types.IndexerOrderId     `protobuf:"bytes,1,opt,name=removed_order_id,json=removedOrderId,proto3" json:"removed_order_id,omitempty"`
	Reason         types1.OrderRemovalReason `protobuf:"varint,2,opt,name=reason,proto3,enum=dydxprotocol.indexer.shared.OrderRemovalReason" json:"reason,omitempty"`
}

func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) Reset() {
	*m = StatefulOrderEventV1_StatefulOrderRemovalV1{}
}
func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_StatefulOrderRemovalV1) ProtoMessage() {}
func (*StatefulOrderEventV1_StatefulOrderRemovalV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{13, 1}
}
func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_StatefulOrderRemovalV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderRemovalV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderRemovalV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_StatefulOrderRemovalV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) GetRemovedOrderId() *types.IndexerOrderId {
	if m != nil {
		return m.RemovedOrderId
	}
	return nil
}

func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) GetReason() types1.OrderRemovalReason {
	if m != nil {
		return m.Reason
	}
	return types1.OrderRemovalReason_ORDER_REMOVAL_REASON_UNSPECIFIED
}

// A conditional order placement contains an order. The order is newly-placed
// and untriggered when this event is emitted.
type StatefulOrderEventV1_ConditionalOrderPlacementV1 struct {
	Order *types.IndexerOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) Reset() {
	*m = StatefulOrderEventV1_ConditionalOrderPlacementV1{}
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_ConditionalOrderPlacementV1) ProtoMessage() {}
func (*StatefulOrderEventV1_ConditionalOrderPlacementV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{13, 2}
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_ConditionalOrderPlacementV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_ConditionalOrderPlacementV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_ConditionalOrderPlacementV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_ConditionalOrderPlacementV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) GetOrder() *types.IndexerOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

// A conditional order trigger event contains an order id and is emitted when
// an order is triggered.
type StatefulOrderEventV1_ConditionalOrderTriggeredV1 struct {
	TriggeredOrderId *types.IndexerOrderId `protobuf:"bytes,1,opt,name=triggered_order_id,json=triggeredOrderId,proto3" json:"triggered_order_id,omitempty"`
}

func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) Reset() {
	*m = StatefulOrderEventV1_ConditionalOrderTriggeredV1{}
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_ConditionalOrderTriggeredV1) ProtoMessage() {}
func (*StatefulOrderEventV1_ConditionalOrderTriggeredV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{13, 3}
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_ConditionalOrderTriggeredV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_ConditionalOrderTriggeredV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_ConditionalOrderTriggeredV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_ConditionalOrderTriggeredV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) GetTriggeredOrderId() *types.IndexerOrderId {
	if m != nil {
		return m.TriggeredOrderId
	}
	return nil
}

// A long term order placement contains an order.
type StatefulOrderEventV1_LongTermOrderPlacementV1 struct {
	Order *types.IndexerOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) Reset() {
	*m = StatefulOrderEventV1_LongTermOrderPlacementV1{}
}
func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_LongTermOrderPlacementV1) ProtoMessage() {}
func (*StatefulOrderEventV1_LongTermOrderPlacementV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{13, 4}
}
func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_LongTermOrderPlacementV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_LongTermOrderPlacementV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_LongTermOrderPlacementV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_LongTermOrderPlacementV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) GetOrder() *types.IndexerOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

// A long term order replacement contains an old order ID and the new order.
type StatefulOrderEventV1_LongTermOrderReplacementV1 struct {
	OldOrderId *types.IndexerOrderId `protobuf:"bytes,1,opt,name=old_order_id,json=oldOrderId,proto3" json:"old_order_id,omitempty"`
	Order      *types.IndexerOrder   `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) Reset() {
	*m = StatefulOrderEventV1_LongTermOrderReplacementV1{}
}
func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_LongTermOrderReplacementV1) ProtoMessage() {}
func (*StatefulOrderEventV1_LongTermOrderReplacementV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{13, 5}
}
func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_LongTermOrderReplacementV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_LongTermOrderReplacementV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_LongTermOrderReplacementV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_LongTermOrderReplacementV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) GetOldOrderId() *types.IndexerOrderId {
	if m != nil {
		return m.OldOrderId
	}
	return nil
}

func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) GetOrder() *types.IndexerOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

// A twap order placement contains an order.
type StatefulOrderEventV1_TwapOrderPlacementV1 struct {
	Order *types.IndexerOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *StatefulOrderEventV1_TwapOrderPlacementV1) Reset() {
	*m = StatefulOrderEventV1_TwapOrderPlacementV1{}
}
func (m *StatefulOrderEventV1_TwapOrderPlacementV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_TwapOrderPlacementV1) ProtoMessage() {}
func (*StatefulOrderEventV1_TwapOrderPlacementV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{13, 6}
}
func (m *StatefulOrderEventV1_TwapOrderPlacementV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_TwapOrderPlacementV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_TwapOrderPlacementV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_TwapOrderPlacementV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_TwapOrderPlacementV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_TwapOrderPlacementV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_TwapOrderPlacementV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_TwapOrderPlacementV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_TwapOrderPlacementV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_TwapOrderPlacementV1) GetOrder() *types.IndexerOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

// AssetCreateEventV1 message contains all the information about an new Asset on
// the dYdX chain.
type AssetCreateEventV1 struct {
	// Unique, sequentially-generated.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The human readable symbol of the `Asset` (e.g. `USDC`, `ATOM`).
	// Must be uppercase, unique and correspond to the canonical symbol of the
	// full coin.
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// `true` if this `Asset` has a valid `MarketId` value.
	HasMarket bool `protobuf:"varint,3,opt,name=has_market,json=hasMarket,proto3" json:"has_market,omitempty"`
	// The `Id` of the `Market` associated with this `Asset`. It acts as the
	// oracle price for the purposes of calculating collateral
	// and margin requirements.
	MarketId uint32 `protobuf:"varint,4,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The exponent for converting an atomic amount (1 'quantum')
	// to a full coin. For example, if `atomic_resolution = -8`
	// then an `asset_position` with `base_quantums = 1e8` is equivalent to
	// a position size of one full coin.
	AtomicResolution int32 `protobuf:"zigzag32,5,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
}

func (m *AssetCreateEventV1) Reset()         { *m = AssetCreateEventV1{} }
func (m *AssetCreateEventV1) String() string { return proto.CompactTextString(m) }
func (*AssetCreateEventV1) ProtoMessage()    {}
func (*AssetCreateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{14}
}
func (m *AssetCreateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetCreateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetCreateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetCreateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetCreateEventV1.Merge(m, src)
}
func (m *AssetCreateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *AssetCreateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetCreateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_AssetCreateEventV1 proto.InternalMessageInfo

func (m *AssetCreateEventV1) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AssetCreateEventV1) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *AssetCreateEventV1) GetHasMarket() bool {
	if m != nil {
		return m.HasMarket
	}
	return false
}

func (m *AssetCreateEventV1) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *AssetCreateEventV1) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

// PerpetualMarketCreateEventV1 message contains all the information about a
// new Perpetual Market on the dYdX chain.
// Deprecated. See PerpetualMarketCreateEventV2 for the most up to date message
// for the event to create a new Perpetual Market.
//
// Deprecated: Do not use.
type PerpetualMarketCreateEventV1 struct {
	// Unique Perpetual id.
	// Defined in perpetuals.perpetual
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Unique clob pair Id associated with this perpetual market
	// Defined in clob.clob_pair
	ClobPairId uint32 `protobuf:"varint,2,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// The name of the `Perpetual` (e.g. `BTC-USD`).
	// Defined in perpetuals.perpetual
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Unique id of market param associated with this perpetual market.
	// Defined in perpetuals.perpetual
	MarketId uint32 `protobuf:"varint,4,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// Status of the CLOB
	Status types.ClobPairStatus `protobuf:"varint,5,opt,name=status,proto3,enum=dydxprotocol.indexer.protocol.v1.ClobPairStatus" json:"status,omitempty"`
	// `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
	// per Subtick.
	// Defined in clob.clob_pair
	QuantumConversionExponent int32 `protobuf:"zigzag32,6,opt,name=quantum_conversion_exponent,json=quantumConversionExponent,proto3" json:"quantum_conversion_exponent,omitempty"`
	// The exponent for converting an atomic amount (`size = 1`)
	// to a full coin. For example, if `AtomicResolution = -8`
	// then a `PerpetualPosition` with `size = 1e8` is equivalent to
	// a position size of one full coin.
	// Defined in perpetuals.perpetual
	AtomicResolution int32 `protobuf:"zigzag32,7,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
	// Defines the tick size of the orderbook by defining how many subticks
	// are in one tick. That is, the subticks of any valid order must be a
	// multiple of this value. Generally this value should start `>= 100`to
	// allow room for decreasing it.
	// Defined in clob.clob_pair
	SubticksPerTick uint32 `protobuf:"varint,8,opt,name=subticks_per_tick,json=subticksPerTick,proto3" json:"subticks_per_tick,omitempty"`
	// Minimum increment in the size of orders on the CLOB, in base quantums.
	// Defined in clob.clob_pair
	StepBaseQuantums uint64 `protobuf:"varint,9,opt,name=step_base_quantums,json=stepBaseQuantums,proto3" json:"step_base_quantums,omitempty"`
	// The liquidity_tier that this perpetual is associated with.
	// Defined in perpetuals.perpetual
	LiquidityTier uint32 `protobuf:"varint,10,opt,name=liquidity_tier,json=liquidityTier,proto3" json:"liquidity_tier,omitempty"`
}

func (m *PerpetualMarketCreateEventV1) Reset()         { *m = PerpetualMarketCreateEventV1{} }
func (m *PerpetualMarketCreateEventV1) String() string { return proto.CompactTextString(m) }
func (*PerpetualMarketCreateEventV1) ProtoMessage()    {}
func (*PerpetualMarketCreateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{15}
}
func (m *PerpetualMarketCreateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerpetualMarketCreateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerpetualMarketCreateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerpetualMarketCreateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerpetualMarketCreateEventV1.Merge(m, src)
}
func (m *PerpetualMarketCreateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *PerpetualMarketCreateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PerpetualMarketCreateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_PerpetualMarketCreateEventV1 proto.InternalMessageInfo

func (m *PerpetualMarketCreateEventV1) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PerpetualMarketCreateEventV1) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *PerpetualMarketCreateEventV1) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *PerpetualMarketCreateEventV1) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *PerpetualMarketCreateEventV1) GetStatus() types.ClobPairStatus {
	if m != nil {
		return m.Status
	}
	return types.ClobPairStatus_CLOB_PAIR_STATUS_UNSPECIFIED
}

func (m *PerpetualMarketCreateEventV1) GetQuantumConversionExponent() int32 {
	if m != nil {
		return m.QuantumConversionExponent
	}
	return 0
}

func (m *PerpetualMarketCreateEventV1) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

func (m *PerpetualMarketCreateEventV1) GetSubticksPerTick() uint32 {
	if m != nil {
		return m.SubticksPerTick
	}
	return 0
}

func (m *PerpetualMarketCreateEventV1) GetStepBaseQuantums() uint64 {
	if m != nil {
		return m.StepBaseQuantums
	}
	return 0
}

func (m *PerpetualMarketCreateEventV1) GetLiquidityTier() uint32 {
	if m != nil {
		return m.LiquidityTier
	}
	return 0
}

// PerpetualMarketCreateEventV2 message contains all the information about a
// new Perpetual Market on the dYdX chain.
// Deprecated. Use PerpetualMarketCreateEventV3 for the most up to date message
//
// Deprecated: Do not use.
type PerpetualMarketCreateEventV2 struct {
	// Unique Perpetual id.
	// Defined in perpetuals.perpetual
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Unique clob pair Id associated with this perpetual market
	// Defined in clob.clob_pair
	ClobPairId uint32 `protobuf:"varint,2,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// The name of the `Perpetual` (e.g. `BTC-USD`).
	// Defined in perpetuals.perpetual
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Unique id of market param associated with this perpetual market.
	// Defined in perpetuals.perpetual
	MarketId uint32 `protobuf:"varint,4,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// Status of the CLOB
	Status types.ClobPairStatus `protobuf:"varint,5,opt,name=status,proto3,enum=dydxprotocol.indexer.protocol.v1.ClobPairStatus" json:"status,omitempty"`
	// `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
	// per Subtick.
	// Defined in clob.clob_pair
	QuantumConversionExponent int32 `protobuf:"zigzag32,6,opt,name=quantum_conversion_exponent,json=quantumConversionExponent,proto3" json:"quantum_conversion_exponent,omitempty"`
	// The exponent for converting an atomic amount (`size = 1`)
	// to a full coin. For example, if `AtomicResolution = -8`
	// then a `PerpetualPosition` with `size = 1e8` is equivalent to
	// a position size of one full coin.
	// Defined in perpetuals.perpetual
	AtomicResolution int32 `protobuf:"zigzag32,7,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
	// Defines the tick size of the orderbook by defining how many subticks
	// are in one tick. That is, the subticks of any valid order must be a
	// multiple of this value. Generally this value should start `>= 100`to
	// allow room for decreasing it.
	// Defined in clob.clob_pair
	SubticksPerTick uint32 `protobuf:"varint,8,opt,name=subticks_per_tick,json=subticksPerTick,proto3" json:"subticks_per_tick,omitempty"`
	// Minimum increment in the size of orders on the CLOB, in base quantums.
	// Defined in clob.clob_pair
	StepBaseQuantums uint64 `protobuf:"varint,9,opt,name=step_base_quantums,json=stepBaseQuantums,proto3" json:"step_base_quantums,omitempty"`
	// The liquidity_tier that this perpetual is associated with.
	// Defined in perpetuals.perpetual
	LiquidityTier uint32 `protobuf:"varint,10,opt,name=liquidity_tier,json=liquidityTier,proto3" json:"liquidity_tier,omitempty"`
	// Market type of the perpetual.
	MarketType types.PerpetualMarketType `protobuf:"varint,11,opt,name=market_type,json=marketType,proto3,enum=dydxprotocol.indexer.protocol.v1.PerpetualMarketType" json:"market_type,omitempty"`
}

func (m *PerpetualMarketCreateEventV2) Reset()         { *m = PerpetualMarketCreateEventV2{} }
func (m *PerpetualMarketCreateEventV2) String() string { return proto.CompactTextString(m) }
func (*PerpetualMarketCreateEventV2) ProtoMessage()    {}
func (*PerpetualMarketCreateEventV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{16}
}
func (m *PerpetualMarketCreateEventV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerpetualMarketCreateEventV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerpetualMarketCreateEventV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerpetualMarketCreateEventV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerpetualMarketCreateEventV2.Merge(m, src)
}
func (m *PerpetualMarketCreateEventV2) XXX_Size() int {
	return m.Size()
}
func (m *PerpetualMarketCreateEventV2) XXX_DiscardUnknown() {
	xxx_messageInfo_PerpetualMarketCreateEventV2.DiscardUnknown(m)
}

var xxx_messageInfo_PerpetualMarketCreateEventV2 proto.InternalMessageInfo

func (m *PerpetualMarketCreateEventV2) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PerpetualMarketCreateEventV2) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *PerpetualMarketCreateEventV2) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *PerpetualMarketCreateEventV2) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *PerpetualMarketCreateEventV2) GetStatus() types.ClobPairStatus {
	if m != nil {
		return m.Status
	}
	return types.ClobPairStatus_CLOB_PAIR_STATUS_UNSPECIFIED
}

func (m *PerpetualMarketCreateEventV2) GetQuantumConversionExponent() int32 {
	if m != nil {
		return m.QuantumConversionExponent
	}
	return 0
}

func (m *PerpetualMarketCreateEventV2) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

func (m *PerpetualMarketCreateEventV2) GetSubticksPerTick() uint32 {
	if m != nil {
		return m.SubticksPerTick
	}
	return 0
}

func (m *PerpetualMarketCreateEventV2) GetStepBaseQuantums() uint64 {
	if m != nil {
		return m.StepBaseQuantums
	}
	return 0
}

func (m *PerpetualMarketCreateEventV2) GetLiquidityTier() uint32 {
	if m != nil {
		return m.LiquidityTier
	}
	return 0
}

func (m *PerpetualMarketCreateEventV2) GetMarketType() types.PerpetualMarketType {
	if m != nil {
		return m.MarketType
	}
	return types.PerpetualMarketType_PERPETUAL_MARKET_TYPE_UNSPECIFIED
}

// PerpetualMarketCreateEventV3 message contains all the information about a
// new Perpetual Market on the dYdX chain.
type PerpetualMarketCreateEventV3 struct {
	// Unique Perpetual id.
	// Defined in perpetuals.perpetual
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Unique clob pair Id associated with this perpetual market
	// Defined in clob.clob_pair
	ClobPairId uint32 `protobuf:"varint,2,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// The name of the `Perpetual` (e.g. `BTC-USD`).
	// Defined in perpetuals.perpetual
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Unique id of market param associated with this perpetual market.
	// Defined in perpetuals.perpetual
	MarketId uint32 `protobuf:"varint,4,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// Status of the CLOB
	Status types.ClobPairStatus `protobuf:"varint,5,opt,name=status,proto3,enum=dydxprotocol.indexer.protocol.v1.ClobPairStatus" json:"status,omitempty"`
	// `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
	// per Subtick.
	// Defined in clob.clob_pair
	QuantumConversionExponent int32 `protobuf:"zigzag32,6,opt,name=quantum_conversion_exponent,json=quantumConversionExponent,proto3" json:"quantum_conversion_exponent,omitempty"`
	// The exponent for converting an atomic amount (`size = 1`)
	// to a full coin. For example, if `AtomicResolution = -8`
	// then a `PerpetualPosition` with `size = 1e8` is equivalent to
	// a position size of one full coin.
	// Defined in perpetuals.perpetual
	AtomicResolution int32 `protobuf:"zigzag32,7,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
	// Defines the tick size of the orderbook by defining how many subticks
	// are in one tick. That is, the subticks of any valid order must be a
	// multiple of this value. Generally this value should start `>= 100`to
	// allow room for decreasing it.
	// Defined in clob.clob_pair
	SubticksPerTick uint32 `protobuf:"varint,8,opt,name=subticks_per_tick,json=subticksPerTick,proto3" json:"subticks_per_tick,omitempty"`
	// Minimum increment in the size of orders on the CLOB, in base quantums.
	// Defined in clob.clob_pair
	StepBaseQuantums uint64 `protobuf:"varint,9,opt,name=step_base_quantums,json=stepBaseQuantums,proto3" json:"step_base_quantums,omitempty"`
	// The liquidity_tier that this perpetual is associated with.
	// Defined in perpetuals.perpetual
	LiquidityTier uint32 `protobuf:"varint,10,opt,name=liquidity_tier,json=liquidityTier,proto3" json:"liquidity_tier,omitempty"`
	// Market type of the perpetual.
	MarketType types.PerpetualMarketType `protobuf:"varint,11,opt,name=market_type,json=marketType,proto3,enum=dydxprotocol.indexer.protocol.v1.PerpetualMarketType" json:"market_type,omitempty"`
	// Default 8hr funding rate in parts-per-million.
	DefaultFunding8HrPpm int32 `protobuf:"varint,12,opt,name=default_funding8hr_ppm,json=defaultFunding8hrPpm,proto3" json:"default_funding8hr_ppm,omitempty"`
}

func (m *PerpetualMarketCreateEventV3) Reset()         { *m = PerpetualMarketCreateEventV3{} }
func (m *PerpetualMarketCreateEventV3) String() string { return proto.CompactTextString(m) }
func (*PerpetualMarketCreateEventV3) ProtoMessage()    {}
func (*PerpetualMarketCreateEventV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{17}
}
func (m *PerpetualMarketCreateEventV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerpetualMarketCreateEventV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerpetualMarketCreateEventV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerpetualMarketCreateEventV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerpetualMarketCreateEventV3.Merge(m, src)
}
func (m *PerpetualMarketCreateEventV3) XXX_Size() int {
	return m.Size()
}
func (m *PerpetualMarketCreateEventV3) XXX_DiscardUnknown() {
	xxx_messageInfo_PerpetualMarketCreateEventV3.DiscardUnknown(m)
}

var xxx_messageInfo_PerpetualMarketCreateEventV3 proto.InternalMessageInfo

func (m *PerpetualMarketCreateEventV3) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PerpetualMarketCreateEventV3) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *PerpetualMarketCreateEventV3) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *PerpetualMarketCreateEventV3) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *PerpetualMarketCreateEventV3) GetStatus() types.ClobPairStatus {
	if m != nil {
		return m.Status
	}
	return types.ClobPairStatus_CLOB_PAIR_STATUS_UNSPECIFIED
}

func (m *PerpetualMarketCreateEventV3) GetQuantumConversionExponent() int32 {
	if m != nil {
		return m.QuantumConversionExponent
	}
	return 0
}

func (m *PerpetualMarketCreateEventV3) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

func (m *PerpetualMarketCreateEventV3) GetSubticksPerTick() uint32 {
	if m != nil {
		return m.SubticksPerTick
	}
	return 0
}

func (m *PerpetualMarketCreateEventV3) GetStepBaseQuantums() uint64 {
	if m != nil {
		return m.StepBaseQuantums
	}
	return 0
}

func (m *PerpetualMarketCreateEventV3) GetLiquidityTier() uint32 {
	if m != nil {
		return m.LiquidityTier
	}
	return 0
}

func (m *PerpetualMarketCreateEventV3) GetMarketType() types.PerpetualMarketType {
	if m != nil {
		return m.MarketType
	}
	return types.PerpetualMarketType_PERPETUAL_MARKET_TYPE_UNSPECIFIED
}

func (m *PerpetualMarketCreateEventV3) GetDefaultFunding8HrPpm() int32 {
	if m != nil {
		return m.DefaultFunding8HrPpm
	}
	return 0
}

// LiquidityTierUpsertEventV1 message contains all the information to
// create/update a Liquidity Tier on the dYdX chain.
type LiquidityTierUpsertEventV1 struct {
	// Unique id.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the tier purely for mnemonic purposes, e.g. "Gold".
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The margin fraction needed to open a position.
	// In parts-per-million.
	InitialMarginPpm uint32 `protobuf:"varint,3,opt,name=initial_margin_ppm,json=initialMarginPpm,proto3" json:"initial_margin_ppm,omitempty"`
	// The fraction of the initial-margin that the maintenance-margin is,
	// e.g. 50%. In parts-per-million.
	MaintenanceFractionPpm uint32 `protobuf:"varint,4,opt,name=maintenance_fraction_ppm,json=maintenanceFractionPpm,proto3" json:"maintenance_fraction_ppm,omitempty"`
	// The maximum position size at which the margin requirements are
	// not increased over the default values. Above this position size,
	// the margin requirements increase at a rate of sqrt(size).
	//
	// Deprecated since v3.x.
	BasePositionNotional uint64 `protobuf:"varint,5,opt,name=base_position_notional,json=basePositionNotional,proto3" json:"base_position_notional,omitempty"` // Deprecated: Do not use.
}

func (m *LiquidityTierUpsertEventV1) Reset()         { *m = LiquidityTierUpsertEventV1{} }
func (m *LiquidityTierUpsertEventV1) String() string { return proto.CompactTextString(m) }
func (*LiquidityTierUpsertEventV1) ProtoMessage()    {}
func (*LiquidityTierUpsertEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{18}
}
func (m *LiquidityTierUpsertEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityTierUpsertEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityTierUpsertEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityTierUpsertEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityTierUpsertEventV1.Merge(m, src)
}
func (m *LiquidityTierUpsertEventV1) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityTierUpsertEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityTierUpsertEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityTierUpsertEventV1 proto.InternalMessageInfo

func (m *LiquidityTierUpsertEventV1) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LiquidityTierUpsertEventV1) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LiquidityTierUpsertEventV1) GetInitialMarginPpm() uint32 {
	if m != nil {
		return m.InitialMarginPpm
	}
	return 0
}

func (m *LiquidityTierUpsertEventV1) GetMaintenanceFractionPpm() uint32 {
	if m != nil {
		return m.MaintenanceFractionPpm
	}
	return 0
}

// Deprecated: Do not use.
func (m *LiquidityTierUpsertEventV1) GetBasePositionNotional() uint64 {
	if m != nil {
		return m.BasePositionNotional
	}
	return 0
}

// UpdateClobPairEventV1 message contains all the information about an update to
// a clob pair on the dYdX chain.
type UpdateClobPairEventV1 struct {
	// Unique clob pair Id associated with this perpetual market
	// Defined in clob.clob_pair
	ClobPairId uint32 `protobuf:"varint,1,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// Status of the CLOB
	Status types.ClobPairStatus `protobuf:"varint,2,opt,name=status,proto3,enum=dydxprotocol.indexer.protocol.v1.ClobPairStatus" json:"status,omitempty"`
	// `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
	// per Subtick.
	// Defined in clob.clob_pair
	QuantumConversionExponent int32 `protobuf:"zigzag32,3,opt,name=quantum_conversion_exponent,json=quantumConversionExponent,proto3" json:"quantum_conversion_exponent,omitempty"`
	// Defines the tick size of the orderbook by defining how many subticks
	// are in one tick. That is, the subticks of any valid order must be a
	// multiple of this value. Generally this value should start `>= 100`to
	// allow room for decreasing it.
	// Defined in clob.clob_pair
	SubticksPerTick uint32 `protobuf:"varint,4,opt,name=subticks_per_tick,json=subticksPerTick,proto3" json:"subticks_per_tick,omitempty"`
	// Minimum increment in the size of orders on the CLOB, in base quantums.
	// Defined in clob.clob_pair
	StepBaseQuantums uint64 `protobuf:"varint,5,opt,name=step_base_quantums,json=stepBaseQuantums,proto3" json:"step_base_quantums,omitempty"`
}

func (m *UpdateClobPairEventV1) Reset()         { *m = UpdateClobPairEventV1{} }
func (m *UpdateClobPairEventV1) String() string { return proto.CompactTextString(m) }
func (*UpdateClobPairEventV1) ProtoMessage()    {}
func (*UpdateClobPairEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{19}
}
func (m *UpdateClobPairEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateClobPairEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateClobPairEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateClobPairEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateClobPairEventV1.Merge(m, src)
}
func (m *UpdateClobPairEventV1) XXX_Size() int {
	return m.Size()
}
func (m *UpdateClobPairEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateClobPairEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateClobPairEventV1 proto.InternalMessageInfo

func (m *UpdateClobPairEventV1) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *UpdateClobPairEventV1) GetStatus() types.ClobPairStatus {
	if m != nil {
		return m.Status
	}
	return types.ClobPairStatus_CLOB_PAIR_STATUS_UNSPECIFIED
}

func (m *UpdateClobPairEventV1) GetQuantumConversionExponent() int32 {
	if m != nil {
		return m.QuantumConversionExponent
	}
	return 0
}

func (m *UpdateClobPairEventV1) GetSubticksPerTick() uint32 {
	if m != nil {
		return m.SubticksPerTick
	}
	return 0
}

func (m *UpdateClobPairEventV1) GetStepBaseQuantums() uint64 {
	if m != nil {
		return m.StepBaseQuantums
	}
	return 0
}

// UpdatePerpetualEventV1 message contains all the information about an update
// to a perpetual on the dYdX chain.
// Deprecated. See UpdatePerpetualEventV2 for the most up to date message
// for the event to update a perpetual.
//
// Deprecated: Do not use.
type UpdatePerpetualEventV1 struct {
	// Unique Perpetual id.
	// Defined in perpetuals.perpetual
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the `Perpetual` (e.g. `BTC-USD`).
	// Defined in perpetuals.perpetual
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Unique id of market param associated with this perpetual market.
	// Defined in perpetuals.perpetual
	MarketId uint32 `protobuf:"varint,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The exponent for converting an atomic amount (`size = 1`)
	// to a full coin. For example, if `AtomicResolution = -8`
	// then a `PerpetualPosition` with `size = 1e8` is equivalent to
	// a position size of one full coin.
	// Defined in perpetuals.perpetual
	AtomicResolution int32 `protobuf:"zigzag32,4,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
	// The liquidity_tier that this perpetual is associated with.
	// Defined in perpetuals.perpetual
	LiquidityTier uint32 `protobuf:"varint,5,opt,name=liquidity_tier,json=liquidityTier,proto3" json:"liquidity_tier,omitempty"`
}

func (m *UpdatePerpetualEventV1) Reset()         { *m = UpdatePerpetualEventV1{} }
func (m *UpdatePerpetualEventV1) String() string { return proto.CompactTextString(m) }
func (*UpdatePerpetualEventV1) ProtoMessage()    {}
func (*UpdatePerpetualEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{20}
}
func (m *UpdatePerpetualEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePerpetualEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePerpetualEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePerpetualEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePerpetualEventV1.Merge(m, src)
}
func (m *UpdatePerpetualEventV1) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePerpetualEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePerpetualEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePerpetualEventV1 proto.InternalMessageInfo

func (m *UpdatePerpetualEventV1) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdatePerpetualEventV1) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *UpdatePerpetualEventV1) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *UpdatePerpetualEventV1) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

func (m *UpdatePerpetualEventV1) GetLiquidityTier() uint32 {
	if m != nil {
		return m.LiquidityTier
	}
	return 0
}

// UpdatePerpetualEventV2 message contains all the information about an update
// to a perpetual on the dYdX chain.
// Deprecated. Use UpdatePerpetualEventV3.
//
// Deprecated: Do not use.
type UpdatePerpetualEventV2 struct {
	// Unique Perpetual id.
	// Defined in perpetuals.perpetual
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the `Perpetual` (e.g. `BTC-USD`).
	// Defined in perpetuals.perpetual
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Unique id of market param associated with this perpetual market.
	// Defined in perpetuals.perpetual
	MarketId uint32 `protobuf:"varint,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The exponent for converting an atomic amount (`size = 1`)
	// to a full coin. For example, if `AtomicResolution = -8`
	// then a `PerpetualPosition` with `size = 1e8` is equivalent to
	// a position size of one full coin.
	// Defined in perpetuals.perpetual
	AtomicResolution int32 `protobuf:"zigzag32,4,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
	// The liquidity_tier that this perpetual is associated with.
	// Defined in perpetuals.perpetual
	LiquidityTier uint32 `protobuf:"varint,5,opt,name=liquidity_tier,json=liquidityTier,proto3" json:"liquidity_tier,omitempty"`
	// Market type of the perpetual.
	MarketType types.PerpetualMarketType `protobuf:"varint,6,opt,name=market_type,json=marketType,proto3,enum=dydxprotocol.indexer.protocol.v1.PerpetualMarketType" json:"market_type,omitempty"`
}

func (m *UpdatePerpetualEventV2) Reset()         { *m = UpdatePerpetualEventV2{} }
func (m *UpdatePerpetualEventV2) String() string { return proto.CompactTextString(m) }
func (*UpdatePerpetualEventV2) ProtoMessage()    {}
func (*UpdatePerpetualEventV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{21}
}
func (m *UpdatePerpetualEventV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePerpetualEventV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePerpetualEventV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePerpetualEventV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePerpetualEventV2.Merge(m, src)
}
func (m *UpdatePerpetualEventV2) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePerpetualEventV2) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePerpetualEventV2.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePerpetualEventV2 proto.InternalMessageInfo

func (m *UpdatePerpetualEventV2) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdatePerpetualEventV2) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *UpdatePerpetualEventV2) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *UpdatePerpetualEventV2) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

func (m *UpdatePerpetualEventV2) GetLiquidityTier() uint32 {
	if m != nil {
		return m.LiquidityTier
	}
	return 0
}

func (m *UpdatePerpetualEventV2) GetMarketType() types.PerpetualMarketType {
	if m != nil {
		return m.MarketType
	}
	return types.PerpetualMarketType_PERPETUAL_MARKET_TYPE_UNSPECIFIED
}

// UpdatePerpetualEventV3 message contains all the information about an update
// to a perpetual on the dYdX chain.
type UpdatePerpetualEventV3 struct {
	// Unique Perpetual id.
	// Defined in perpetuals.perpetual
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the `Perpetual` (e.g. `BTC-USD`).
	// Defined in perpetuals.perpetual
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Unique id of market param associated with this perpetual market.
	// Defined in perpetuals.perpetual
	MarketId uint32 `protobuf:"varint,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The exponent for converting an atomic amount (`size = 1`)
	// to a full coin. For example, if `AtomicResolution = -8`
	// then a `PerpetualPosition` with `size = 1e8` is equivalent to
	// a position size of one full coin.
	// Defined in perpetuals.perpetual
	AtomicResolution int32 `protobuf:"zigzag32,4,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
	// The liquidity_tier that this perpetual is associated with.
	// Defined in perpetuals.perpetual
	LiquidityTier uint32 `protobuf:"varint,5,opt,name=liquidity_tier,json=liquidityTier,proto3" json:"liquidity_tier,omitempty"`
	// Market type of the perpetual.
	MarketType types.PerpetualMarketType `protobuf:"varint,6,opt,name=market_type,json=marketType,proto3,enum=dydxprotocol.indexer.protocol.v1.PerpetualMarketType" json:"market_type,omitempty"`
	// Default 8hr funding rate in parts-per-million.
	DefaultFunding8HrPpm int32 `protobuf:"varint,7,opt,name=default_funding8hr_ppm,json=defaultFunding8hrPpm,proto3" json:"default_funding8hr_ppm,omitempty"`
}

func (m *UpdatePerpetualEventV3) Reset()         { *m = UpdatePerpetualEventV3{} }
func (m *UpdatePerpetualEventV3) String() string { return proto.CompactTextString(m) }
func (*UpdatePerpetualEventV3) ProtoMessage()    {}
func (*UpdatePerpetualEventV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{22}
}
func (m *UpdatePerpetualEventV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePerpetualEventV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePerpetualEventV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePerpetualEventV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePerpetualEventV3.Merge(m, src)
}
func (m *UpdatePerpetualEventV3) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePerpetualEventV3) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePerpetualEventV3.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePerpetualEventV3 proto.InternalMessageInfo

func (m *UpdatePerpetualEventV3) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdatePerpetualEventV3) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *UpdatePerpetualEventV3) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *UpdatePerpetualEventV3) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

func (m *UpdatePerpetualEventV3) GetLiquidityTier() uint32 {
	if m != nil {
		return m.LiquidityTier
	}
	return 0
}

func (m *UpdatePerpetualEventV3) GetMarketType() types.PerpetualMarketType {
	if m != nil {
		return m.MarketType
	}
	return types.PerpetualMarketType_PERPETUAL_MARKET_TYPE_UNSPECIFIED
}

func (m *UpdatePerpetualEventV3) GetDefaultFunding8HrPpm() int32 {
	if m != nil {
		return m.DefaultFunding8HrPpm
	}
	return 0
}

// TradingRewardsEventV1 is communicates all trading rewards for all accounts
// that receive trade rewards in the block.
type TradingRewardsEventV1 struct {
	// The list of all trading rewards in the block.
	TradingRewards []*AddressTradingReward `protobuf:"bytes,1,rep,name=trading_rewards,json=tradingRewards,proto3" json:"trading_rewards,omitempty"`
}

func (m *TradingRewardsEventV1) Reset()         { *m = TradingRewardsEventV1{} }
func (m *TradingRewardsEventV1) String() string { return proto.CompactTextString(m) }
func (*TradingRewardsEventV1) ProtoMessage()    {}
func (*TradingRewardsEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{23}
}
func (m *TradingRewardsEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingRewardsEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingRewardsEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingRewardsEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingRewardsEventV1.Merge(m, src)
}
func (m *TradingRewardsEventV1) XXX_Size() int {
	return m.Size()
}
func (m *TradingRewardsEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingRewardsEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_TradingRewardsEventV1 proto.InternalMessageInfo

func (m *TradingRewardsEventV1) GetTradingRewards() []*AddressTradingReward {
	if m != nil {
		return m.TradingRewards
	}
	return nil
}

// AddressTradingReward contains info on an instance of an address receiving a
// reward
type AddressTradingReward struct {
	// The address of the wallet that will receive the trading reward.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// The amount of trading rewards earned by the address above in denoms. 1e18
	// denoms is equivalent to a single coin.
	DenomAmount github_com_dydxprotocol_v4_chain_protocol_dtypes.SerializableInt `protobuf:"bytes,2,opt,name=denom_amount,json=denomAmount,proto3,customtype=github.com/dydxprotocol/v4-chain/protocol/dtypes.SerializableInt" json:"denom_amount"`
}

func (m *AddressTradingReward) Reset()         { *m = AddressTradingReward{} }
func (m *AddressTradingReward) String() string { return proto.CompactTextString(m) }
func (*AddressTradingReward) ProtoMessage()    {}
func (*AddressTradingReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{24}
}
func (m *AddressTradingReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressTradingReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressTradingReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressTradingReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressTradingReward.Merge(m, src)
}
func (m *AddressTradingReward) XXX_Size() int {
	return m.Size()
}
func (m *AddressTradingReward) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressTradingReward.DiscardUnknown(m)
}

var xxx_messageInfo_AddressTradingReward proto.InternalMessageInfo

func (m *AddressTradingReward) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// OpenInterestUpdateEventV1 is used for open interest update events
// Deprecated.
//
// Deprecated: Do not use.
type OpenInterestUpdateEventV1 struct {
	OpenInterestUpdates []*OpenInterestUpdate `protobuf:"bytes,1,rep,name=open_interest_updates,json=openInterestUpdates,proto3" json:"open_interest_updates,omitempty"`
}

func (m *OpenInterestUpdateEventV1) Reset()         { *m = OpenInterestUpdateEventV1{} }
func (m *OpenInterestUpdateEventV1) String() string { return proto.CompactTextString(m) }
func (*OpenInterestUpdateEventV1) ProtoMessage()    {}
func (*OpenInterestUpdateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{25}
}
func (m *OpenInterestUpdateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenInterestUpdateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenInterestUpdateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenInterestUpdateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenInterestUpdateEventV1.Merge(m, src)
}
func (m *OpenInterestUpdateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *OpenInterestUpdateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenInterestUpdateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_OpenInterestUpdateEventV1 proto.InternalMessageInfo

func (m *OpenInterestUpdateEventV1) GetOpenInterestUpdates() []*OpenInterestUpdate {
	if m != nil {
		return m.OpenInterestUpdates
	}
	return nil
}

// OpenInterestUpdate contains a single open interest update for a perpetual
// Deprecated.
//
// Deprecated: Do not use.
type OpenInterestUpdate struct {
	PerpetualId uint32 `protobuf:"varint,1,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// The new open interest value for the perpetual market.
	OpenInterest github_com_dydxprotocol_v4_chain_protocol_dtypes.SerializableInt `protobuf:"bytes,2,opt,name=open_interest,json=openInterest,proto3,customtype=github.com/dydxprotocol/v4-chain/protocol/dtypes.SerializableInt" json:"open_interest"`
}

func (m *OpenInterestUpdate) Reset()         { *m = OpenInterestUpdate{} }
func (m *OpenInterestUpdate) String() string { return proto.CompactTextString(m) }
func (*OpenInterestUpdate) ProtoMessage()    {}
func (*OpenInterestUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{26}
}
func (m *OpenInterestUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenInterestUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenInterestUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenInterestUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenInterestUpdate.Merge(m, src)
}
func (m *OpenInterestUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OpenInterestUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenInterestUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OpenInterestUpdate proto.InternalMessageInfo

func (m *OpenInterestUpdate) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

// LiquidationEventV2 message contains all the information needed to update
// the liquidity tiers. It contains all the fields from V1 along with the
// open interest caps.
type LiquidityTierUpsertEventV2 struct {
	// Unique id.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the tier purely for mnemonic purposes, e.g. "Gold".
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The margin fraction needed to open a position.
	// In parts-per-million.
	InitialMarginPpm uint32 `protobuf:"varint,3,opt,name=initial_margin_ppm,json=initialMarginPpm,proto3" json:"initial_margin_ppm,omitempty"`
	// The fraction of the initial-margin that the maintenance-margin is,
	// e.g. 50%. In parts-per-million.
	MaintenanceFractionPpm uint32 `protobuf:"varint,4,opt,name=maintenance_fraction_ppm,json=maintenanceFractionPpm,proto3" json:"maintenance_fraction_ppm,omitempty"`
	// The maximum position size at which the margin requirements are
	// not increased over the default values. Above this position size,
	// the margin requirements increase at a rate of sqrt(size).
	//
	// Deprecated since v3.x.
	BasePositionNotional uint64 `protobuf:"varint,5,opt,name=base_position_notional,json=basePositionNotional,proto3" json:"base_position_notional,omitempty"` // Deprecated: Do not use.
	// Lower cap of open interest in quote quantums. optional
	OpenInterestLowerCap uint64 `protobuf:"varint,6,opt,name=open_interest_lower_cap,json=openInterestLowerCap,proto3" json:"open_interest_lower_cap,omitempty"`
	// Upper cap of open interest in quote quantums.
	OpenInterestUpperCap uint64 `protobuf:"varint,7,opt,name=open_interest_upper_cap,json=openInterestUpperCap,proto3" json:"open_interest_upper_cap,omitempty"`
}

func (m *LiquidityTierUpsertEventV2) Reset()         { *m = LiquidityTierUpsertEventV2{} }
func (m *LiquidityTierUpsertEventV2) String() string { return proto.CompactTextString(m) }
func (*LiquidityTierUpsertEventV2) ProtoMessage()    {}
func (*LiquidityTierUpsertEventV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{27}
}
func (m *LiquidityTierUpsertEventV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityTierUpsertEventV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityTierUpsertEventV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityTierUpsertEventV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityTierUpsertEventV2.Merge(m, src)
}
func (m *LiquidityTierUpsertEventV2) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityTierUpsertEventV2) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityTierUpsertEventV2.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityTierUpsertEventV2 proto.InternalMessageInfo

func (m *LiquidityTierUpsertEventV2) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LiquidityTierUpsertEventV2) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LiquidityTierUpsertEventV2) GetInitialMarginPpm() uint32 {
	if m != nil {
		return m.InitialMarginPpm
	}
	return 0
}

func (m *LiquidityTierUpsertEventV2) GetMaintenanceFractionPpm() uint32 {
	if m != nil {
		return m.MaintenanceFractionPpm
	}
	return 0
}

// Deprecated: Do not use.
func (m *LiquidityTierUpsertEventV2) GetBasePositionNotional() uint64 {
	if m != nil {
		return m.BasePositionNotional
	}
	return 0
}

func (m *LiquidityTierUpsertEventV2) GetOpenInterestLowerCap() uint64 {
	if m != nil {
		return m.OpenInterestLowerCap
	}
	return 0
}

func (m *LiquidityTierUpsertEventV2) GetOpenInterestUpperCap() uint64 {
	if m != nil {
		return m.OpenInterestUpperCap
	}
	return 0
}

// Event emitted when a referee is registered with an affiliate.
type RegisterAffiliateEventV1 struct {
	// Address of the referee being registered.
	Referee string `protobuf:"bytes,1,opt,name=referee,proto3" json:"referee,omitempty"`
	// Address of the affiliate associated with the referee.
	Affiliate string `protobuf:"bytes,2,opt,name=affiliate,proto3" json:"affiliate,omitempty"`
}

func (m *RegisterAffiliateEventV1) Reset()         { *m = RegisterAffiliateEventV1{} }
func (m *RegisterAffiliateEventV1) String() string { return proto.CompactTextString(m) }
func (*RegisterAffiliateEventV1) ProtoMessage()    {}
func (*RegisterAffiliateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{28}
}
func (m *RegisterAffiliateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterAffiliateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterAffiliateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterAffiliateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterAffiliateEventV1.Merge(m, src)
}
func (m *RegisterAffiliateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *RegisterAffiliateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterAffiliateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterAffiliateEventV1 proto.InternalMessageInfo

func (m *RegisterAffiliateEventV1) GetReferee() string {
	if m != nil {
		return m.Referee
	}
	return ""
}

func (m *RegisterAffiliateEventV1) GetAffiliate() string {
	if m != nil {
		return m.Affiliate
	}
	return ""
}

// Event emitted when a vault is created / updated.
type UpsertVaultEventV1 struct {
	// Address of the vault.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Clob pair Id associated with the vault.
	ClobPairId uint32 `protobuf:"varint,2,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// Status of the vault.
	Status types.VaultStatus `protobuf:"varint,3,opt,name=status,proto3,enum=dydxprotocol.indexer.protocol.v1.VaultStatus" json:"status,omitempty"`
}

func (m *UpsertVaultEventV1) Reset()         { *m = UpsertVaultEventV1{} }
func (m *UpsertVaultEventV1) String() string { return proto.CompactTextString(m) }
func (*UpsertVaultEventV1) ProtoMessage()    {}
func (*UpsertVaultEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{29}
}
func (m *UpsertVaultEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertVaultEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertVaultEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertVaultEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertVaultEventV1.Merge(m, src)
}
func (m *UpsertVaultEventV1) XXX_Size() int {
	return m.Size()
}
func (m *UpsertVaultEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertVaultEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertVaultEventV1 proto.InternalMessageInfo

func (m *UpsertVaultEventV1) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *UpsertVaultEventV1) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *UpsertVaultEventV1) GetStatus() types.VaultStatus {
	if m != nil {
		return m.Status
	}
	return types.VaultStatus_VAULT_STATUS_UNSPECIFIED
}

func init() {
	proto.RegisterEnum("dydxprotocol.indexer.events.FundingEventV1_Type", FundingEventV1_Type_name, FundingEventV1_Type_value)
	proto.RegisterType((*FundingUpdateV1)(nil), "dydxprotocol.indexer.events.FundingUpdateV1")
	proto.RegisterType((*FundingEventV1)(nil), "dydxprotocol.indexer.events.FundingEventV1")
	proto.RegisterType((*MarketEventV1)(nil), "dydxprotocol.indexer.events.MarketEventV1")
	proto.RegisterType((*MarketPriceUpdateEventV1)(nil), "dydxprotocol.indexer.events.MarketPriceUpdateEventV1")
	proto.RegisterType((*MarketBaseEventV1)(nil), "dydxprotocol.indexer.events.MarketBaseEventV1")
	proto.RegisterType((*MarketCreateEventV1)(nil), "dydxprotocol.indexer.events.MarketCreateEventV1")
	proto.RegisterType((*MarketModifyEventV1)(nil), "dydxprotocol.indexer.events.MarketModifyEventV1")
	proto.RegisterType((*SourceOfFunds)(nil), "dydxprotocol.indexer.events.SourceOfFunds")
	proto.RegisterType((*TransferEventV1)(nil), "dydxprotocol.indexer.events.TransferEventV1")
	proto.RegisterType((*OrderFillEventV1)(nil), "dydxprotocol.indexer.events.OrderFillEventV1")
	proto.RegisterType((*DeleveragingEventV1)(nil), "dydxprotocol.indexer.events.DeleveragingEventV1")
	proto.RegisterType((*LiquidationOrderV1)(nil), "dydxprotocol.indexer.events.LiquidationOrderV1")
	proto.RegisterType((*SubaccountUpdateEventV1)(nil), "dydxprotocol.indexer.events.SubaccountUpdateEventV1")
	proto.RegisterType((*StatefulOrderEventV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1")
	proto.RegisterType((*StatefulOrderEventV1_StatefulOrderPlacementV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1")
	proto.RegisterType((*StatefulOrderEventV1_StatefulOrderRemovalV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1")
	proto.RegisterType((*StatefulOrderEventV1_ConditionalOrderPlacementV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1")
	proto.RegisterType((*StatefulOrderEventV1_ConditionalOrderTriggeredV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1")
	proto.RegisterType((*StatefulOrderEventV1_LongTermOrderPlacementV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1")
	proto.RegisterType((*StatefulOrderEventV1_LongTermOrderReplacementV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderReplacementV1")
	proto.RegisterType((*StatefulOrderEventV1_TwapOrderPlacementV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.TwapOrderPlacementV1")
	proto.RegisterType((*AssetCreateEventV1)(nil), "dydxprotocol.indexer.events.AssetCreateEventV1")
	proto.RegisterType((*PerpetualMarketCreateEventV1)(nil), "dydxprotocol.indexer.events.PerpetualMarketCreateEventV1")
	proto.RegisterType((*PerpetualMarketCreateEventV2)(nil), "dydxprotocol.indexer.events.PerpetualMarketCreateEventV2")
	proto.RegisterType((*PerpetualMarketCreateEventV3)(nil), "dydxprotocol.indexer.events.PerpetualMarketCreateEventV3")
	proto.RegisterType((*LiquidityTierUpsertEventV1)(nil), "dydxprotocol.indexer.events.LiquidityTierUpsertEventV1")
	proto.RegisterType((*UpdateClobPairEventV1)(nil), "dydxprotocol.indexer.events.UpdateClobPairEventV1")
	proto.RegisterType((*UpdatePerpetualEventV1)(nil), "dydxprotocol.indexer.events.UpdatePerpetualEventV1")
	proto.RegisterType((*UpdatePerpetualEventV2)(nil), "dydxprotocol.indexer.events.UpdatePerpetualEventV2")
	proto.RegisterType((*UpdatePerpetualEventV3)(nil), "dydxprotocol.indexer.events.UpdatePerpetualEventV3")
	proto.RegisterType((*TradingRewardsEventV1)(nil), "dydxprotocol.indexer.events.TradingRewardsEventV1")
	proto.RegisterType((*AddressTradingReward)(nil), "dydxprotocol.indexer.events.AddressTradingReward")
	proto.RegisterType((*OpenInterestUpdateEventV1)(nil), "dydxprotocol.indexer.events.OpenInterestUpdateEventV1")
	proto.RegisterType((*OpenInterestUpdate)(nil), "dydxprotocol.indexer.events.OpenInterestUpdate")
	proto.RegisterType((*LiquidityTierUpsertEventV2)(nil), "dydxprotocol.indexer.events.LiquidityTierUpsertEventV2")
	proto.RegisterType((*RegisterAffiliateEventV1)(nil), "dydxprotocol.indexer.events.RegisterAffiliateEventV1")
	proto.RegisterType((*UpsertVaultEventV1)(nil), "dydxprotocol.indexer.events.UpsertVaultEventV1")
}

func init() {
	proto.RegisterFile("dydxprotocol/indexer/events/events.proto", fileDescriptor_6331dfb59c6fd2bb)
}

var fileDescriptor_6331dfb59c6fd2bb = []byte{
	// 2664 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x1a, 0x4d, 0x6f, 0x1b, 0xc7,
	0x55, 0x4b, 0x52, 0x24, 0xf5, 0x28, 0x4a, 0xe4, 0x88, 0x92, 0x29, 0xa9, 0xb5, 0xdd, 0x05, 0x0a,
	0x18, 0xf9, 0xa0, 0x6c, 0x39, 0x09, 0x82, 0x04, 0x28, 0x2a, 0xea, 0x23, 0xa2, 0x21, 0xd9, 0xcc,
	0x4a, 0x76, 0x12, 0x37, 0xc8, 0x76, 0xc4, 0x1d, 0x52, 0x03, 0xef, 0x97, 0x77, 0x87, 0x52, 0xe4,
	0xa2, 0xb7, 0xa2, 0xed, 0xa1, 0x45, 0x0b, 0xf4, 0x94, 0x43, 0x81, 0x5e, 0x7a, 0x49, 0xd1, 0x43,
	0x81, 0xa6, 0xb7, 0xa2, 0x28, 0x7a, 0x09, 0xd0, 0x43, 0x83, 0x9e, 0x8a, 0x1e, 0x82, 0x22, 0x39,
	0xf4, 0x6f, 0x14, 0xf3, 0xb1, 0xcb, 0x6f, 0x8a, 0xb6, 0x14, 0x20, 0x68, 0x72, 0x22, 0xf7, 0x7d,
	0xcf, 0x9b, 0xf7, 0xde, 0xbc, 0x79, 0xbb, 0x70, 0xc3, 0x3a, 0xb3, 0xde, 0xf7, 0x03, 0x8f, 0x79,
	0x0d, 0xcf, 0x5e, 0xa3, 0xae, 0x45, 0xde, 0x27, 0xc1, 0x1a, 0x39, 0x21, 0x2e, 0x0b, 0xd5, 0x4f,
	0x45, 0xa0, 0xd1, 0x6a, 0x37, 0x65, 0x45, 0x51, 0x56, 0x24, 0xc9, 0xca, 0x72, 0xc3, 0x0b, 0x1d,
	0x2f, 0x34, 0x05, 0x7e, 0x4d, 0x3e, 0x48, 0xbe, 0x95, 0x52, 0xcb, 0x6b, 0x79, 0x12, 0xce, 0xff,
	0x29, 0xe8, 0xcd, 0xa1, 0x7a, 0xc3, 0x63, 0x1c, 0x10, 0x6b, 0x2d, 0x20, 0x8e, 0x77, 0x82, 0x6d,
	0x33, 0x20, 0x38, 0xf4, 0x5c, 0xc5, 0xf1, 0xfc, 0x50, 0x8e, 0x18, 0x70, 0x72, 0x6b, 0xad, 0x61,
	0x7b, 0x47, 0x63, 0xc5, 0x77, 0x13, 0xfb, 0x24, 0xf0, 0x09, 0x6b, 0x63, 0x5b, 0x71, 0xdc, 0x3a,
	0x97, 0x23, 0x6c, 0x1f, 0xe1, 0x46, 0xc3, 0x6b, 0xbb, 0x4c, 0xb1, 0xbc, 0x70, 0x2e, 0xcb, 0x09,
	0x6e, 0xdb, 0x8a, 0x5a, 0xff, 0x87, 0x06, 0xf3, 0x3b, 0x6d, 0xd7, 0xa2, 0x6e, 0xeb, 0xbe, 0x6f,
	0x61, 0x46, 0x1e, 0xdc, 0x42, 0xdf, 0x82, 0xd9, 0xd8, 0x0e, 0x93, 0x5a, 0x65, 0xed, 0xba, 0x76,
	0x23, 0x6f, 0xe4, 0x62, 0x58, 0xcd, 0x42, 0xcf, 0x41, 0xb1, 0x29, 0xb9, 0xcc, 0x13, 0x6c, 0xb7,
	0x89, 0xe9, 0xfb, 0x4e, 0x39, 0x71, 0x5d, 0xbb, 0x31, 0x6d, 0xcc, 0x2b, 0xc4, 0x03, 0x0e, 0xaf,
	0xfb, 0x0e, 0x72, 0x20, 0x1f, 0xd1, 0x0a, 0x6b, 0xca, 0xc9, 0xeb, 0xda, 0x8d, 0xd9, 0xea, 0xee,
	0xc7, 0x9f, 0x5e, 0x9b, 0xfa, 0xf7, 0xa7, 0xd7, 0xbe, 0xdb, 0xa2, 0xec, 0xb8, 0x7d, 0x54, 0x69,
	0x78, 0xce, 0x5a, 0x8f, 0xe9, 0x27, 0x2f, 0xbd, 0xd8, 0x38, 0xc6, 0xd4, 0xed, 0xd8, 0x6e, 0xb1,
	0x33, 0x9f, 0x84, 0x95, 0x03, 0x12, 0x50, 0x6c, 0xd3, 0x27, 0xf8, 0xc8, 0x26, 0x35, 0x97, 0x19,
	0xb3, 0x4a, 0x7c, 0x8d, 0x4b, 0xd7, 0x7f, 0x95, 0x80, 0x39, 0xb5, 0xa2, 0x6d, 0x1e, 0x06, 0x0f,
	0x6e, 0xa1, 0x3d, 0xc8, 0xb4, 0xc5, 0xe2, 0xc2, 0xb2, 0x76, 0x3d, 0x79, 0x23, 0xb7, 0xfe, 0x42,
	0x65, 0x4c, 0xd8, 0x54, 0xfa, 0xfc, 0x51, 0x4d, 0x71, 0x4b, 0x8d, 0x48, 0x04, 0xda, 0x82, 0x14,
	0xb7, 0x43, 0x2c, 0x77, 0x6e, 0xfd, 0xe6, 0x24, 0xa2, 0x94, 0x21, 0x95, 0xc3, 0x33, 0x9f, 0x18,
	0x82, 0x5b, 0x77, 0x20, 0xc5, 0x9f, 0x50, 0x09, 0x0a, 0x87, 0xef, 0xd4, 0xb7, 0xcd, 0xfb, 0x77,
	0x0f, 0xea, 0xdb, 0x9b, 0xb5, 0x9d, 0xda, 0xf6, 0x56, 0x61, 0x0a, 0x5d, 0x81, 0x05, 0x01, 0xad,
	0x1b, 0xdb, 0xfb, 0xb5, 0xfb, 0xfb, 0xe6, 0xc1, 0xc6, 0x7e, 0x7d, 0x6f, 0xbb, 0xa0, 0xa1, 0x6b,
	0xb0, 0x2a, 0x10, 0x3b, 0xf7, 0xef, 0x6e, 0xd5, 0xee, 0xbe, 0x61, 0x1a, 0x1b, 0x87, 0xdb, 0xe6,
	0xc6, 0xdd, 0x2d, 0xb3, 0x76, 0x77, 0x6b, 0xfb, 0xed, 0x42, 0x02, 0x2d, 0x42, 0xb1, 0x87, 0xf3,
	0xc1, 0xbd, 0xc3, 0xed, 0x42, 0x52, 0xff, 0x5b, 0x02, 0xf2, 0xfb, 0x38, 0x78, 0x44, 0x58, 0xe4,
	0x94, 0x55, 0x98, 0x71, 0x04, 0xa0, 0xb3, 0xc5, 0x59, 0x09, 0xa8, 0x59, 0xe8, 0x21, 0xcc, 0xfa,
	0x01, 0x6d, 0x10, 0x53, 0x2e, 0x5a, 0xac, 0x35, 0xb7, 0xfe, 0xf2, 0xd8, 0xb5, 0x4a, 0xf1, 0x75,
	0xce, 0x26, 0x5d, 0xa7, 0x34, 0xed, 0x4e, 0x19, 0x39, 0xbf, 0x03, 0x45, 0x6f, 0x41, 0x5e, 0x29,
	0x6e, 0x04, 0x84, 0x0b, 0x4f, 0x0a, 0xe1, 0x37, 0x27, 0x10, 0xbe, 0x29, 0x18, 0x3a, 0x72, 0x67,
	0x9d, 0x2e, 0x70, 0x97, 0x60, 0xc7, 0xb3, 0x68, 0xf3, 0xac, 0x9c, 0x9a, 0x58, 0xf0, 0xbe, 0x60,
	0x18, 0x10, 0x2c, 0xc1, 0xd5, 0x0c, 0x4c, 0x0b, 0x6a, 0xfd, 0x0e, 0x94, 0x47, 0xad, 0x12, 0x55,
	0x60, 0x41, 0xba, 0xec, 0x94, 0xb2, 0x63, 0x93, 0xbc, 0xef, 0x7b, 0x2e, 0x71, 0x99, 0xf0, 0x6c,
	0xca, 0x28, 0x0a, 0xd4, 0x5b, 0x94, 0x1d, 0x6f, 0x2b, 0x84, 0xfe, 0x36, 0x14, 0xa5, 0xac, 0x2a,
	0x0e, 0x63, 0x21, 0x08, 0x52, 0x3e, 0xa6, 0x81, 0xe0, 0x9a, 0x31, 0xc4, 0x7f, 0xb4, 0x06, 0x25,
	0x87, 0xba, 0xa6, 0x14, 0xde, 0x38, 0xc6, 0x6e, 0xab, 0x93, 0x6e, 0x79, 0xa3, 0xe8, 0x50, 0x57,
	0x58, 0xb3, 0x29, 0x30, 0x75, 0xdf, 0xd1, 0xdb, 0xb0, 0x30, 0xc4, 0x5d, 0xa8, 0x0a, 0xa9, 0x23,
	0x1c, 0x12, 0x21, 0x3b, 0xb7, 0x5e, 0x99, 0xc0, 0x2b, 0x5d, 0x96, 0x19, 0x82, 0x17, 0xad, 0x40,
	0x36, 0x5e, 0x19, 0xd7, 0x5f, 0x34, 0xe2, 0x67, 0xfd, 0x9d, 0x48, 0x6d, 0x8f, 0x33, 0x2f, 0x43,
	0xad, 0xfe, 0x7b, 0x0d, 0xf2, 0x07, 0x5e, 0x3b, 0x68, 0x90, 0x7b, 0x4d, 0x9e, 0x52, 0x21, 0x7a,
	0x17, 0xf2, 0x9d, 0xca, 0x17, 0x45, 0xf0, 0xc8, 0x08, 0x8d, 0x01, 0x27, 0xb7, 0x2a, 0x35, 0x09,
	0x3b, 0x88, 0xb9, 0x6b, 0x16, 0xdf, 0xf0, 0xb0, 0xeb, 0x19, 0xbd, 0x04, 0x19, 0x6c, 0x59, 0x01,
	0x09, 0x43, 0xb1, 0xca, 0x99, 0x6a, 0xf9, 0x9f, 0x7f, 0x7c, 0xb1, 0xa4, 0x0e, 0x90, 0x0d, 0x89,
	0x39, 0x60, 0x01, 0x75, 0x5b, 0xbb, 0x53, 0x46, 0x44, 0x5a, 0xcd, 0x42, 0x3a, 0x14, 0x46, 0xea,
	0x1f, 0x26, 0x61, 0xfe, 0x30, 0xc0, 0x6e, 0xd8, 0x24, 0x41, 0xe4, 0x87, 0x16, 0x94, 0x42, 0xe2,
	0x5a, 0x24, 0x30, 0x2f, 0xcf, 0x70, 0x03, 0x49, 0x91, 0xdd, 0x30, 0xe4, 0xc0, 0x95, 0x80, 0x34,
	0xa8, 0x4f, 0x89, 0xcb, 0xfa, 0x74, 0x25, 0x2e, 0xa2, 0x6b, 0x31, 0x96, 0xda, 0xa3, 0x6e, 0x19,
	0xb2, 0x38, 0x0c, 0x65, 0x19, 0x49, 0x8a, 0x90, 0xcc, 0x88, 0xe7, 0x9a, 0x85, 0x96, 0x20, 0x8d,
	0x1d, 0x4e, 0x26, 0x32, 0x31, 0x65, 0xa8, 0x27, 0x54, 0x85, 0xb4, 0xb4, 0xbb, 0x3c, 0x2d, 0x0c,
	0x7a, 0x6e, 0x6c, 0x50, 0xf4, 0x6c, 0xbc, 0xa1, 0x38, 0xd1, 0x2e, 0xcc, 0xc4, 0xf6, 0x94, 0xd3,
	0x4f, 0x2d, 0xa6, 0xc3, 0xac, 0xff, 0x2e, 0x03, 0x85, 0x7b, 0x81, 0x45, 0x82, 0x1d, 0x6a, 0xdb,
	0xd1, 0x6e, 0xdd, 0x87, 0x9c, 0x83, 0x1f, 0x91, 0xc0, 0xf4, 0x38, 0x66, 0x7c, 0xf0, 0x0e, 0x71,
	0x9c, 0x90, 0xa7, 0x0e, 0x0e, 0x10, 0x82, 0x04, 0x04, 0xed, 0xc0, 0xb4, 0x14, 0x98, 0x78, 0x16,
	0x81, 0xbb, 0x53, 0x86, 0x64, 0x47, 0xef, 0x41, 0xd1, 0xa6, 0x8f, 0xdb, 0xd4, 0xc2, 0x8c, 0x7a,
	0xae, 0x32, 0x52, 0x96, 0xbb, 0xb5, 0xb1, 0x5e, 0xd8, 0xeb, 0x70, 0x09, 0x91, 0xa2, 0xda, 0x15,
	0xec, 0x3e, 0x28, 0xba, 0x06, 0xb9, 0x26, 0xb5, 0x6d, 0x53, 0x6d, 0x5f, 0x52, 0x6c, 0x1f, 0x70,
	0xd0, 0x86, 0xdc, 0x42, 0x71, 0x7a, 0x70, 0xff, 0x34, 0x09, 0x11, 0xbb, 0x88, 0xf8, 0xe9, 0xf1,
	0x88, 0x04, 0x3b, 0x84, 0x70, 0x24, 0x8b, 0x91, 0x69, 0x89, 0x64, 0x11, 0xf2, 0x05, 0x40, 0xcc,
	0x63, 0xd8, 0x36, 0xb9, 0x34, 0x62, 0x99, 0x82, 0xab, 0x9c, 0x11, 0x1a, 0x0a, 0x02, 0xb3, 0x23,
	0x10, 0xfb, 0x1c, 0x3e, 0x40, 0x2d, 0xc4, 0x94, 0xb3, 0x03, 0xd4, 0x87, 0x82, 0xba, 0x02, 0x0b,
	0xb8, 0xd9, 0xa4, 0x36, 0xc5, 0x8c, 0x98, 0x01, 0x39, 0x31, 0x45, 0xeb, 0x56, 0x9e, 0x91, 0x35,
	0x38, 0x46, 0x19, 0xe4, 0xe4, 0x80, 0x23, 0x78, 0x1b, 0x23, 0x57, 0x71, 0xd4, 0xa6, 0xb6, 0xa5,
	0x0c, 0x06, 0x41, 0x3d, 0x2f, 0x10, 0x55, 0x09, 0xe7, 0x76, 0x3f, 0x07, 0x45, 0x36, 0x40, 0x9b,
	0x93, 0xb4, 0xac, 0x8f, 0x76, 0x1d, 0x16, 0x7b, 0xe5, 0x46, 0xd5, 0x64, 0x56, 0xd4, 0xf5, 0x85,
	0x6e, 0xd9, 0xaa, 0x9c, 0x70, 0x1e, 0x36, 0x94, 0x27, 0x2f, 0x79, 0xd8, 0x10, 0x9e, 0xdb, 0xb0,
	0xd4, 0x15, 0xa5, 0x66, 0xe0, 0xb5, 0x99, 0x32, 0x6c, 0x4e, 0x18, 0xb6, 0xd0, 0x09, 0x3d, 0x43,
	0xe0, 0xb8, 0x71, 0xb7, 0x61, 0x89, 0x0d, 0x67, 0x9a, 0x97, 0x4c, 0x6c, 0x08, 0xd3, 0xeb, 0xb0,
	0x32, 0x44, 0x53, 0x64, 0x62, 0x41, 0x98, 0x78, 0xa5, 0x5f, 0x5b, 0x64, 0xe6, 0xeb, 0xb0, 0xc2,
	0x46, 0x33, 0x17, 0x25, 0x33, 0x1b, 0xce, 0x5c, 0xcd, 0x43, 0xae, 0x8b, 0x59, 0xff, 0x59, 0x12,
	0x16, 0xb6, 0x88, 0x4d, 0x4e, 0x48, 0x80, 0x5b, 0x5d, 0x3d, 0xde, 0xf7, 0x00, 0xa2, 0x28, 0x26,
	0x17, 0x2b, 0xaa, 0x51, 0xda, 0x76, 0xc4, 0x71, 0xe1, 0x5e, 0xb3, 0x19, 0x12, 0xc6, 0xa8, 0xdb,
	0xba, 0x50, 0x15, 0x8d, 0x84, 0x77, 0xc4, 0x0d, 0xb4, 0xdb, 0xc9, 0xc1, 0x76, 0xbb, 0x2f, 0x1d,
	0x53, 0x03, 0xe9, 0x78, 0x13, 0x4a, 0x32, 0x4d, 0x1e, 0xb7, 0x3d, 0x46, 0xcc, 0xc7, 0x6d, 0xec,
	0xb2, 0xb6, 0x13, 0x8a, 0xcc, 0x4c, 0x19, 0x32, 0x85, 0xde, 0xe4, 0xa8, 0x37, 0x15, 0x06, 0x2d,
	0x42, 0x9a, 0x86, 0xe6, 0x51, 0xfb, 0x4c, 0x24, 0x68, 0xd6, 0x98, 0xa6, 0x61, 0xb5, 0x7d, 0xc6,
	0x33, 0x88, 0x86, 0x66, 0x93, 0xba, 0xd8, 0x36, 0xb9, 0x81, 0x36, 0x71, 0x78, 0x81, 0xcd, 0x08,
	0x9a, 0x22, 0x0d, 0x77, 0x38, 0xe6, 0x20, 0x46, 0xe8, 0x3f, 0x4d, 0x00, 0x1a, 0xac, 0x29, 0x5f,
	0xec, 0x6e, 0x5c, 0x87, 0x59, 0x7e, 0xa9, 0x32, 0x79, 0x77, 0x14, 0x9d, 0x6a, 0x79, 0x03, 0x38,
	0xac, 0x8e, 0x69, 0x50, 0xb3, 0x26, 0x71, 0xe9, 0x37, 0x01, 0xa4, 0xc7, 0x42, 0xfa, 0x84, 0x28,
	0x8f, 0xce, 0x08, 0xc8, 0x01, 0x7d, 0x42, 0xba, 0xdc, 0x33, 0xdd, 0xed, 0x9e, 0x15, 0xc8, 0x86,
	0xed, 0x23, 0x46, 0x1b, 0x8f, 0x42, 0xe1, 0xb7, 0x94, 0x11, 0x3f, 0xeb, 0xff, 0x4d, 0xc0, 0x95,
	0x8e, 0xe5, 0xbd, 0xcd, 0xe1, 0xc3, 0xcb, 0x6c, 0x57, 0xfa, 0x9a, 0x95, 0x27, 0xb0, 0x2a, 0xbb,
	0x74, 0xcb, 0xec, 0x2c, 0xda, 0xf7, 0x42, 0xca, 0x37, 0x24, 0x2c, 0x27, 0xc5, 0x8d, 0xe7, 0xb5,
	0x89, 0x35, 0xd5, 0x23, 0x19, 0x75, 0x25, 0xc2, 0x58, 0x56, 0xe2, 0x07, 0x30, 0x21, 0x72, 0xe1,
	0x4a, 0xa4, 0x5b, 0x36, 0x01, 0x1d, 0xbd, 0x29, 0xa1, 0xf7, 0x95, 0x89, 0xf5, 0x6e, 0x70, 0xfe,
	0x58, 0xe7, 0xa2, 0x12, 0xdb, 0x03, 0x0d, 0xef, 0xa4, 0xb2, 0x89, 0x42, 0x52, 0xff, 0x68, 0x0e,
	0x4a, 0x07, 0x0c, 0x33, 0xd2, 0x6c, 0xdb, 0x22, 0xe2, 0x22, 0x37, 0x3f, 0x86, 0x9c, 0x2c, 0x31,
	0xbe, 0x8d, 0x1b, 0x51, 0xcb, 0x79, 0x67, 0x7c, 0x5b, 0x30, 0x44, 0x4e, 0x2f, 0xb0, 0xce, 0x65,
	0x39, 0x02, 0x51, 0x4d, 0x94, 0xb5, 0x5d, 0x9e, 0xbd, 0x31, 0x1c, 0x79, 0x90, 0x57, 0x55, 0x4d,
	0x8e, 0x07, 0xd4, 0x29, 0xbc, 0x7b, 0x41, 0xa5, 0x86, 0x94, 0x26, 0x2f, 0x23, 0x5e, 0x17, 0x04,
	0xfd, 0x42, 0x83, 0xd5, 0x86, 0xe7, 0x5a, 0xc2, 0x23, 0xd8, 0x36, 0xbb, 0x16, 0x2c, 0x52, 0x55,
	0xb6, 0x54, 0xfb, 0x4f, 0xaf, 0x7f, 0xb3, 0x23, 0xb4, 0x7f, 0xdd, 0xbb, 0x53, 0xc6, 0x72, 0x63,
	0x14, 0x7a, 0x84, 0x45, 0x2c, 0xa0, 0xad, 0x16, 0x09, 0x88, 0xa5, 0xba, 0xb3, 0x4b, 0xb0, 0xe8,
	0x30, 0x12, 0x39, 0xdc, 0xa2, 0x18, 0x8d, 0x7e, 0xa2, 0xc1, 0xb2, 0xed, 0xb9, 0x2d, 0x93, 0x91,
	0xc0, 0x19, 0xf0, 0x50, 0xe6, 0x59, 0xc3, 0x62, 0xcf, 0x73, 0x5b, 0x87, 0x24, 0x70, 0x86, 0xb8,
	0x67, 0xc9, 0x1e, 0x8a, 0x43, 0x3f, 0x80, 0x62, 0x14, 0x1e, 0x1d, 0x03, 0xb2, 0xc2, 0x80, 0xbd,
	0x0b, 0x1a, 0x60, 0x74, 0x24, 0xca, 0x2e, 0xce, 0xeb, 0x83, 0xa2, 0x27, 0x50, 0x62, 0xa7, 0xd8,
	0x1f, 0x70, 0xc0, 0x8c, 0xd0, 0xbf, 0xf3, 0xf4, 0xfa, 0x0f, 0x4f, 0xb1, 0x3f, 0x64, 0xf1, 0x88,
	0x0d, 0xc0, 0x57, 0xbe, 0x0f, 0xe5, 0x51, 0x59, 0x84, 0xb6, 0xa2, 0x2e, 0xf8, 0x99, 0xda, 0x6a,
	0xd5, 0x03, 0xaf, 0xfc, 0x59, 0x83, 0xa5, 0xe1, 0x39, 0x83, 0x1e, 0x42, 0x41, 0xa4, 0x23, 0xb1,
	0xd4, 0xda, 0xe3, 0x8a, 0x7b, 0xf3, 0xe9, 0x74, 0xd5, 0x2c, 0x63, 0x4e, 0x49, 0x52, 0xcf, 0xe8,
	0x0d, 0x48, 0xcb, 0x09, 0xa0, 0x1a, 0x00, 0x8d, 0xe8, 0xb7, 0xe5, 0xd0, 0xb0, 0xd2, 0x6d, 0x98,
	0x21, 0xd8, 0x0c, 0xc5, 0xbe, 0xd2, 0x80, 0xd5, 0x31, 0x29, 0x77, 0x49, 0x4e, 0xfa, 0xe1, 0xa0,
	0x92, 0xae, 0x2c, 0x42, 0xef, 0x01, 0x8a, 0xf3, 0xf4, 0xe2, 0xae, 0x2a, 0xc4, 0xb2, 0x14, 0x84,
	0x47, 0xc1, 0xa8, 0xa4, 0xb9, 0xa4, 0x05, 0xfe, 0x49, 0x83, 0x95, 0xd1, 0x69, 0x81, 0x0c, 0x98,
	0xf5, 0xec, 0x4b, 0x58, 0x1a, 0x78, 0x76, 0x1c, 0x01, 0x5b, 0x17, 0xba, 0xc4, 0x45, 0x86, 0xbf,
	0x0b, 0xa5, 0x61, 0xe9, 0x74, 0x39, 0x6e, 0x89, 0x47, 0x56, 0xf2, 0xc4, 0xbc, 0x93, 0xca, 0x26,
	0x0b, 0x29, 0xfd, 0xb7, 0x1a, 0x20, 0x71, 0xa0, 0xf6, 0x0e, 0x86, 0xe6, 0x20, 0x11, 0x8f, 0x00,
	0x13, 0x54, 0x5c, 0xdb, 0xc3, 0x33, 0xe7, 0xc8, 0xb3, 0xe5, 0xf0, 0xc3, 0x50, 0x4f, 0xbc, 0x65,
	0x3a, 0xc6, 0xa1, 0x29, 0x47, 0x63, 0xa2, 0xa7, 0xca, 0x1a, 0x33, 0xc7, 0x38, 0x94, 0x53, 0x9b,
	0xde, 0x81, 0x62, 0xaa, 0x6f, 0xa0, 0xf8, 0x3c, 0x14, 0x31, 0xf3, 0x1c, 0xda, 0x30, 0x03, 0x12,
	0x7a, 0x76, 0x9b, 0xc7, 0xa3, 0x38, 0xaa, 0x8a, 0x46, 0x41, 0x22, 0x8c, 0x18, 0xae, 0xff, 0x35,
	0x09, 0xdf, 0x88, 0x9b, 0x8d, 0x61, 0xa3, 0xac, 0x7e, 0x8b, 0xcf, 0xef, 0x08, 0x97, 0x20, 0xcd,
	0xbb, 0x34, 0x12, 0x08, 0xbb, 0x67, 0x0c, 0xf5, 0x34, 0xde, 0xe8, 0x5d, 0x48, 0x87, 0x0c, 0xb3,
	0xb6, 0xec, 0xa3, 0xe7, 0x26, 0x09, 0x9b, 0x4d, 0xa5, 0xf2, 0x40, 0xf0, 0x19, 0x8a, 0x1f, 0x7d,
	0x07, 0x56, 0x55, 0x4f, 0x6e, 0x36, 0x3c, 0xf7, 0x84, 0x04, 0x21, 0xbf, 0xb6, 0xc7, 0xa3, 0xb4,
	0xb4, 0x70, 0xc4, 0xb2, 0x22, 0xd9, 0x8c, 0x29, 0xa2, 0x61, 0xe1, 0x70, 0xf7, 0x65, 0x86, 0xbb,
	0x8f, 0xdf, 0x54, 0xa3, 0xa6, 0x94, 0x77, 0x84, 0x26, 0xff, 0x27, 0xce, 0x9c, 0xbc, 0x31, 0x1f,
	0x21, 0xea, 0x24, 0x38, 0xa4, 0x8d, 0x47, 0xfc, 0x7e, 0x1d, 0x32, 0xe2, 0x9b, 0x47, 0x38, 0xec,
	0xba, 0x36, 0xc8, 0x0b, 0x73, 0x81, 0x63, 0xaa, 0x38, 0xec, 0x5c, 0x1a, 0xbe, 0x0d, 0x73, 0xb2,
	0x0f, 0xa7, 0xec, 0xcc, 0x64, 0x94, 0x04, 0xe2, 0xb2, 0x9c, 0x37, 0xf2, 0x31, 0xf4, 0x90, 0x92,
	0xe0, 0xb5, 0x44, 0x59, 0xd3, 0x3f, 0x48, 0x8d, 0xdd, 0xc3, 0xf5, 0xaf, 0xf7, 0xf0, 0x4b, 0xbd,
	0x87, 0xe8, 0x01, 0xe4, 0x94, 0x53, 0xc5, 0xcb, 0x8e, 0x9c, 0x70, 0xde, 0x04, 0xf7, 0x95, 0xbe,
	0x3d, 0x17, 0x6f, 0x3c, 0xc0, 0x89, 0xff, 0x8b, 0xd8, 0xf8, 0xfb, 0xf8, 0xd8, 0xb8, 0xfd, 0x75,
	0x6c, 0x7c, 0x25, 0x63, 0x03, 0xbd, 0x04, 0x4b, 0x16, 0x69, 0xe2, 0xb6, 0xcd, 0x4c, 0xf5, 0x4a,
	0xef, 0xd5, 0xe3, 0x40, 0xbc, 0xeb, 0x98, 0x15, 0xaf, 0x16, 0x4b, 0x0a, 0xbb, 0x13, 0x23, 0xeb,
	0xbe, 0xa3, 0xff, 0x26, 0x01, 0x2b, 0x7b, 0xdd, 0xf6, 0xdd, 0xf7, 0x43, 0x12, 0xb0, 0x51, 0x67,
	0x05, 0x82, 0x94, 0x8b, 0x1d, 0xa2, 0xce, 0x36, 0xf1, 0x9f, 0x7b, 0x89, 0xba, 0x94, 0x51, 0x6c,
	0xf3, 0xd3, 0xad, 0x45, 0x5d, 0xa1, 0x54, 0x4e, 0x0d, 0x0a, 0x0a, 0xb3, 0x2f, 0x10, 0x75, 0xdf,
	0x41, 0xaf, 0x42, 0xd9, 0xc1, 0xd4, 0x65, 0xc4, 0xc5, 0x6e, 0x83, 0x98, 0xcd, 0x00, 0x37, 0xc4,
	0x14, 0x96, 0xf3, 0xc8, 0x10, 0x5b, 0xea, 0xc2, 0xef, 0x28, 0xb4, 0xe4, 0x5c, 0x12, 0x1b, 0x11,
	0xdd, 0x92, 0x4d, 0xd7, 0x93, 0x8d, 0x99, 0x1c, 0xd4, 0xf0, 0xeb, 0xa5, 0x51, 0xe2, 0x14, 0xd1,
	0x8d, 0xf7, 0xae, 0xc2, 0xdf, 0x49, 0x65, 0xd3, 0x85, 0xcc, 0x9d, 0x54, 0x36, 0x53, 0xc8, 0x1a,
	0x57, 0x3c, 0x9f, 0xb8, 0x26, 0x57, 0x10, 0x90, 0x90, 0x99, 0xb6, 0x77, 0x4a, 0x02, 0xb3, 0x81,
	0xfd, 0x7e, 0x44, 0xdb, 0xf7, 0x25, 0x42, 0xff, 0x75, 0x02, 0x16, 0xe5, 0x40, 0x22, 0x8a, 0xdf,
	0xc8, 0x3b, 0xfd, 0x99, 0xa5, 0x0d, 0x64, 0x56, 0x27, 0x49, 0x12, 0x5f, 0x6c, 0x92, 0x24, 0xcf,
	0x4b, 0x92, 0xa1, 0x71, 0x9f, 0x7a, 0x9a, 0xb8, 0x9f, 0x1e, 0x1e, 0xf7, 0xfa, 0x47, 0x1a, 0x2c,
	0x49, 0xff, 0xc4, 0x21, 0x3a, 0xa6, 0x39, 0x52, 0x85, 0x26, 0x31, 0xba, 0xd0, 0x24, 0x27, 0xe9,
	0x7e, 0x52, 0x23, 0xd2, 0x7b, 0x30, 0x09, 0xa7, 0x47, 0x1d, 0xb2, 0x3f, 0x4f, 0x8c, 0xb0, 0x7b,
	0xfd, 0x4b, 0x6b, 0x77, 0x7f, 0xf1, 0x48, 0x5f, 0xe6, 0xc1, 0xf2, 0x97, 0x51, 0xfe, 0xb8, 0xfd,
	0x95, 0xf3, 0xc7, 0x98, 0x62, 0x9a, 0x19, 0x53, 0x4c, 0x43, 0x58, 0x3c, 0x0c, 0x30, 0x07, 0x18,
	0xe4, 0x14, 0x07, 0x56, 0xd8, 0x99, 0x60, 0xce, 0x33, 0x89, 0x30, 0x03, 0x89, 0x51, 0xdf, 0x52,
	0xdc, 0x1a, 0x3b, 0x46, 0x50, 0x53, 0xfc, 0x1e, 0x99, 0xc6, 0x1c, 0xeb, 0x51, 0xa1, 0x7f, 0xa0,
	0x41, 0x69, 0x18, 0x21, 0x2a, 0xc1, 0xb4, 0x77, 0xea, 0x92, 0xe8, 0x7d, 0xb8, 0x7c, 0x40, 0x8f,
	0x60, 0xd6, 0x22, 0xae, 0xe7, 0x44, 0xe3, 0xf0, 0xc4, 0x25, 0x7f, 0x4f, 0x92, 0x13, 0xd2, 0xe5,
	0x64, 0x5d, 0xff, 0x91, 0x06, 0xcb, 0xf7, 0x7c, 0xe2, 0xd6, 0x54, 0x55, 0xed, 0x9d, 0xeb, 0x36,
	0x60, 0xb1, 0xbf, 0xe6, 0x76, 0x7f, 0x67, 0x32, 0xfe, 0x5d, 0xdc, 0xa0, 0x58, 0x63, 0xc1, 0x1b,
	0x80, 0x85, 0x22, 0xb2, 0x3f, 0xd4, 0x00, 0x0d, 0xd2, 0x4f, 0xf2, 0xa9, 0x8e, 0x03, 0xf9, 0x1e,
	0x13, 0x2f, 0xdd, 0x5d, 0xb3, 0xdd, 0x36, 0x0b, 0x63, 0x3f, 0x19, 0x77, 0x22, 0xaf, 0xff, 0x7f,
	0x9c, 0xc8, 0xe8, 0x65, 0x18, 0x75, 0x0e, 0xab, 0x37, 0x03, 0xa5, 0x6e, 0xbf, 0xec, 0x71, 0xe4,
	0x26, 0xf6, 0x07, 0xd9, 0xe2, 0x53, 0x5a, 0xbd, 0x03, 0x2d, 0xf5, 0x86, 0x80, 0x2f, 0xd8, 0xf4,
	0x1f, 0x6b, 0x50, 0x36, 0x48, 0x8b, 0x86, 0x8c, 0x04, 0x1b, 0xd1, 0x7b, 0xcc, 0x28, 0x0a, 0xd7,
	0x21, 0x13, 0x90, 0x26, 0x09, 0x88, 0x1c, 0x79, 0x8f, 0xf9, 0x5c, 0xc1, 0x88, 0x08, 0xd1, 0x2b,
	0x30, 0x13, 0xbf, 0x0f, 0x3d, 0xef, 0x23, 0x07, 0xa3, 0x43, 0xaa, 0xff, 0x41, 0x03, 0x24, 0xb7,
	0xf3, 0x01, 0xaf, 0x1e, 0x5d, 0x26, 0x44, 0xef, 0xf3, 0xce, 0x35, 0x41, 0x11, 0x4e, 0xd0, 0xd5,
	0x6f, 0xc7, 0xbd, 0x47, 0x52, 0x94, 0xc5, 0x17, 0xcf, 0x2f, 0x8b, 0xc2, 0xaa, 0xde, 0xc6, 0xa3,
	0x6a, 0x7c, 0xfc, 0xd9, 0x55, 0xed, 0x93, 0xcf, 0xae, 0x6a, 0xff, 0xf9, 0xec, 0xaa, 0xf6, 0xcb,
	0xcf, 0xaf, 0x4e, 0x7d, 0xf2, 0xf9, 0xd5, 0xa9, 0x7f, 0x7d, 0x7e, 0x75, 0xea, 0xe1, 0xab, 0x93,
	0x47, 0x7f, 0xef, 0x57, 0x88, 0x47, 0x69, 0x81, 0xb8, 0xfd, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xb9, 0xe4, 0xd5, 0xba, 0xab, 0x28, 0x00, 0x00,
}

func (m *FundingUpdateV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingUpdateV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingUpdateV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FundingIndex.Size()
		i -= size
		if _, err := m.FundingIndex.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.FundingValuePpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FundingValuePpm))
		i--
		dAtA[i] = 0x10
	}
	if m.PerpetualId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FundingEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MarketEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarketEventV1_PriceUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEventV1_PriceUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PriceUpdate != nil {
		{
			size, err := m.PriceUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MarketEventV1_MarketCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEventV1_MarketCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MarketCreate != nil {
		{
			size, err := m.MarketCreate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MarketEventV1_MarketModify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEventV1_MarketModify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MarketModify != nil {
		{
			size, err := m.MarketModify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MarketPriceUpdateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketPriceUpdateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketPriceUpdateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PriceWithExponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PriceWithExponent))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarketBaseEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketBaseEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketBaseEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinPriceChangePpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MinPriceChangePpm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Pair) > 0 {
		i -= len(m.Pair)
		copy(dAtA[i:], m.Pair)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Pair)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketCreateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketCreateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketCreateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.Exponent)<<1)^uint32((m.Exponent>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketModifyEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketModifyEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketModifyEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceOfFunds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceOfFunds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceOfFunds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		{
			size := m.Source.Size()
			i -= size
			if _, err := m.Source.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SourceOfFunds_SubaccountId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceOfFunds_SubaccountId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubaccountId != nil {
		{
			size, err := m.SubaccountId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SourceOfFunds_Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceOfFunds_Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Address)
	copy(dAtA[i:], m.Address)
	i = encodeVarintEvents(dAtA, i, uint64(len(m.Address)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *TransferEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Recipient != nil {
		{
			size, err := m.Recipient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Sender != nil {
		{
			size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Amount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x20
	}
	if m.AssetId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.AssetId))
		i--
		dAtA[i] = 0x18
	}
	if m.RecipientSubaccountId != nil {
		{
			size, err := m.RecipientSubaccountId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SenderSubaccountId != nil {
		{
			size, err := m.SenderSubaccountId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderFillEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFillEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerOrderRouterAddress) > 0 {
		i -= len(m.TakerOrderRouterAddress)
		copy(dAtA[i:], m.TakerOrderRouterAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TakerOrderRouterAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.MakerOrderRouterAddress) > 0 {
		i -= len(m.MakerOrderRouterAddress)
		copy(dAtA[i:], m.MakerOrderRouterAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MakerOrderRouterAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.TakerOrderRouterFee != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TakerOrderRouterFee))
		i--
		dAtA[i] = 0x78
	}
	if m.MakerOrderRouterFee != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MakerOrderRouterFee))
		i--
		dAtA[i] = 0x70
	}
	if len(m.TakerBuilderAddress) > 0 {
		i -= len(m.TakerBuilderAddress)
		copy(dAtA[i:], m.TakerBuilderAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TakerBuilderAddress)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.MakerBuilderAddress) > 0 {
		i -= len(m.MakerBuilderAddress)
		copy(dAtA[i:], m.MakerBuilderAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MakerBuilderAddress)))
		i--
		dAtA[i] = 0x62
	}
	if m.TakerBuilderFee != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TakerBuilderFee))
		i--
		dAtA[i] = 0x58
	}
	if m.MakerBuilderFee != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MakerBuilderFee))
		i--
		dAtA[i] = 0x50
	}
	if m.AffiliateRevShare != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.AffiliateRevShare))
		i--
		dAtA[i] = 0x48
	}
	if m.TotalFilledTaker != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TotalFilledTaker))
		i--
		dAtA[i] = 0x40
	}
	if m.TotalFilledMaker != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TotalFilledMaker))
		i--
		dAtA[i] = 0x38
	}
	if m.TakerFee != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint64(m.TakerFee)<<1)^uint64((m.TakerFee>>63))))
		i--
		dAtA[i] = 0x30
	}
	if m.MakerFee != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint64(m.MakerFee)<<1)^uint64((m.MakerFee>>63))))
		i--
		dAtA[i] = 0x28
	}
	if m.TakerOrder != nil {
		{
			size := m.TakerOrder.Size()
			i -= size
			if _, err := m.TakerOrder.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.FillAmount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FillAmount))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.MakerOrder.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OrderFillEventV1_Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEventV1_Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OrderFillEventV1_LiquidationOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEventV1_LiquidationOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LiquidationOrder != nil {
		{
			size, err := m.LiquidationOrder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DeleveragingEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleveragingEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleveragingEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFinalSettlement {
		i--
		if m.IsFinalSettlement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TotalQuoteQuantums != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TotalQuoteQuantums))
		i--
		dAtA[i] = 0x28
	}
	if m.FillAmount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FillAmount))
		i--
		dAtA[i] = 0x20
	}
	if m.PerpetualId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Offsetting.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Liquidated.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LiquidationOrderV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidationOrderV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidationOrderV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Subticks != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Subticks))
		i--
		dAtA[i] = 0x30
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TotalSize != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x20
	}
	if m.PerpetualId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x18
	}
	if m.ClobPairId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Liquidated.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubaccountUpdateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountUpdateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountUpdateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedAssetPositions) > 0 {
		for iNdEx := len(m.UpdatedAssetPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdatedAssetPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UpdatedPerpetualPositions) > 0 {
		for iNdEx := len(m.UpdatedPerpetualPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdatedPerpetualPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SubaccountId != nil {
		{
			size, err := m.SubaccountId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_OrderPlace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_OrderPlace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderPlace != nil {
		{
			size, err := m.OrderPlace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_OrderRemoval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_OrderRemoval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderRemoval != nil {
		{
			size, err := m.OrderRemoval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_ConditionalOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConditionalOrderPlacement != nil {
		{
			size, err := m.ConditionalOrderPlacement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggered) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_ConditionalOrderTriggered) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConditionalOrderTriggered != nil {
		{
			size, err := m.ConditionalOrderTriggered.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_LongTermOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_LongTermOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LongTermOrderPlacement != nil {
		{
			size, err := m.LongTermOrderPlacement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_OrderReplacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_OrderReplacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderReplacement != nil {
		{
			size, err := m.OrderReplacement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_TwapOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_TwapOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TwapOrderPlacement != nil {
		{
			size, err := m.TwapOrderPlacement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x10
	}
	if m.RemovedOrderId != nil {
		{
			size, err := m.RemovedOrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TriggeredOrderId != nil {
		{
			size, err := m.TriggeredOrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OldOrderId != nil {
		{
			size, err := m.OldOrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_TwapOrderPlacementV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_TwapOrderPlacementV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_TwapOrderPlacementV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AssetCreateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetCreateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetCreateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AtomicResolution != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x20
	}
	if m.HasMarket {
		i--
		if m.HasMarket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PerpetualMarketCreateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerpetualMarketCreateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerpetualMarketCreateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LiquidityTier != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.LiquidityTier))
		i--
		dAtA[i] = 0x50
	}
	if m.StepBaseQuantums != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.StepBaseQuantums))
		i--
		dAtA[i] = 0x48
	}
	if m.SubticksPerTick != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SubticksPerTick))
		i--
		dAtA[i] = 0x40
	}
	if m.AtomicResolution != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.QuantumConversionExponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.QuantumConversionExponent)<<1)^uint32((m.QuantumConversionExponent>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ClobPairId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PerpetualMarketCreateEventV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerpetualMarketCreateEventV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerpetualMarketCreateEventV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketType))
		i--
		dAtA[i] = 0x58
	}
	if m.LiquidityTier != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.LiquidityTier))
		i--
		dAtA[i] = 0x50
	}
	if m.StepBaseQuantums != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.StepBaseQuantums))
		i--
		dAtA[i] = 0x48
	}
	if m.SubticksPerTick != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SubticksPerTick))
		i--
		dAtA[i] = 0x40
	}
	if m.AtomicResolution != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.QuantumConversionExponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.QuantumConversionExponent)<<1)^uint32((m.QuantumConversionExponent>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ClobPairId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PerpetualMarketCreateEventV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerpetualMarketCreateEventV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerpetualMarketCreateEventV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultFunding8HrPpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.DefaultFunding8HrPpm))
		i--
		dAtA[i] = 0x60
	}
	if m.MarketType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketType))
		i--
		dAtA[i] = 0x58
	}
	if m.LiquidityTier != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.LiquidityTier))
		i--
		dAtA[i] = 0x50
	}
	if m.StepBaseQuantums != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.StepBaseQuantums))
		i--
		dAtA[i] = 0x48
	}
	if m.SubticksPerTick != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SubticksPerTick))
		i--
		dAtA[i] = 0x40
	}
	if m.AtomicResolution != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.QuantumConversionExponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.QuantumConversionExponent)<<1)^uint32((m.QuantumConversionExponent>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ClobPairId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityTierUpsertEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityTierUpsertEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityTierUpsertEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BasePositionNotional != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BasePositionNotional))
		i--
		dAtA[i] = 0x28
	}
	if m.MaintenanceFractionPpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MaintenanceFractionPpm))
		i--
		dAtA[i] = 0x20
	}
	if m.InitialMarginPpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.InitialMarginPpm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateClobPairEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateClobPairEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateClobPairEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StepBaseQuantums != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.StepBaseQuantums))
		i--
		dAtA[i] = 0x28
	}
	if m.SubticksPerTick != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SubticksPerTick))
		i--
		dAtA[i] = 0x20
	}
	if m.QuantumConversionExponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.QuantumConversionExponent)<<1)^uint32((m.QuantumConversionExponent>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.ClobPairId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdatePerpetualEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePerpetualEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdatePerpetualEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LiquidityTier != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.LiquidityTier))
		i--
		dAtA[i] = 0x28
	}
	if m.AtomicResolution != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdatePerpetualEventV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePerpetualEventV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdatePerpetualEventV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketType))
		i--
		dAtA[i] = 0x30
	}
	if m.LiquidityTier != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.LiquidityTier))
		i--
		dAtA[i] = 0x28
	}
	if m.AtomicResolution != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdatePerpetualEventV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePerpetualEventV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdatePerpetualEventV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultFunding8HrPpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.DefaultFunding8HrPpm))
		i--
		dAtA[i] = 0x38
	}
	if m.MarketType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketType))
		i--
		dAtA[i] = 0x30
	}
	if m.LiquidityTier != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.LiquidityTier))
		i--
		dAtA[i] = 0x28
	}
	if m.AtomicResolution != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TradingRewardsEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingRewardsEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingRewardsEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TradingRewards) > 0 {
		for iNdEx := len(m.TradingRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TradingRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddressTradingReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressTradingReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressTradingReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.DenomAmount.Size()
		i -= size
		if _, err := m.DenomAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenInterestUpdateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenInterestUpdateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenInterestUpdateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OpenInterestUpdates) > 0 {
		for iNdEx := len(m.OpenInterestUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OpenInterestUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OpenInterestUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenInterestUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenInterestUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.OpenInterest.Size()
		i -= size
		if _, err := m.OpenInterest.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PerpetualId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityTierUpsertEventV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityTierUpsertEventV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityTierUpsertEventV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OpenInterestUpperCap != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OpenInterestUpperCap))
		i--
		dAtA[i] = 0x38
	}
	if m.OpenInterestLowerCap != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OpenInterestLowerCap))
		i--
		dAtA[i] = 0x30
	}
	if m.BasePositionNotional != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BasePositionNotional))
		i--
		dAtA[i] = 0x28
	}
	if m.MaintenanceFractionPpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MaintenanceFractionPpm))
		i--
		dAtA[i] = 0x20
	}
	if m.InitialMarginPpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.InitialMarginPpm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterAffiliateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterAffiliateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterAffiliateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Affiliate) > 0 {
		i -= len(m.Affiliate)
		copy(dAtA[i:], m.Affiliate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Affiliate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Referee) > 0 {
		i -= len(m.Referee)
		copy(dAtA[i:], m.Referee)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Referee)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpsertVaultEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertVaultEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertVaultEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.ClobPairId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FundingUpdateV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerpetualId != 0 {
		n += 1 + sovEvents(uint64(m.PerpetualId))
	}
	if m.FundingValuePpm != 0 {
		n += 1 + sovEvents(uint64(m.FundingValuePpm))
	}
	l = m.FundingIndex.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *FundingEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovEvents(uint64(m.Type))
	}
	return n
}

func (m *MarketEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *MarketEventV1_PriceUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceUpdate != nil {
		l = m.PriceUpdate.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketEventV1_MarketCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketCreate != nil {
		l = m.MarketCreate.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketEventV1_MarketModify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketModify != nil {
		l = m.MarketModify.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketPriceUpdateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceWithExponent != 0 {
		n += 1 + sovEvents(uint64(m.PriceWithExponent))
	}
	return n
}

func (m *MarketBaseEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pair)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MinPriceChangePpm != 0 {
		n += 1 + sovEvents(uint64(m.MinPriceChangePpm))
	}
	return n
}

func (m *MarketCreateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sozEvents(uint64(m.Exponent))
	}
	return n
}

func (m *MarketModifyEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *SourceOfFunds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		n += m.Source.Size()
	}
	return n
}

func (m *SourceOfFunds_SubaccountId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubaccountId != nil {
		l = m.SubaccountId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *SourceOfFunds_Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovEvents(uint64(l))
	return n
}
func (m *TransferEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderSubaccountId != nil {
		l = m.SenderSubaccountId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RecipientSubaccountId != nil {
		l = m.RecipientSubaccountId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.AssetId != 0 {
		n += 1 + sovEvents(uint64(m.AssetId))
	}
	if m.Amount != 0 {
		n += 1 + sovEvents(uint64(m.Amount))
	}
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Recipient != nil {
		l = m.Recipient.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *OrderFillEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MakerOrder.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.TakerOrder != nil {
		n += m.TakerOrder.Size()
	}
	if m.FillAmount != 0 {
		n += 1 + sovEvents(uint64(m.FillAmount))
	}
	if m.MakerFee != 0 {
		n += 1 + sozEvents(uint64(m.MakerFee))
	}
	if m.TakerFee != 0 {
		n += 1 + sozEvents(uint64(m.TakerFee))
	}
	if m.TotalFilledMaker != 0 {
		n += 1 + sovEvents(uint64(m.TotalFilledMaker))
	}
	if m.TotalFilledTaker != 0 {
		n += 1 + sovEvents(uint64(m.TotalFilledTaker))
	}
	if m.AffiliateRevShare != 0 {
		n += 1 + sovEvents(uint64(m.AffiliateRevShare))
	}
	if m.MakerBuilderFee != 0 {
		n += 1 + sovEvents(uint64(m.MakerBuilderFee))
	}
	if m.TakerBuilderFee != 0 {
		n += 1 + sovEvents(uint64(m.TakerBuilderFee))
	}
	l = len(m.MakerBuilderAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TakerBuilderAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MakerOrderRouterFee != 0 {
		n += 1 + sovEvents(uint64(m.MakerOrderRouterFee))
	}
	if m.TakerOrderRouterFee != 0 {
		n += 1 + sovEvents(uint64(m.TakerOrderRouterFee))
	}
	l = len(m.MakerOrderRouterAddress)
	if l > 0 {
		n += 2 + l + sovEvents(uint64(l))
	}
	l = len(m.TakerOrderRouterAddress)
	if l > 0 {
		n += 2 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *OrderFillEventV1_Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *OrderFillEventV1_LiquidationOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiquidationOrder != nil {
		l = m.LiquidationOrder.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *DeleveragingEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Liquidated.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Offsetting.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.PerpetualId != 0 {
		n += 1 + sovEvents(uint64(m.PerpetualId))
	}
	if m.FillAmount != 0 {
		n += 1 + sovEvents(uint64(m.FillAmount))
	}
	if m.TotalQuoteQuantums != 0 {
		n += 1 + sovEvents(uint64(m.TotalQuoteQuantums))
	}
	if m.IsBuy {
		n += 2
	}
	if m.IsFinalSettlement {
		n += 2
	}
	return n
}

func (m *LiquidationOrderV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Liquidated.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.ClobPairId != 0 {
		n += 1 + sovEvents(uint64(m.ClobPairId))
	}
	if m.PerpetualId != 0 {
		n += 1 + sovEvents(uint64(m.PerpetualId))
	}
	if m.TotalSize != 0 {
		n += 1 + sovEvents(uint64(m.TotalSize))
	}
	if m.IsBuy {
		n += 2
	}
	if m.Subticks != 0 {
		n += 1 + sovEvents(uint64(m.Subticks))
	}
	return n
}

func (m *SubaccountUpdateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubaccountId != nil {
		l = m.SubaccountId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.UpdatedPerpetualPositions) > 0 {
		for _, e := range m.UpdatedPerpetualPositions {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.UpdatedAssetPositions) > 0 {
		for _, e := range m.UpdatedAssetPositions {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *StatefulOrderEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *StatefulOrderEventV1_OrderPlace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderPlace != nil {
		l = m.OrderPlace.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_OrderRemoval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderRemoval != nil {
		l = m.OrderRemoval.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionalOrderPlacement != nil {
		l = m.ConditionalOrderPlacement.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggered) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionalOrderTriggered != nil {
		l = m.ConditionalOrderTriggered.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_LongTermOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LongTermOrderPlacement != nil {
		l = m.LongTermOrderPlacement.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_OrderReplacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderReplacement != nil {
		l = m.OrderReplacement.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_TwapOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TwapOrderPlacement != nil {
		l = m.TwapOrderPlacement.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemovedOrderId != nil {
		l = m.RemovedOrderId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovEvents(uint64(m.Reason))
	}
	return n
}

func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggeredOrderId != nil {
		l = m.TriggeredOrderId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OldOrderId != nil {
		l = m.OldOrderId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEventV1_TwapOrderPlacementV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *AssetCreateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.HasMarket {
		n += 2
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozEvents(uint64(m.AtomicResolution))
	}
	return n
}

func (m *PerpetualMarketCreateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	if m.ClobPairId != 0 {
		n += 1 + sovEvents(uint64(m.ClobPairId))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	if m.QuantumConversionExponent != 0 {
		n += 1 + sozEvents(uint64(m.QuantumConversionExponent))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozEvents(uint64(m.AtomicResolution))
	}
	if m.SubticksPerTick != 0 {
		n += 1 + sovEvents(uint64(m.SubticksPerTick))
	}
	if m.StepBaseQuantums != 0 {
		n += 1 + sovEvents(uint64(m.StepBaseQuantums))
	}
	if m.LiquidityTier != 0 {
		n += 1 + sovEvents(uint64(m.LiquidityTier))
	}
	return n
}

func (m *PerpetualMarketCreateEventV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	if m.ClobPairId != 0 {
		n += 1 + sovEvents(uint64(m.ClobPairId))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	if m.QuantumConversionExponent != 0 {
		n += 1 + sozEvents(uint64(m.QuantumConversionExponent))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozEvents(uint64(m.AtomicResolution))
	}
	if m.SubticksPerTick != 0 {
		n += 1 + sovEvents(uint64(m.SubticksPerTick))
	}
	if m.StepBaseQuantums != 0 {
		n += 1 + sovEvents(uint64(m.StepBaseQuantums))
	}
	if m.LiquidityTier != 0 {
		n += 1 + sovEvents(uint64(m.LiquidityTier))
	}
	if m.MarketType != 0 {
		n += 1 + sovEvents(uint64(m.MarketType))
	}
	return n
}

func (m *PerpetualMarketCreateEventV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	if m.ClobPairId != 0 {
		n += 1 + sovEvents(uint64(m.ClobPairId))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	if m.QuantumConversionExponent != 0 {
		n += 1 + sozEvents(uint64(m.QuantumConversionExponent))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozEvents(uint64(m.AtomicResolution))
	}
	if m.SubticksPerTick != 0 {
		n += 1 + sovEvents(uint64(m.SubticksPerTick))
	}
	if m.StepBaseQuantums != 0 {
		n += 1 + sovEvents(uint64(m.StepBaseQuantums))
	}
	if m.LiquidityTier != 0 {
		n += 1 + sovEvents(uint64(m.LiquidityTier))
	}
	if m.MarketType != 0 {
		n += 1 + sovEvents(uint64(m.MarketType))
	}
	if m.DefaultFunding8HrPpm != 0 {
		n += 1 + sovEvents(uint64(m.DefaultFunding8HrPpm))
	}
	return n
}

func (m *LiquidityTierUpsertEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.InitialMarginPpm != 0 {
		n += 1 + sovEvents(uint64(m.InitialMarginPpm))
	}
	if m.MaintenanceFractionPpm != 0 {
		n += 1 + sovEvents(uint64(m.MaintenanceFractionPpm))
	}
	if m.BasePositionNotional != 0 {
		n += 1 + sovEvents(uint64(m.BasePositionNotional))
	}
	return n
}

func (m *UpdateClobPairEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClobPairId != 0 {
		n += 1 + sovEvents(uint64(m.ClobPairId))
	}
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	if m.QuantumConversionExponent != 0 {
		n += 1 + sozEvents(uint64(m.QuantumConversionExponent))
	}
	if m.SubticksPerTick != 0 {
		n += 1 + sovEvents(uint64(m.SubticksPerTick))
	}
	if m.StepBaseQuantums != 0 {
		n += 1 + sovEvents(uint64(m.StepBaseQuantums))
	}
	return n
}

func (m *UpdatePerpetualEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozEvents(uint64(m.AtomicResolution))
	}
	if m.LiquidityTier != 0 {
		n += 1 + sovEvents(uint64(m.LiquidityTier))
	}
	return n
}

func (m *UpdatePerpetualEventV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozEvents(uint64(m.AtomicResolution))
	}
	if m.LiquidityTier != 0 {
		n += 1 + sovEvents(uint64(m.LiquidityTier))
	}
	if m.MarketType != 0 {
		n += 1 + sovEvents(uint64(m.MarketType))
	}
	return n
}

func (m *UpdatePerpetualEventV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozEvents(uint64(m.AtomicResolution))
	}
	if m.LiquidityTier != 0 {
		n += 1 + sovEvents(uint64(m.LiquidityTier))
	}
	if m.MarketType != 0 {
		n += 1 + sovEvents(uint64(m.MarketType))
	}
	if m.DefaultFunding8HrPpm != 0 {
		n += 1 + sovEvents(uint64(m.DefaultFunding8HrPpm))
	}
	return n
}

func (m *TradingRewardsEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TradingRewards) > 0 {
		for _, e := range m.TradingRewards {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *AddressTradingReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.DenomAmount.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *OpenInterestUpdateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OpenInterestUpdates) > 0 {
		for _, e := range m.OpenInterestUpdates {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *OpenInterestUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerpetualId != 0 {
		n += 1 + sovEvents(uint64(m.PerpetualId))
	}
	l = m.OpenInterest.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *LiquidityTierUpsertEventV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.InitialMarginPpm != 0 {
		n += 1 + sovEvents(uint64(m.InitialMarginPpm))
	}
	if m.MaintenanceFractionPpm != 0 {
		n += 1 + sovEvents(uint64(m.MaintenanceFractionPpm))
	}
	if m.BasePositionNotional != 0 {
		n += 1 + sovEvents(uint64(m.BasePositionNotional))
	}
	if m.OpenInterestLowerCap != 0 {
		n += 1 + sovEvents(uint64(m.OpenInterestLowerCap))
	}
	if m.OpenInterestUpperCap != 0 {
		n += 1 + sovEvents(uint64(m.OpenInterestUpperCap))
	}
	return n
}

func (m *RegisterAffiliateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Referee)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Affiliate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *UpsertVaultEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ClobPairId != 0 {
		n += 1 + sovEvents(uint64(m.ClobPairId))
	}
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FundingUpdateV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingUpdateV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingUpdateV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingValuePpm", wireType)
			}
			m.FundingValuePpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FundingValuePpm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundingIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, FundingUpdateV1{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FundingEventV1_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketPriceUpdateEventV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEventV1_PriceUpdate{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketCreateEventV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEventV1_MarketCreate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketModify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketModifyEventV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEventV1_MarketModify{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketPriceUpdateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketPriceUpdateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketPriceUpdateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceWithExponent", wireType)
			}
			m.PriceWithExponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceWithExponent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketBaseEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketBaseEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketBaseEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pair = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceChangePpm", wireType)
			}
			m.MinPriceChangePpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinPriceChangePpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketCreateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketCreateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketCreateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &MarketBaseEventV1{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exponent = v
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketModifyEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketModifyEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketModifyEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &MarketBaseEventV1{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceOfFunds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceOfFunds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceOfFunds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.IndexerSubaccountId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &SourceOfFunds_SubaccountId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = &SourceOfFunds_Address{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderSubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SenderSubaccountId == nil {
				m.SenderSubaccountId = &types.IndexerSubaccountId{}
			}
			if err := m.SenderSubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientSubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecipientSubaccountId == nil {
				m.RecipientSubaccountId = &types.IndexerSubaccountId{}
			}
			if err := m.RecipientSubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			m.AssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &SourceOfFunds{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recipient == nil {
				m.Recipient = &SourceOfFunds{}
			}
			if err := m.Recipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFillEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFillEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFillEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.IndexerOrder{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TakerOrder = &OrderFillEventV1_Order{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillAmount", wireType)
			}
			m.FillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LiquidationOrderV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TakerOrder = &OrderFillEventV1_LiquidationOrder{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFee", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MakerFee = int64(v)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.TakerFee = int64(v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFilledMaker", wireType)
			}
			m.TotalFilledMaker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFilledMaker |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFilledTaker", wireType)
			}
			m.TotalFilledTaker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFilledTaker |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateRevShare", wireType)
			}
			m.AffiliateRevShare = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffiliateRevShare |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerBuilderFee", wireType)
			}
			m.MakerBuilderFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MakerBuilderFee |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerBuilderFee", wireType)
			}
			m.TakerBuilderFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TakerBuilderFee |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerBuilderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerBuilderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerBuilderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerBuilderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerOrderRouterFee", wireType)
			}
			m.MakerOrderRouterFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MakerOrderRouterFee |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerOrderRouterFee", wireType)
			}
			m.TakerOrderRouterFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TakerOrderRouterFee |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerOrderRouterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerOrderRouterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerOrderRouterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerOrderRouterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleveragingEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleveragingEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleveragingEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Liquidated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsetting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offsetting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillAmount", wireType)
			}
			m.FillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalQuoteQuantums", wireType)
			}
			m.TotalQuoteQuantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalQuoteQuantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinalSettlement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFinalSettlement = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidationOrderV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidationOrderV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidationOrderV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Liquidated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subticks", wireType)
			}
			m.Subticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subticks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountUpdateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountUpdateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountUpdateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubaccountId == nil {
				m.SubaccountId = &types.IndexerSubaccountId{}
			}
			if err := m.SubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedPerpetualPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedPerpetualPositions = append(m.UpdatedPerpetualPositions, &types.IndexerPerpetualPosition{})
			if err := m.UpdatedPerpetualPositions[len(m.UpdatedPerpetualPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAssetPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAssetPositions = append(m.UpdatedAssetPositions, &types.IndexerAssetPosition{})
			if err := m.UpdatedAssetPositions[len(m.UpdatedAssetPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderPlace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_StatefulOrderPlacementV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_OrderPlace{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRemoval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_StatefulOrderRemovalV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_OrderRemoval{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalOrderPlacement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_ConditionalOrderPlacementV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_ConditionalOrderPlacement{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalOrderTriggered", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_ConditionalOrderTriggeredV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_ConditionalOrderTriggered{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTermOrderPlacement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_LongTermOrderPlacementV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_LongTermOrderPlacement{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderReplacement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_LongTermOrderReplacementV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_OrderReplacement{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwapOrderPlacement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_TwapOrderPlacementV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_TwapOrderPlacement{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderPlacementV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderPlacementV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &types.IndexerOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_StatefulOrderRemovalV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderRemovalV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderRemovalV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovedOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemovedOrderId == nil {
				m.RemovedOrderId = &types.IndexerOrderId{}
			}
			if err := m.RemovedOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= types1.OrderRemovalReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_ConditionalOrderPlacementV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalOrderPlacementV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalOrderPlacementV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &types.IndexerOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_ConditionalOrderTriggeredV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalOrderTriggeredV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalOrderTriggeredV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggeredOrderId == nil {
				m.TriggeredOrderId = &types.IndexerOrderId{}
			}
			if err := m.TriggeredOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_LongTermOrderPlacementV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongTermOrderPlacementV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongTermOrderPlacementV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &types.IndexerOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_LongTermOrderReplacementV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongTermOrderReplacementV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongTermOrderReplacementV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldOrderId == nil {
				m.OldOrderId = &types.IndexerOrderId{}
			}
			if err := m.OldOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &types.IndexerOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_TwapOrderPlacementV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TwapOrderPlacementV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TwapOrderPlacementV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &types.IndexerOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetCreateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetCreateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetCreateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMarket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMarket = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerpetualMarketCreateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerpetualMarketCreateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerpetualMarketCreateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.ClobPairStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantumConversionExponent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.QuantumConversionExponent = v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubticksPerTick", wireType)
			}
			m.SubticksPerTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubticksPerTick |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepBaseQuantums", wireType)
			}
			m.StepBaseQuantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepBaseQuantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityTier", wireType)
			}
			m.LiquidityTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityTier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerpetualMarketCreateEventV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerpetualMarketCreateEventV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerpetualMarketCreateEventV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.ClobPairStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantumConversionExponent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.QuantumConversionExponent = v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubticksPerTick", wireType)
			}
			m.SubticksPerTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubticksPerTick |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepBaseQuantums", wireType)
			}
			m.StepBaseQuantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepBaseQuantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityTier", wireType)
			}
			m.LiquidityTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityTier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketType", wireType)
			}
			m.MarketType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketType |= types.PerpetualMarketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerpetualMarketCreateEventV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerpetualMarketCreateEventV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerpetualMarketCreateEventV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.ClobPairStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantumConversionExponent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.QuantumConversionExponent = v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubticksPerTick", wireType)
			}
			m.SubticksPerTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubticksPerTick |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepBaseQuantums", wireType)
			}
			m.StepBaseQuantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepBaseQuantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityTier", wireType)
			}
			m.LiquidityTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityTier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketType", wireType)
			}
			m.MarketType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketType |= types.PerpetualMarketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFunding8HrPpm", wireType)
			}
			m.DefaultFunding8HrPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFunding8HrPpm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityTierUpsertEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityTierUpsertEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityTierUpsertEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginPpm", wireType)
			}
			m.InitialMarginPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialMarginPpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceFractionPpm", wireType)
			}
			m.MaintenanceFractionPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceFractionPpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePositionNotional", wireType)
			}
			m.BasePositionNotional = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasePositionNotional |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateClobPairEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateClobPairEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateClobPairEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.ClobPairStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantumConversionExponent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.QuantumConversionExponent = v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubticksPerTick", wireType)
			}
			m.SubticksPerTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubticksPerTick |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepBaseQuantums", wireType)
			}
			m.StepBaseQuantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepBaseQuantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePerpetualEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePerpetualEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePerpetualEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityTier", wireType)
			}
			m.LiquidityTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityTier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePerpetualEventV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePerpetualEventV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePerpetualEventV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityTier", wireType)
			}
			m.LiquidityTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityTier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketType", wireType)
			}
			m.MarketType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketType |= types.PerpetualMarketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePerpetualEventV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePerpetualEventV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePerpetualEventV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityTier", wireType)
			}
			m.LiquidityTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityTier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketType", wireType)
			}
			m.MarketType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketType |= types.PerpetualMarketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFunding8HrPpm", wireType)
			}
			m.DefaultFunding8HrPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFunding8HrPpm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingRewardsEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingRewardsEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingRewardsEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradingRewards = append(m.TradingRewards, &AddressTradingReward{})
			if err := m.TradingRewards[len(m.TradingRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressTradingReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressTradingReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressTradingReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomAmount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DenomAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenInterestUpdateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenInterestUpdateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenInterestUpdateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenInterestUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenInterestUpdates = append(m.OpenInterestUpdates, &OpenInterestUpdate{})
			if err := m.OpenInterestUpdates[len(m.OpenInterestUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenInterestUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenInterestUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenInterestUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenInterest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OpenInterest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityTierUpsertEventV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityTierUpsertEventV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityTierUpsertEventV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginPpm", wireType)
			}
			m.InitialMarginPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialMarginPpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceFractionPpm", wireType)
			}
			m.MaintenanceFractionPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceFractionPpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePositionNotional", wireType)
			}
			m.BasePositionNotional = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasePositionNotional |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenInterestLowerCap", wireType)
			}
			m.OpenInterestLowerCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenInterestLowerCap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenInterestUpperCap", wireType)
			}
			m.OpenInterestUpperCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenInterestUpperCap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterAffiliateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterAffiliateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterAffiliateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Referee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affiliate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Affiliate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertVaultEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertVaultEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertVaultEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.VaultStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
