// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/indexer/events/events.proto

package events

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_dydxprotocol_v4_dtypes "github.com/dydxprotocol/v4/dtypes"
	v1 "github.com/dydxprotocol/v4/indexer/protocol/v1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Type is the type for funding values.
type FundingEventV1_Type int32

const (
	// Unspecified type.
	FundingEventV1_TYPE_UNSPECIFIED FundingEventV1_Type = 0
	// Premium sample is the combined value from all premium votes during a
	// `funding-sample` epoch.
	FundingEventV1_TYPE_PREMIUM_SAMPLE FundingEventV1_Type = 1
	// Funding rate is the final funding rate combining all premium samples
	// during a `funding-tick` epoch.
	FundingEventV1_TYPE_FUNDING_RATE_AND_INDEX FundingEventV1_Type = 2
	// TODO(DEC-1513): Investigate whether premium vote values need to be
	// sent to indexer.
	FundingEventV1_TYPE_PREMIUM_VOTE FundingEventV1_Type = 3
)

var FundingEventV1_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "TYPE_PREMIUM_SAMPLE",
	2: "TYPE_FUNDING_RATE_AND_INDEX",
	3: "TYPE_PREMIUM_VOTE",
}

var FundingEventV1_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED":            0,
	"TYPE_PREMIUM_SAMPLE":         1,
	"TYPE_FUNDING_RATE_AND_INDEX": 2,
	"TYPE_PREMIUM_VOTE":           3,
}

func (x FundingEventV1_Type) String() string {
	return proto.EnumName(FundingEventV1_Type_name, int32(x))
}

func (FundingEventV1_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{1, 0}
}

// FundingUpdate is used for funding update events and includes a funding
// value and an optional funding index that correspond to a perpetual market.
type FundingUpdateV1 struct {
	// The id of the perpetual market.
	PerpetualId uint32 `protobuf:"varint,1,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// funding value (in parts-per-million) can be premium vote, premium sample,
	// or funding rate.
	FundingValuePpm int32 `protobuf:"varint,2,opt,name=funding_value_ppm,json=fundingValuePpm,proto3" json:"funding_value_ppm,omitempty"`
	// funding index is required if and only if parent `FundingEvent` type is
	// `TYPE_FUNDING_RATE_AND_INDEX`.
	FundingIndex github_com_dydxprotocol_v4_dtypes.SerializableInt `protobuf:"bytes,3,opt,name=funding_index,json=fundingIndex,proto3,customtype=github.com/dydxprotocol/v4/dtypes.SerializableInt" json:"funding_index"`
}

func (m *FundingUpdateV1) Reset()         { *m = FundingUpdateV1{} }
func (m *FundingUpdateV1) String() string { return proto.CompactTextString(m) }
func (*FundingUpdateV1) ProtoMessage()    {}
func (*FundingUpdateV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{0}
}
func (m *FundingUpdateV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingUpdateV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingUpdateV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingUpdateV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingUpdateV1.Merge(m, src)
}
func (m *FundingUpdateV1) XXX_Size() int {
	return m.Size()
}
func (m *FundingUpdateV1) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingUpdateV1.DiscardUnknown(m)
}

var xxx_messageInfo_FundingUpdateV1 proto.InternalMessageInfo

func (m *FundingUpdateV1) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *FundingUpdateV1) GetFundingValuePpm() int32 {
	if m != nil {
		return m.FundingValuePpm
	}
	return 0
}

// FundingEvent message contains a list of per-market funding values. The
// funding values in the list is of the same type and the types are: which can
// have one of the following types:
//  1. Premium vote: votes on the premium values injected by block proposers.
//  2. Premium sample: combined value from all premium votes during a
//     `funding-sample` epoch.
//  3. Funding rate and index: final funding rate combining all premium samples
//     during a `funding-tick` epoch and funding index accordingly updated with
//     `funding rate * price`.
type FundingEventV1 struct {
	// updates is a list of per-market funding updates for all existing perpetual
	// markets. The list is sorted by `perpetualId`s which are unique.
	Updates []FundingUpdateV1 `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates"`
	// type stores the type of funding updates.
	Type FundingEventV1_Type `protobuf:"varint,2,opt,name=type,proto3,enum=dydxprotocol.indexer.events.FundingEventV1_Type" json:"type,omitempty"`
}

func (m *FundingEventV1) Reset()         { *m = FundingEventV1{} }
func (m *FundingEventV1) String() string { return proto.CompactTextString(m) }
func (*FundingEventV1) ProtoMessage()    {}
func (*FundingEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{1}
}
func (m *FundingEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingEventV1.Merge(m, src)
}
func (m *FundingEventV1) XXX_Size() int {
	return m.Size()
}
func (m *FundingEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_FundingEventV1 proto.InternalMessageInfo

func (m *FundingEventV1) GetUpdates() []FundingUpdateV1 {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *FundingEventV1) GetType() FundingEventV1_Type {
	if m != nil {
		return m.Type
	}
	return FundingEventV1_TYPE_UNSPECIFIED
}

// MarketEvent message contains all the information about a market event on
// the V4 chain.
type MarketEventV1 struct {
	// market id.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// either an event for price update, market creation, or market modification.
	//
	// Types that are valid to be assigned to Event:
	//	*MarketEventV1_PriceUpdate
	//	*MarketEventV1_MarketCreate
	//	*MarketEventV1_MarketModify
	Event isMarketEventV1_Event `protobuf_oneof:"event"`
}

func (m *MarketEventV1) Reset()         { *m = MarketEventV1{} }
func (m *MarketEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketEventV1) ProtoMessage()    {}
func (*MarketEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{2}
}
func (m *MarketEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketEventV1.Merge(m, src)
}
func (m *MarketEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketEventV1 proto.InternalMessageInfo

type isMarketEventV1_Event interface {
	isMarketEventV1_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MarketEventV1_PriceUpdate struct {
	PriceUpdate *MarketPriceUpdateEventV1 `protobuf:"bytes,2,opt,name=price_update,json=priceUpdate,proto3,oneof" json:"price_update,omitempty"`
}
type MarketEventV1_MarketCreate struct {
	MarketCreate *MarketCreateEventV1 `protobuf:"bytes,3,opt,name=market_create,json=marketCreate,proto3,oneof" json:"market_create,omitempty"`
}
type MarketEventV1_MarketModify struct {
	MarketModify *MarketModifyEventV1 `protobuf:"bytes,4,opt,name=market_modify,json=marketModify,proto3,oneof" json:"market_modify,omitempty"`
}

func (*MarketEventV1_PriceUpdate) isMarketEventV1_Event()  {}
func (*MarketEventV1_MarketCreate) isMarketEventV1_Event() {}
func (*MarketEventV1_MarketModify) isMarketEventV1_Event() {}

func (m *MarketEventV1) GetEvent() isMarketEventV1_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *MarketEventV1) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *MarketEventV1) GetPriceUpdate() *MarketPriceUpdateEventV1 {
	if x, ok := m.GetEvent().(*MarketEventV1_PriceUpdate); ok {
		return x.PriceUpdate
	}
	return nil
}

func (m *MarketEventV1) GetMarketCreate() *MarketCreateEventV1 {
	if x, ok := m.GetEvent().(*MarketEventV1_MarketCreate); ok {
		return x.MarketCreate
	}
	return nil
}

func (m *MarketEventV1) GetMarketModify() *MarketModifyEventV1 {
	if x, ok := m.GetEvent().(*MarketEventV1_MarketModify); ok {
		return x.MarketModify
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MarketEventV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MarketEventV1_PriceUpdate)(nil),
		(*MarketEventV1_MarketCreate)(nil),
		(*MarketEventV1_MarketModify)(nil),
	}
}

// MarketPriceUpdateEvent message contains all the information about a price
// update on the V4 chain.
type MarketPriceUpdateEventV1 struct {
	// price_with_exponent. Multiply by 10 ^ Exponent to get the human readable
	// price in dollars. For example if `Exponent == -5` then a `exponent_price`
	// of `1,000,000,000` represents â€œ$10,000`.
	PriceWithExponent uint64 `protobuf:"varint,1,opt,name=price_with_exponent,json=priceWithExponent,proto3" json:"price_with_exponent,omitempty"`
}

func (m *MarketPriceUpdateEventV1) Reset()         { *m = MarketPriceUpdateEventV1{} }
func (m *MarketPriceUpdateEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketPriceUpdateEventV1) ProtoMessage()    {}
func (*MarketPriceUpdateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{3}
}
func (m *MarketPriceUpdateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketPriceUpdateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketPriceUpdateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketPriceUpdateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketPriceUpdateEventV1.Merge(m, src)
}
func (m *MarketPriceUpdateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketPriceUpdateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketPriceUpdateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketPriceUpdateEventV1 proto.InternalMessageInfo

func (m *MarketPriceUpdateEventV1) GetPriceWithExponent() uint64 {
	if m != nil {
		return m.PriceWithExponent
	}
	return 0
}

// shared fields between MarketCreateEvent and MarketModifyEvent
type MarketBaseEventV1 struct {
	// String representation of the market pair, e.g. `BTC-USD`
	Pair string `protobuf:"bytes,1,opt,name=pair,proto3" json:"pair,omitempty"`
	// The minimum allowable change in the Price value for a given update.
	// Measured as 1e-6.
	MinPriceChangePpm uint32 `protobuf:"varint,2,opt,name=min_price_change_ppm,json=minPriceChangePpm,proto3" json:"min_price_change_ppm,omitempty"`
}

func (m *MarketBaseEventV1) Reset()         { *m = MarketBaseEventV1{} }
func (m *MarketBaseEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketBaseEventV1) ProtoMessage()    {}
func (*MarketBaseEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{4}
}
func (m *MarketBaseEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketBaseEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketBaseEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketBaseEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketBaseEventV1.Merge(m, src)
}
func (m *MarketBaseEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketBaseEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketBaseEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketBaseEventV1 proto.InternalMessageInfo

func (m *MarketBaseEventV1) GetPair() string {
	if m != nil {
		return m.Pair
	}
	return ""
}

func (m *MarketBaseEventV1) GetMinPriceChangePpm() uint32 {
	if m != nil {
		return m.MinPriceChangePpm
	}
	return 0
}

// MarketCreateEvent message contains all the information about a new market on
// the V4 chain.
type MarketCreateEventV1 struct {
	Base *MarketBaseEventV1 `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	// Static value. The exponent of the price.
	// For example if Exponent == -5 then a `exponent_price` of 1,000,000,000
	// represents $10,000. Therefore 10 ^ Exponent represents the smallest
	// price step (in dollars) that can be recorded.
	Exponent int32 `protobuf:"zigzag32,2,opt,name=exponent,proto3" json:"exponent,omitempty"`
}

func (m *MarketCreateEventV1) Reset()         { *m = MarketCreateEventV1{} }
func (m *MarketCreateEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketCreateEventV1) ProtoMessage()    {}
func (*MarketCreateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{5}
}
func (m *MarketCreateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketCreateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketCreateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketCreateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketCreateEventV1.Merge(m, src)
}
func (m *MarketCreateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketCreateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketCreateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketCreateEventV1 proto.InternalMessageInfo

func (m *MarketCreateEventV1) GetBase() *MarketBaseEventV1 {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *MarketCreateEventV1) GetExponent() int32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

// MarketModifyEvent message contains all the information about a market update
// on the V4 chain
type MarketModifyEventV1 struct {
	Base *MarketBaseEventV1 `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
}

func (m *MarketModifyEventV1) Reset()         { *m = MarketModifyEventV1{} }
func (m *MarketModifyEventV1) String() string { return proto.CompactTextString(m) }
func (*MarketModifyEventV1) ProtoMessage()    {}
func (*MarketModifyEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{6}
}
func (m *MarketModifyEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketModifyEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketModifyEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketModifyEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketModifyEventV1.Merge(m, src)
}
func (m *MarketModifyEventV1) XXX_Size() int {
	return m.Size()
}
func (m *MarketModifyEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketModifyEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_MarketModifyEventV1 proto.InternalMessageInfo

func (m *MarketModifyEventV1) GetBase() *MarketBaseEventV1 {
	if m != nil {
		return m.Base
	}
	return nil
}

// TransferEvent message contains all the information about a transfer on
// the V4 chain. A transfer also produces 2 separate SubaccountUpdateEvent
// messages, 1 for recipient and 1 for sender, with the updated asset
// positions.
type TransferEventV1 struct {
	// The sender subaccount ID.
	SenderSubaccountId v1.IndexerSubaccountId `protobuf:"bytes,1,opt,name=sender_subaccount_id,json=senderSubaccountId,proto3" json:"sender_subaccount_id"`
	// The recipient subaccount ID.
	RecipientSubaccountId v1.IndexerSubaccountId `protobuf:"bytes,2,opt,name=recipient_subaccount_id,json=recipientSubaccountId,proto3" json:"recipient_subaccount_id"`
	// Id of the asset transfered.
	AssetId uint32 `protobuf:"varint,3,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The amount of asset in quantums to transfer.
	Amount uint64 `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *TransferEventV1) Reset()         { *m = TransferEventV1{} }
func (m *TransferEventV1) String() string { return proto.CompactTextString(m) }
func (*TransferEventV1) ProtoMessage()    {}
func (*TransferEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{7}
}
func (m *TransferEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferEventV1.Merge(m, src)
}
func (m *TransferEventV1) XXX_Size() int {
	return m.Size()
}
func (m *TransferEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_TransferEventV1 proto.InternalMessageInfo

func (m *TransferEventV1) GetSenderSubaccountId() v1.IndexerSubaccountId {
	if m != nil {
		return m.SenderSubaccountId
	}
	return v1.IndexerSubaccountId{}
}

func (m *TransferEventV1) GetRecipientSubaccountId() v1.IndexerSubaccountId {
	if m != nil {
		return m.RecipientSubaccountId
	}
	return v1.IndexerSubaccountId{}
}

func (m *TransferEventV1) GetAssetId() uint32 {
	if m != nil {
		return m.AssetId
	}
	return 0
}

func (m *TransferEventV1) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// OrderFillEvent message contains all the information from an order match in
// the V4 chain. This includes the maker/taker orders that matched and the
// amount filled.
type OrderFillEventV1 struct {
	MakerOrder v1.IndexerOrder `protobuf:"bytes,1,opt,name=maker_order,json=makerOrder,proto3" json:"maker_order"`
	// The type of order fill this event represents.
	//
	// Types that are valid to be assigned to TakerOrder:
	//
	//	*OrderFillEventV1_Order
	//	*OrderFillEventV1_LiquidationOrder
	TakerOrder isOrderFillEventV1_TakerOrder `protobuf_oneof:"taker_order"`
	FillAmount uint64                        `protobuf:"varint,3,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty"`
	// Maker fee in USDC quantums.
	MakerFee int64 `protobuf:"zigzag64,5,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Taker fee in USDC quantums. If the taker order is a liquidation, then this
	// represents the special liquidation fee, not the standard taker fee.
	TakerFee int64 `protobuf:"zigzag64,6,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
}

func (m *OrderFillEventV1) Reset()         { *m = OrderFillEventV1{} }
func (m *OrderFillEventV1) String() string { return proto.CompactTextString(m) }
func (*OrderFillEventV1) ProtoMessage()    {}
func (*OrderFillEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{8}
}
func (m *OrderFillEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFillEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFillEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFillEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFillEventV1.Merge(m, src)
}
func (m *OrderFillEventV1) XXX_Size() int {
	return m.Size()
}
func (m *OrderFillEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFillEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFillEventV1 proto.InternalMessageInfo

type isOrderFillEventV1_TakerOrder interface {
	isOrderFillEventV1_TakerOrder()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OrderFillEventV1_Order struct {
	Order *v1.IndexerOrder `protobuf:"bytes,2,opt,name=order,proto3,oneof" json:"order,omitempty"`
}
type OrderFillEventV1_LiquidationOrder struct {
	LiquidationOrder *LiquidationOrderV1 `protobuf:"bytes,4,opt,name=liquidation_order,json=liquidationOrder,proto3,oneof" json:"liquidation_order,omitempty"`
}

func (*OrderFillEventV1_Order) isOrderFillEventV1_TakerOrder()            {}
func (*OrderFillEventV1_LiquidationOrder) isOrderFillEventV1_TakerOrder() {}

func (m *OrderFillEventV1) GetTakerOrder() isOrderFillEventV1_TakerOrder {
	if m != nil {
		return m.TakerOrder
	}
	return nil
}

func (m *OrderFillEventV1) GetMakerOrder() v1.IndexerOrder {
	if m != nil {
		return m.MakerOrder
	}
	return v1.IndexerOrder{}
}

func (m *OrderFillEventV1) GetOrder() *v1.IndexerOrder {
	if x, ok := m.GetTakerOrder().(*OrderFillEventV1_Order); ok {
		return x.Order
	}
	return nil
}

func (m *OrderFillEventV1) GetLiquidationOrder() *LiquidationOrderV1 {
	if x, ok := m.GetTakerOrder().(*OrderFillEventV1_LiquidationOrder); ok {
		return x.LiquidationOrder
	}
	return nil
}

func (m *OrderFillEventV1) GetFillAmount() uint64 {
	if m != nil {
		return m.FillAmount
	}
	return 0
}

func (m *OrderFillEventV1) GetMakerFee() int64 {
	if m != nil {
		return m.MakerFee
	}
	return 0
}

func (m *OrderFillEventV1) GetTakerFee() int64 {
	if m != nil {
		return m.TakerFee
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrderFillEventV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrderFillEventV1_Order)(nil),
		(*OrderFillEventV1_LiquidationOrder)(nil),
	}
}

// LiquidationOrder represents the liquidation taker order to be included in a
// liquidation order fill event.
type LiquidationOrderV1 struct {
	// ID of the subaccount that was liquidated.
	Liquidated v1.IndexerSubaccountId `protobuf:"bytes,1,opt,name=liquidated,proto3" json:"liquidated"`
	// The ID of the clob pair involved in the liquidation.
	ClobPairId uint32 `protobuf:"varint,2,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// The ID of the perpetual involved in the liquidation.
	PerpetualId uint32 `protobuf:"varint,3,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// The total size of the liquidation order including any unfilled size,
	// in base quantums.
	TotalSize uint64 `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	// `true` if liquidating a short position, `false` otherwise.
	IsBuy bool `protobuf:"varint,5,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	// The fillable price in subticks.
	// This represents the lower-price-bound for liquidating longs
	// and the upper-price-bound for liquidating shorts.
	// Must be a multiple of ClobPair.SubticksPerTick
	// (where `ClobPair.Id = orderId.ClobPairId`).
	Subticks uint64 `protobuf:"varint,6,opt,name=subticks,proto3" json:"subticks,omitempty"`
}

func (m *LiquidationOrderV1) Reset()         { *m = LiquidationOrderV1{} }
func (m *LiquidationOrderV1) String() string { return proto.CompactTextString(m) }
func (*LiquidationOrderV1) ProtoMessage()    {}
func (*LiquidationOrderV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{9}
}
func (m *LiquidationOrderV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidationOrderV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidationOrderV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidationOrderV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidationOrderV1.Merge(m, src)
}
func (m *LiquidationOrderV1) XXX_Size() int {
	return m.Size()
}
func (m *LiquidationOrderV1) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidationOrderV1.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidationOrderV1 proto.InternalMessageInfo

func (m *LiquidationOrderV1) GetLiquidated() v1.IndexerSubaccountId {
	if m != nil {
		return m.Liquidated
	}
	return v1.IndexerSubaccountId{}
}

func (m *LiquidationOrderV1) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *LiquidationOrderV1) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *LiquidationOrderV1) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *LiquidationOrderV1) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *LiquidationOrderV1) GetSubticks() uint64 {
	if m != nil {
		return m.Subticks
	}
	return 0
}

// SubaccountUpdateEvent message contains information about an update to a
// subaccount in the V4 chain. This includes the list of updated perpetual
// and asset positions for the subaccount.
// Note: This event message will contain all the updates to a subaccount
// at the end of a block which is why multiple asset/perpetual position
// updates may exist.
type SubaccountUpdateEventV1 struct {
	SubaccountId *v1.IndexerSubaccountId `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// updated_perpetual_positions will each be for unique perpetuals.
	UpdatedPerpetualPositions []*v1.IndexerPerpetualPosition `protobuf:"bytes,3,rep,name=updated_perpetual_positions,json=updatedPerpetualPositions,proto3" json:"updated_perpetual_positions,omitempty"`
	// updated_asset_positions will each be for unique assets.
	UpdatedAssetPositions []*v1.IndexerAssetPosition `protobuf:"bytes,4,rep,name=updated_asset_positions,json=updatedAssetPositions,proto3" json:"updated_asset_positions,omitempty"`
}

func (m *SubaccountUpdateEventV1) Reset()         { *m = SubaccountUpdateEventV1{} }
func (m *SubaccountUpdateEventV1) String() string { return proto.CompactTextString(m) }
func (*SubaccountUpdateEventV1) ProtoMessage()    {}
func (*SubaccountUpdateEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{10}
}
func (m *SubaccountUpdateEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountUpdateEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountUpdateEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountUpdateEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountUpdateEventV1.Merge(m, src)
}
func (m *SubaccountUpdateEventV1) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountUpdateEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountUpdateEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountUpdateEventV1 proto.InternalMessageInfo

func (m *SubaccountUpdateEventV1) GetSubaccountId() *v1.IndexerSubaccountId {
	if m != nil {
		return m.SubaccountId
	}
	return nil
}

func (m *SubaccountUpdateEventV1) GetUpdatedPerpetualPositions() []*v1.IndexerPerpetualPosition {
	if m != nil {
		return m.UpdatedPerpetualPositions
	}
	return nil
}

func (m *SubaccountUpdateEventV1) GetUpdatedAssetPositions() []*v1.IndexerAssetPosition {
	if m != nil {
		return m.UpdatedAssetPositions
	}
	return nil
}

// StatefulOrderEvent message contains information about a change to a stateful
// order. Currently, this is either the placement, cancelation, or expiration of
// a stateful order.
type StatefulOrderEventV1 struct {
	// The type of event that this StatefulOrderEvent contains.
	//
	// Types that are valid to be assigned to Event:
	//
	//	*StatefulOrderEventV1_OrderPlace
	//	*StatefulOrderEventV1_OrderCancel
	//	*StatefulOrderEventV1_OrderExpiration
	Event isStatefulOrderEventV1_Event `protobuf_oneof:"event"`
}

func (m *StatefulOrderEventV1) Reset()         { *m = StatefulOrderEventV1{} }
func (m *StatefulOrderEventV1) String() string { return proto.CompactTextString(m) }
func (*StatefulOrderEventV1) ProtoMessage()    {}
func (*StatefulOrderEventV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11}
}
func (m *StatefulOrderEventV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1.Merge(m, src)
}
func (m *StatefulOrderEventV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1 proto.InternalMessageInfo

type isStatefulOrderEventV1_Event interface {
	isStatefulOrderEventV1_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StatefulOrderEventV1_OrderPlace struct {
	OrderPlace *StatefulOrderEventV1_StatefulOrderPlacementV1 `protobuf:"bytes,1,opt,name=order_place,json=orderPlace,proto3,oneof" json:"order_place,omitempty"`
}
type StatefulOrderEventV1_OrderCancel struct {
	OrderCancel *StatefulOrderEventV1_StatefulOrderCancelationV1 `protobuf:"bytes,2,opt,name=order_cancel,json=orderCancel,proto3,oneof" json:"order_cancel,omitempty"`
}
type StatefulOrderEventV1_OrderExpiration struct {
	OrderExpiration *StatefulOrderEventV1_StatefulOrderExpirationV1 `protobuf:"bytes,3,opt,name=order_expiration,json=orderExpiration,proto3,oneof" json:"order_expiration,omitempty"`
}

func (*StatefulOrderEventV1_OrderPlace) isStatefulOrderEventV1_Event()      {}
func (*StatefulOrderEventV1_OrderCancel) isStatefulOrderEventV1_Event()     {}
func (*StatefulOrderEventV1_OrderExpiration) isStatefulOrderEventV1_Event() {}

func (m *StatefulOrderEventV1) GetEvent() isStatefulOrderEventV1_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *StatefulOrderEventV1) GetOrderPlace() *StatefulOrderEventV1_StatefulOrderPlacementV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_OrderPlace); ok {
		return x.OrderPlace
	}
	return nil
}

func (m *StatefulOrderEventV1) GetOrderCancel() *StatefulOrderEventV1_StatefulOrderCancelationV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_OrderCancel); ok {
		return x.OrderCancel
	}
	return nil
}

func (m *StatefulOrderEventV1) GetOrderExpiration() *StatefulOrderEventV1_StatefulOrderExpirationV1 {
	if x, ok := m.GetEvent().(*StatefulOrderEventV1_OrderExpiration); ok {
		return x.OrderExpiration
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StatefulOrderEventV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StatefulOrderEventV1_OrderPlace)(nil),
		(*StatefulOrderEventV1_OrderCancel)(nil),
		(*StatefulOrderEventV1_OrderExpiration)(nil),
	}
}

// A stateful order placement contains an order.
type StatefulOrderEventV1_StatefulOrderPlacementV1 struct {
	Order *v1.IndexerOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) Reset() {
	*m = StatefulOrderEventV1_StatefulOrderPlacementV1{}
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_StatefulOrderPlacementV1) ProtoMessage() {}
func (*StatefulOrderEventV1_StatefulOrderPlacementV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11, 0}
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_StatefulOrderPlacementV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderPlacementV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderPlacementV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_StatefulOrderPlacementV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) GetOrder() *v1.IndexerOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

// A stateful order cancelation contains the id of an order that was already
// placed and is now cancelled.
type StatefulOrderEventV1_StatefulOrderCancelationV1 struct {
	CanceledOrderId *v1.IndexerOrderId `protobuf:"bytes,1,opt,name=canceled_order_id,json=canceledOrderId,proto3" json:"canceled_order_id,omitempty"`
}

func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) Reset() {
	*m = StatefulOrderEventV1_StatefulOrderCancelationV1{}
}
func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_StatefulOrderCancelationV1) ProtoMessage() {}
func (*StatefulOrderEventV1_StatefulOrderCancelationV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11, 1}
}
func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_StatefulOrderCancelationV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderCancelationV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderCancelationV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_StatefulOrderCancelationV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) GetCanceledOrderId() *v1.IndexerOrderId {
	if m != nil {
		return m.CanceledOrderId
	}
	return nil
}

// A stateful order expiration contains the id of an order that was already
// placed and is now expired.
type StatefulOrderEventV1_StatefulOrderExpirationV1 struct {
	ExpiredOrderId *v1.IndexerOrderId `protobuf:"bytes,1,opt,name=expired_order_id,json=expiredOrderId,proto3" json:"expired_order_id,omitempty"`
}

func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) Reset() {
	*m = StatefulOrderEventV1_StatefulOrderExpirationV1{}
}
func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEventV1_StatefulOrderExpirationV1) ProtoMessage() {}
func (*StatefulOrderEventV1_StatefulOrderExpirationV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11, 2}
}
func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEventV1_StatefulOrderExpirationV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderExpirationV1.Merge(m, src)
}
func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEventV1_StatefulOrderExpirationV1.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEventV1_StatefulOrderExpirationV1 proto.InternalMessageInfo

func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) GetExpiredOrderId() *v1.IndexerOrderId {
	if m != nil {
		return m.ExpiredOrderId
	}
	return nil
}

func init() {
	proto.RegisterEnum("dydxprotocol.indexer.events.FundingEventV1_Type", FundingEventV1_Type_name, FundingEventV1_Type_value)
	proto.RegisterType((*FundingUpdateV1)(nil), "dydxprotocol.indexer.events.FundingUpdateV1")
	proto.RegisterType((*FundingEventV1)(nil), "dydxprotocol.indexer.events.FundingEventV1")
	proto.RegisterType((*MarketEventV1)(nil), "dydxprotocol.indexer.events.MarketEventV1")
	proto.RegisterType((*MarketPriceUpdateEventV1)(nil), "dydxprotocol.indexer.events.MarketPriceUpdateEventV1")
	proto.RegisterType((*MarketBaseEventV1)(nil), "dydxprotocol.indexer.events.MarketBaseEventV1")
	proto.RegisterType((*MarketCreateEventV1)(nil), "dydxprotocol.indexer.events.MarketCreateEventV1")
	proto.RegisterType((*MarketModifyEventV1)(nil), "dydxprotocol.indexer.events.MarketModifyEventV1")
	proto.RegisterType((*TransferEventV1)(nil), "dydxprotocol.indexer.events.TransferEventV1")
	proto.RegisterType((*OrderFillEventV1)(nil), "dydxprotocol.indexer.events.OrderFillEventV1")
	proto.RegisterType((*LiquidationOrderV1)(nil), "dydxprotocol.indexer.events.LiquidationOrderV1")
	proto.RegisterType((*SubaccountUpdateEventV1)(nil), "dydxprotocol.indexer.events.SubaccountUpdateEventV1")
	proto.RegisterType((*StatefulOrderEventV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1")
	proto.RegisterType((*StatefulOrderEventV1_StatefulOrderPlacementV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1")
	proto.RegisterType((*StatefulOrderEventV1_StatefulOrderCancelationV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderCancelationV1")
	proto.RegisterType((*StatefulOrderEventV1_StatefulOrderExpirationV1)(nil), "dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderExpirationV1")
}

func init() {
	proto.RegisterFile("dydxprotocol/indexer/events/events.proto", fileDescriptor_6331dfb59c6fd2bb)
}

var fileDescriptor_6331dfb59c6fd2bb = []byte{
	// 1247 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0xd6, 0xd5, 0x71, 0x8e, 0xa4, 0x58, 0x9a, 0xd8, 0xbf, 0x15, 0x19, 0xbf, 0xac, 0x72, 0xa5,
	0x5e, 0x20, 0x45, 0xee, 0x05, 0x68, 0x77, 0x96, 0x25, 0x35, 0x4c, 0x6d, 0x47, 0xa0, 0x6c, 0x27,
	0x71, 0x8b, 0xb0, 0x14, 0x39, 0xb2, 0x07, 0xe6, 0x2d, 0xbc, 0x38, 0x96, 0x9f, 0xa0, 0xcb, 0x02,
	0x7d, 0x89, 0x3e, 0x46, 0x81, 0x6e, 0xb2, 0x0c, 0xba, 0x2a, 0xba, 0x08, 0x8a, 0x64, 0xd1, 0x87,
	0xe8, 0xa6, 0xe0, 0xcc, 0x90, 0x94, 0x62, 0x5b, 0x55, 0x63, 0xaf, 0xec, 0xf9, 0xce, 0x9c, 0xef,
	0x3b, 0xf3, 0x71, 0xce, 0x21, 0x05, 0x75, 0x6d, 0xac, 0x9d, 0xd9, 0x8e, 0xe5, 0x59, 0xaa, 0xa5,
	0x37, 0x89, 0xa9, 0xe1, 0x33, 0xec, 0x34, 0xf1, 0x29, 0x36, 0x3d, 0x97, 0xff, 0x69, 0xd0, 0x30,
	0x5a, 0x9b, 0xdc, 0xd9, 0xe0, 0x3b, 0x1b, 0x6c, 0x4b, 0x65, 0xf9, 0xc8, 0x3a, 0xb2, 0x68, 0xb0,
	0x19, 0xfc, 0xc7, 0x52, 0x2a, 0x1f, 0x5f, 0x4a, 0x1e, 0x01, 0xa7, 0xad, 0xa6, 0xaa, 0x5b, 0x43,
	0xbe, 0xb9, 0xf5, 0xaf, 0x9b, 0x5d, 0x7f, 0xa8, 0xa8, 0xaa, 0xe5, 0x9b, 0x1e, 0x4b, 0x11, 0x7e,
	0x49, 0xc2, 0x52, 0xcf, 0x37, 0x35, 0x62, 0x1e, 0xed, 0xdb, 0x9a, 0xe2, 0xe1, 0x83, 0x16, 0xfa,
	0x00, 0xf2, 0x36, 0x76, 0x6c, 0xec, 0xf9, 0x8a, 0x2e, 0x13, 0xad, 0x9c, 0xac, 0x25, 0xeb, 0x05,
	0x29, 0x17, 0x61, 0xa2, 0x86, 0x3e, 0x82, 0xd2, 0x88, 0x65, 0xc9, 0xa7, 0x8a, 0xee, 0x63, 0xd9,
	0xb6, 0x8d, 0x72, 0xaa, 0x96, 0xac, 0x67, 0xa5, 0x25, 0x1e, 0x38, 0x08, 0xf0, 0xbe, 0x6d, 0xa0,
	0x67, 0x50, 0x08, 0xf7, 0xd2, 0x92, 0xca, 0xe9, 0x5a, 0xb2, 0x9e, 0x6f, 0x7f, 0xf9, 0xf2, 0xf5,
	0x7a, 0xe2, 0x8f, 0xd7, 0xeb, 0xad, 0x23, 0xe2, 0x1d, 0xfb, 0xc3, 0x86, 0x6a, 0x19, 0xcd, 0xa9,
	0xfa, 0x4f, 0x3f, 0x6b, 0x6a, 0xde, 0xd8, 0xc6, 0x6e, 0x63, 0x80, 0x1d, 0xa2, 0xe8, 0xe4, 0x5c,
	0x19, 0xea, 0x58, 0x34, 0x3d, 0x29, 0xcf, 0xf9, 0xc4, 0x80, 0x4e, 0xf8, 0x29, 0x05, 0x77, 0xf8,
	0x11, 0xba, 0x81, 0x95, 0x07, 0x2d, 0xb4, 0x0d, 0xb7, 0x7c, 0x7a, 0x1a, 0xb7, 0x9c, 0xac, 0xa5,
	0xeb, 0xb9, 0x8d, 0x4f, 0x1a, 0x33, 0xac, 0x6f, 0xbc, 0x63, 0x40, 0x3b, 0x13, 0x94, 0x26, 0x85,
	0x14, 0xa8, 0x03, 0x99, 0xa0, 0x0e, 0x7a, 0xbe, 0x3b, 0x1b, 0xf7, 0xe7, 0xa1, 0xe2, 0x85, 0x34,
	0xf6, 0xc6, 0x36, 0x96, 0x68, 0xb6, 0x60, 0x40, 0x26, 0x58, 0xa1, 0x65, 0x28, 0xee, 0x3d, 0xed,
	0x77, 0xe5, 0xfd, 0xdd, 0x41, 0xbf, 0xbb, 0x25, 0xf6, 0xc4, 0x6e, 0xa7, 0x98, 0x40, 0xab, 0x70,
	0x97, 0xa2, 0x7d, 0xa9, 0xbb, 0x23, 0xee, 0xef, 0xc8, 0x83, 0xcd, 0x9d, 0xfe, 0x76, 0xb7, 0x98,
	0x44, 0xeb, 0xb0, 0x46, 0x03, 0xbd, 0xfd, 0xdd, 0x8e, 0xb8, 0xfb, 0xb5, 0x2c, 0x6d, 0xee, 0x75,
	0xe5, 0xcd, 0xdd, 0x8e, 0x2c, 0xee, 0x76, 0xba, 0x4f, 0x8a, 0x29, 0xb4, 0x02, 0xa5, 0xa9, 0xcc,
	0x83, 0x47, 0x7b, 0xdd, 0x62, 0x5a, 0xf8, 0x35, 0x05, 0x85, 0x1d, 0xc5, 0x39, 0xc1, 0x5e, 0x68,
	0xca, 0x1a, 0xdc, 0x36, 0x28, 0x10, 0x3f, 0xd3, 0x45, 0x06, 0x88, 0x1a, 0x3a, 0x84, 0xbc, 0xed,
	0x10, 0x15, 0xcb, 0xec, 0xd0, 0xf4, 0xac, 0xb9, 0x8d, 0xcf, 0x67, 0x9e, 0x95, 0xd1, 0xf7, 0x83,
	0x34, 0x66, 0x1d, 0x57, 0x7a, 0x90, 0x90, 0x72, 0x76, 0x8c, 0xa2, 0xc7, 0x50, 0xe0, 0xc2, 0xaa,
	0x83, 0x03, 0xf2, 0x34, 0x25, 0xbf, 0x3f, 0x07, 0xf9, 0x16, 0x4d, 0x88, 0x79, 0xf3, 0xc6, 0x04,
	0x3c, 0x41, 0x6c, 0x58, 0x1a, 0x19, 0x8d, 0xcb, 0x99, 0xb9, 0x89, 0x77, 0x68, 0xc2, 0x05, 0x62,
	0x06, 0xb7, 0x6f, 0x41, 0x96, 0xee, 0x16, 0x1e, 0x42, 0xf9, 0xaa, 0x53, 0xa2, 0x06, 0xdc, 0x65,
	0x96, 0xbd, 0x20, 0xde, 0xb1, 0x8c, 0xcf, 0x6c, 0xcb, 0xc4, 0xa6, 0x47, 0x9d, 0xcd, 0x48, 0x25,
	0x1a, 0x7a, 0x4c, 0xbc, 0xe3, 0x2e, 0x0f, 0x08, 0x4f, 0xa0, 0xc4, 0xb8, 0xda, 0x8a, 0x1b, 0x91,
	0x20, 0xc8, 0xd8, 0x0a, 0x71, 0x68, 0xd6, 0x6d, 0x89, 0xfe, 0x8f, 0x9a, 0xb0, 0x6c, 0x10, 0x53,
	0x66, 0xe4, 0xea, 0xb1, 0x62, 0x1e, 0xc5, 0xfd, 0x55, 0x90, 0x4a, 0x06, 0x31, 0x69, 0x35, 0x5b,
	0x34, 0xd2, 0xb7, 0x0d, 0xc1, 0x87, 0xbb, 0x97, 0xd8, 0x85, 0xda, 0x90, 0x19, 0x2a, 0x2e, 0xa6,
	0xdc, 0xb9, 0x8d, 0xc6, 0x1c, 0xae, 0x4c, 0x54, 0x26, 0xd1, 0x5c, 0x54, 0x81, 0xc5, 0xe8, 0x64,
	0x81, 0x7e, 0x49, 0x8a, 0xd6, 0xc2, 0xd3, 0x50, 0x76, 0xca, 0xcc, 0x9b, 0x90, 0x15, 0x7e, 0x4e,
	0xc1, 0xd2, 0x9e, 0xa3, 0x98, 0xee, 0x08, 0x3b, 0x21, 0xaf, 0x01, 0xcb, 0x2e, 0x36, 0x35, 0xec,
	0xc8, 0xf1, 0x14, 0x0b, 0xaf, 0xf2, 0x95, 0x57, 0x35, 0x02, 0x4e, 0x5b, 0x0d, 0x91, 0x61, 0x83,
	0x28, 0x5b, 0xd4, 0x78, 0xab, 0x23, 0x46, 0x3c, 0x19, 0x41, 0x2e, 0xac, 0x3a, 0x58, 0x25, 0x36,
	0xc1, 0xa6, 0xf7, 0x8e, 0x62, 0xea, 0xfa, 0x8a, 0x2b, 0x11, 0xf7, 0x94, 0xe8, 0x3d, 0x58, 0x54,
	0x5c, 0x97, 0xb5, 0x68, 0x9a, 0x3e, 0xee, 0x5b, 0x74, 0x2d, 0x6a, 0xe8, 0x7f, 0xb0, 0xa0, 0x18,
	0xc1, 0x36, 0x7a, 0xcb, 0x33, 0x12, 0x5f, 0x09, 0x7f, 0xa7, 0xa0, 0xf8, 0xc8, 0xd1, 0xb0, 0xd3,
	0x23, 0xba, 0x1e, 0x7a, 0xb5, 0x0f, 0x39, 0x43, 0x39, 0xc1, 0x8e, 0x6c, 0x05, 0x91, 0xd9, 0x8f,
	0xe2, 0x92, 0x82, 0x29, 0x1f, 0xaf, 0x14, 0x28, 0x11, 0x45, 0x50, 0x0f, 0xb2, 0x8c, 0x30, 0xf5,
	0x3e, 0x84, 0x0f, 0x12, 0x12, 0x4b, 0x47, 0xcf, 0xa0, 0xa4, 0x93, 0xe7, 0x3e, 0xd1, 0x14, 0x8f,
	0x58, 0x26, 0x2f, 0x92, 0x35, 0x6f, 0x73, 0xe6, 0x7d, 0xd9, 0x8e, 0xb3, 0x28, 0x25, 0xed, 0xdd,
	0xa2, 0xfe, 0x0e, 0x8a, 0xd6, 0x21, 0x37, 0x22, 0xba, 0x2e, 0x73, 0xc3, 0xd2, 0xd4, 0x30, 0x08,
	0xa0, 0x4d, 0x8a, 0xb0, 0x59, 0x18, 0xf8, 0x33, 0xc2, 0xb8, 0x9c, 0xad, 0x25, 0xeb, 0x28, 0x98,
	0x85, 0x27, 0xd8, 0xe9, 0x61, 0x1c, 0x04, 0xbd, 0x28, 0xb8, 0xc0, 0x82, 0x1e, 0x0f, 0xb6, 0x0b,
	0x90, 0xf3, 0x62, 0x67, 0x85, 0x1f, 0x52, 0x80, 0x2e, 0x16, 0x85, 0xbe, 0x05, 0x08, 0x8b, 0xc2,
	0x37, 0x72, 0x43, 0x27, 0xe8, 0x50, 0x0d, 0xf2, 0xc1, 0x4b, 0x5f, 0x0e, 0x86, 0x45, 0x78, 0x1d,
	0x0b, 0x12, 0x04, 0x58, 0x5f, 0x21, 0x8e, 0xa8, 0x5d, 0x78, 0x83, 0xa7, 0x2f, 0xbe, 0xc1, 0xff,
	0x0f, 0xe0, 0x59, 0x9e, 0xa2, 0xcb, 0x2e, 0x39, 0xc7, 0xfc, 0x4a, 0xdd, 0xa6, 0xc8, 0x80, 0x9c,
	0x63, 0xb4, 0x02, 0x0b, 0xc4, 0x95, 0x87, 0xfe, 0x98, 0xba, 0xb3, 0x28, 0x65, 0x89, 0xdb, 0xf6,
	0xc7, 0xc1, 0x38, 0x70, 0xfd, 0xa1, 0x47, 0xd4, 0x13, 0x97, 0x3a, 0x93, 0x91, 0xa2, 0xb5, 0xf0,
	0x57, 0x0a, 0x56, 0xe3, 0xca, 0xa7, 0x67, 0xe5, 0x21, 0x14, 0x6e, 0xae, 0x69, 0xa5, 0xbc, 0x3b,
	0xd9, 0x33, 0xe7, 0xb0, 0xc6, 0x5e, 0x5a, 0x9a, 0x1c, 0x1f, 0xda, 0xb6, 0x5c, 0x12, 0x3c, 0x10,
	0xb7, 0x9c, 0xa6, 0x1f, 0x00, 0x5f, 0xcd, 0xad, 0xd4, 0x0f, 0x39, 0xfa, 0x9c, 0x42, 0xba, 0xc7,
	0xe9, 0x2f, 0x44, 0x5c, 0x64, 0xc2, 0x6a, 0xa8, 0xcd, 0xfa, 0x36, 0xd6, 0xcd, 0x50, 0xdd, 0x2f,
	0xe6, 0xd6, 0xdd, 0x0c, 0xf2, 0x23, 0xcd, 0x15, 0x4e, 0x3b, 0x85, 0xba, 0x0f, 0x33, 0x8b, 0xa9,
	0x62, 0x5a, 0xf8, 0x2d, 0x0b, 0xcb, 0x03, 0x4f, 0xf1, 0xf0, 0xc8, 0xd7, 0xe9, 0x8d, 0x8b, 0x47,
	0x64, 0x8e, 0x5e, 0x4b, 0xd9, 0xd6, 0x15, 0x35, 0x9c, 0xc0, 0x0f, 0x67, 0x76, 0xd4, 0x65, 0x3c,
	0xd3, 0x60, 0x3f, 0xe0, 0x32, 0xc2, 0x17, 0x25, 0x58, 0x11, 0x86, 0x9e, 0x43, 0x9e, 0xc9, 0xa9,
	0x8a, 0xa9, 0x62, 0x9d, 0x4f, 0x85, 0xed, 0x6b, 0xea, 0x6d, 0x51, 0x32, 0xda, 0x4e, 0xec, 0x5b,
	0xc2, 0x8a, 0x51, 0x74, 0x06, 0x45, 0x26, 0x89, 0xcf, 0x6c, 0xe2, 0xd0, 0x4d, 0xfc, 0x73, 0xe2,
	0x9b, 0x6b, 0xca, 0x76, 0x23, 0x42, 0xaa, 0xba, 0x64, 0x4d, 0x83, 0x95, 0xef, 0xa1, 0x7c, 0x95,
	0x2d, 0xa8, 0x13, 0xce, 0xc5, 0xf7, 0x1a, 0xb4, 0x7c, 0x2a, 0x56, 0xce, 0xa1, 0x72, 0xb5, 0x11,
	0xe8, 0x3b, 0x28, 0x31, 0x9b, 0xb1, 0xc6, 0x66, 0x4f, 0xdc, 0x46, 0xf7, 0xff, 0x9b, 0x9e, 0xa8,
	0x49, 0x4b, 0x21, 0x15, 0x07, 0x2a, 0x2f, 0xe0, 0xde, 0x95, 0x6e, 0xa0, 0x43, 0x28, 0x52, 0xbb,
	0x6f, 0x42, 0xf9, 0x0e, 0x67, 0xe2, 0xeb, 0xe8, 0x53, 0xab, 0xbd, 0xf5, 0xf2, 0x4d, 0x35, 0xf9,
	0xea, 0x4d, 0x35, 0xf9, 0xe7, 0x9b, 0x6a, 0xf2, 0xc7, 0xb7, 0xd5, 0xc4, 0xab, 0xb7, 0xd5, 0xc4,
	0xef, 0x6f, 0xab, 0x89, 0xc3, 0x0f, 0x67, 0xfc, 0x42, 0x98, 0xfe, 0xb9, 0x35, 0x5c, 0xa0, 0xb1,
	0x4f, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x20, 0xa2, 0xcb, 0x99, 0x94, 0x0d, 0x00, 0x00,
}

func (m *FundingUpdateV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingUpdateV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingUpdateV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FundingIndex.Size()
		i -= size
		if _, err := m.FundingIndex.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.FundingValuePpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FundingValuePpm))
		i--
		dAtA[i] = 0x10
	}
	if m.PerpetualId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FundingEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MarketEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarketEventV1_PriceUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEventV1_PriceUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PriceUpdate != nil {
		{
			size, err := m.PriceUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MarketEventV1_MarketCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEventV1_MarketCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MarketCreate != nil {
		{
			size, err := m.MarketCreate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MarketEventV1_MarketModify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEventV1_MarketModify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MarketModify != nil {
		{
			size, err := m.MarketModify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MarketPriceUpdateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketPriceUpdateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketPriceUpdateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PriceWithExponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PriceWithExponent))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarketBaseEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketBaseEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketBaseEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinPriceChangePpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MinPriceChangePpm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Pair) > 0 {
		i -= len(m.Pair)
		copy(dAtA[i:], m.Pair)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Pair)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketCreateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketCreateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketCreateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.Exponent)<<1)^uint32((m.Exponent>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketModifyEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketModifyEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketModifyEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x20
	}
	if m.AssetId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.AssetId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.RecipientSubaccountId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.SenderSubaccountId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OrderFillEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFillEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TakerFee != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint64(m.TakerFee)<<1)^uint64((m.TakerFee>>63))))
		i--
		dAtA[i] = 0x30
	}
	if m.MakerFee != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint64(m.MakerFee)<<1)^uint64((m.MakerFee>>63))))
		i--
		dAtA[i] = 0x28
	}
	if m.TakerOrder != nil {
		{
			size := m.TakerOrder.Size()
			i -= size
			if _, err := m.TakerOrder.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.FillAmount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FillAmount))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.MakerOrder.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OrderFillEventV1_Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEventV1_Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OrderFillEventV1_LiquidationOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEventV1_LiquidationOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LiquidationOrder != nil {
		{
			size, err := m.LiquidationOrder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *LiquidationOrderV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidationOrderV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidationOrderV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Subticks != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Subticks))
		i--
		dAtA[i] = 0x30
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TotalSize != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x20
	}
	if m.PerpetualId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x18
	}
	if m.ClobPairId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Liquidated.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubaccountUpdateEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountUpdateEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountUpdateEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedAssetPositions) > 0 {
		for iNdEx := len(m.UpdatedAssetPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdatedAssetPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UpdatedPerpetualPositions) > 0 {
		for iNdEx := len(m.UpdatedPerpetualPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdatedPerpetualPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SubaccountId != nil {
		{
			size, err := m.SubaccountId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_OrderPlace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_OrderPlace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderPlace != nil {
		{
			size, err := m.OrderPlace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_OrderCancel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_OrderCancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderCancel != nil {
		{
			size, err := m.OrderCancel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_OrderExpiration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_OrderExpiration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderExpiration != nil {
		{
			size, err := m.OrderExpiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CanceledOrderId != nil {
		{
			size, err := m.CanceledOrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiredOrderId != nil {
		{
			size, err := m.ExpiredOrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FundingUpdateV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerpetualId != 0 {
		n += 1 + sovEvents(uint64(m.PerpetualId))
	}
	if m.FundingValuePpm != 0 {
		n += 1 + sovEvents(uint64(m.FundingValuePpm))
	}
	l = m.FundingIndex.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *FundingEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovEvents(uint64(m.Type))
	}
	return n
}

func (m *MarketEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *MarketEventV1_PriceUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceUpdate != nil {
		l = m.PriceUpdate.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketEventV1_MarketCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketCreate != nil {
		l = m.MarketCreate.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketEventV1_MarketModify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketModify != nil {
		l = m.MarketModify.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketPriceUpdateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceWithExponent != 0 {
		n += 1 + sovEvents(uint64(m.PriceWithExponent))
	}
	return n
}

func (m *MarketBaseEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pair)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MinPriceChangePpm != 0 {
		n += 1 + sovEvents(uint64(m.MinPriceChangePpm))
	}
	return n
}

func (m *MarketCreateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sozEvents(uint64(m.Exponent))
	}
	return n
}

func (m *MarketModifyEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TransferEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SenderSubaccountId.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.RecipientSubaccountId.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.AssetId != 0 {
		n += 1 + sovEvents(uint64(m.AssetId))
	}
	if m.Amount != 0 {
		n += 1 + sovEvents(uint64(m.Amount))
	}
	return n
}

func (m *OrderFillEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MakerOrder.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.TakerOrder != nil {
		n += m.TakerOrder.Size()
	}
	if m.FillAmount != 0 {
		n += 1 + sovEvents(uint64(m.FillAmount))
	}
	if m.MakerFee != 0 {
		n += 1 + sozEvents(uint64(m.MakerFee))
	}
	if m.TakerFee != 0 {
		n += 1 + sozEvents(uint64(m.TakerFee))
	}
	return n
}

func (m *OrderFillEventV1_Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *OrderFillEventV1_LiquidationOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiquidationOrder != nil {
		l = m.LiquidationOrder.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *LiquidationOrderV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Liquidated.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.ClobPairId != 0 {
		n += 1 + sovEvents(uint64(m.ClobPairId))
	}
	if m.PerpetualId != 0 {
		n += 1 + sovEvents(uint64(m.PerpetualId))
	}
	if m.TotalSize != 0 {
		n += 1 + sovEvents(uint64(m.TotalSize))
	}
	if m.IsBuy {
		n += 2
	}
	if m.Subticks != 0 {
		n += 1 + sovEvents(uint64(m.Subticks))
	}
	return n
}

func (m *SubaccountUpdateEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubaccountId != nil {
		l = m.SubaccountId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.UpdatedPerpetualPositions) > 0 {
		for _, e := range m.UpdatedPerpetualPositions {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.UpdatedAssetPositions) > 0 {
		for _, e := range m.UpdatedAssetPositions {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *StatefulOrderEventV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *StatefulOrderEventV1_OrderPlace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderPlace != nil {
		l = m.OrderPlace.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_OrderCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderCancel != nil {
		l = m.OrderCancel.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_OrderExpiration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderExpiration != nil {
		l = m.OrderExpiration.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CanceledOrderId != nil {
		l = m.CanceledOrderId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiredOrderId != nil {
		l = m.ExpiredOrderId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FundingUpdateV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingUpdateV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingUpdateV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingValuePpm", wireType)
			}
			m.FundingValuePpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FundingValuePpm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundingIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, FundingUpdateV1{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FundingEventV1_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketPriceUpdateEventV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEventV1_PriceUpdate{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketCreateEventV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEventV1_MarketCreate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketModify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketModifyEventV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEventV1_MarketModify{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketPriceUpdateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketPriceUpdateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketPriceUpdateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceWithExponent", wireType)
			}
			m.PriceWithExponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceWithExponent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketBaseEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketBaseEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketBaseEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pair = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceChangePpm", wireType)
			}
			m.MinPriceChangePpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinPriceChangePpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketCreateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketCreateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketCreateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &MarketBaseEventV1{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exponent = v
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketModifyEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketModifyEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketModifyEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &MarketBaseEventV1{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderSubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SenderSubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientSubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecipientSubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			m.AssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFillEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFillEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFillEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1.IndexerOrder{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TakerOrder = &OrderFillEventV1_Order{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillAmount", wireType)
			}
			m.FillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LiquidationOrderV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TakerOrder = &OrderFillEventV1_LiquidationOrder{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFee", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MakerFee = int64(v)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.TakerFee = int64(v)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidationOrderV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidationOrderV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidationOrderV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Liquidated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subticks", wireType)
			}
			m.Subticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subticks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountUpdateEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountUpdateEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountUpdateEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubaccountId == nil {
				m.SubaccountId = &v1.IndexerSubaccountId{}
			}
			if err := m.SubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedPerpetualPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedPerpetualPositions = append(m.UpdatedPerpetualPositions, &v1.IndexerPerpetualPosition{})
			if err := m.UpdatedPerpetualPositions[len(m.UpdatedPerpetualPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAssetPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAssetPositions = append(m.UpdatedAssetPositions, &v1.IndexerAssetPosition{})
			if err := m.UpdatedAssetPositions[len(m.UpdatedAssetPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderEventV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderEventV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderPlace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_StatefulOrderPlacementV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_OrderPlace{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_StatefulOrderCancelationV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_OrderCancel{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderExpiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEventV1_StatefulOrderExpirationV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEventV1_OrderExpiration{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_StatefulOrderPlacementV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderPlacementV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderPlacementV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &v1.IndexerOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_StatefulOrderCancelationV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderCancelationV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderCancelationV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanceledOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CanceledOrderId == nil {
				m.CanceledOrderId = &v1.IndexerOrderId{}
			}
			if err := m.CanceledOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEventV1_StatefulOrderExpirationV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderExpirationV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderExpirationV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiredOrderId == nil {
				m.ExpiredOrderId = &v1.IndexerOrderId{}
			}
			if err := m.ExpiredOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
