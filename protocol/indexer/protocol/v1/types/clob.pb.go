// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/indexer/protocol/v1/clob.proto

package types

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status of the CLOB.
// Defined in clob.clob_pair
type ClobPairStatus int32

const (
	// Default value. This value is invalid and unused.
	ClobPairStatus_CLOB_PAIR_STATUS_UNSPECIFIED ClobPairStatus = 0
	// CLOB_PAIR_STATUS_ACTIVE behavior is unfinalized.
	// TODO(DEC-600): update this documentation.
	ClobPairStatus_CLOB_PAIR_STATUS_ACTIVE ClobPairStatus = 1
	// CLOB_PAIR_STATUS_PAUSED behavior is unfinalized.
	// TODO(DEC-600): update this documentation.
	ClobPairStatus_CLOB_PAIR_STATUS_PAUSED ClobPairStatus = 2
	// CLOB_PAIR_STATUS_CANCEL_ONLY behavior is unfinalized.
	// TODO(DEC-600): update this documentation.
	ClobPairStatus_CLOB_PAIR_STATUS_CANCEL_ONLY ClobPairStatus = 3
	// CLOB_PAIR_STATUS_POST_ONLY behavior is unfinalized.
	// TODO(DEC-600): update this documentation.
	ClobPairStatus_CLOB_PAIR_STATUS_POST_ONLY ClobPairStatus = 4
	// CLOB_PAIR_STATUS_INITIALIZING represents a newly-added clob pair.
	// Clob pairs in this state only accept orders which are
	// both short-term and post-only.
	ClobPairStatus_CLOB_PAIR_STATUS_INITIALIZING ClobPairStatus = 5
	// CLOB_PAIR_STATUS_FINAL_SETTLEMENT represents a clob pair that has been
	// deactivated. Clob pairs in this state do not accept new orders and trading
	// is blocked. All open positions are closed and open stateful orders canceled
	// by the protocol when the clob pair transitions to this status. All
	// short-term orders are left to expire.
	ClobPairStatus_CLOB_PAIR_STATUS_FINAL_SETTLEMENT ClobPairStatus = 6
)

var ClobPairStatus_name = map[int32]string{
	0: "CLOB_PAIR_STATUS_UNSPECIFIED",
	1: "CLOB_PAIR_STATUS_ACTIVE",
	2: "CLOB_PAIR_STATUS_PAUSED",
	3: "CLOB_PAIR_STATUS_CANCEL_ONLY",
	4: "CLOB_PAIR_STATUS_POST_ONLY",
	5: "CLOB_PAIR_STATUS_INITIALIZING",
	6: "CLOB_PAIR_STATUS_FINAL_SETTLEMENT",
}

var ClobPairStatus_value = map[string]int32{
	"CLOB_PAIR_STATUS_UNSPECIFIED":      0,
	"CLOB_PAIR_STATUS_ACTIVE":           1,
	"CLOB_PAIR_STATUS_PAUSED":           2,
	"CLOB_PAIR_STATUS_CANCEL_ONLY":      3,
	"CLOB_PAIR_STATUS_POST_ONLY":        4,
	"CLOB_PAIR_STATUS_INITIALIZING":     5,
	"CLOB_PAIR_STATUS_FINAL_SETTLEMENT": 6,
}

func (x ClobPairStatus) String() string {
	return proto.EnumName(ClobPairStatus_name, int32(x))
}

func (ClobPairStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fac8923e70f7ca3c, []int{0}
}

// Represents the side of the orderbook the order will be placed on.
// Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be
// placed on the orderbook.
type IndexerOrder_Side int32

const (
	// Default value. This value is invalid and unused.
	IndexerOrder_SIDE_UNSPECIFIED IndexerOrder_Side = 0
	// SIDE_BUY is used to represent a BUY order.
	IndexerOrder_SIDE_BUY IndexerOrder_Side = 1
	// SIDE_SELL is used to represent a SELL order.
	IndexerOrder_SIDE_SELL IndexerOrder_Side = 2
)

var IndexerOrder_Side_name = map[int32]string{
	0: "SIDE_UNSPECIFIED",
	1: "SIDE_BUY",
	2: "SIDE_SELL",
}

var IndexerOrder_Side_value = map[string]int32{
	"SIDE_UNSPECIFIED": 0,
	"SIDE_BUY":         1,
	"SIDE_SELL":        2,
}

func (x IndexerOrder_Side) String() string {
	return proto.EnumName(IndexerOrder_Side_name, int32(x))
}

func (IndexerOrder_Side) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fac8923e70f7ca3c, []int{1, 0}
}

// TimeInForce indicates how long an order will remain active before it
// is executed or expires.
type IndexerOrder_TimeInForce int32

const (
	// TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an
	// order will first match with existing orders on the book, and any
	// remaining size will be added to the book as a maker order.
	IndexerOrder_TIME_IN_FORCE_UNSPECIFIED IndexerOrder_TimeInForce = 0
	// TIME_IN_FORCE_IOC enforces that an order only be matched with
	// maker orders on the book. If the order has remaining size after
	// matching with existing orders on the book, the remaining size
	// is not placed on the book.
	IndexerOrder_TIME_IN_FORCE_IOC IndexerOrder_TimeInForce = 1
	// TIME_IN_FORCE_POST_ONLY enforces that an order only be placed
	// on the book as a maker order. Note this means that validators will cancel
	// any newly-placed post only orders that would cross with other maker
	// orders.
	IndexerOrder_TIME_IN_FORCE_POST_ONLY IndexerOrder_TimeInForce = 2
	// TIME_IN_FORCE_FILL_OR_KILL enforces that an order will either be filled
	// completely and immediately by maker orders on the book or canceled if the
	// entire amount canâ€˜t be matched.
	IndexerOrder_TIME_IN_FORCE_FILL_OR_KILL IndexerOrder_TimeInForce = 3
)

var IndexerOrder_TimeInForce_name = map[int32]string{
	0: "TIME_IN_FORCE_UNSPECIFIED",
	1: "TIME_IN_FORCE_IOC",
	2: "TIME_IN_FORCE_POST_ONLY",
	3: "TIME_IN_FORCE_FILL_OR_KILL",
}

var IndexerOrder_TimeInForce_value = map[string]int32{
	"TIME_IN_FORCE_UNSPECIFIED":  0,
	"TIME_IN_FORCE_IOC":          1,
	"TIME_IN_FORCE_POST_ONLY":    2,
	"TIME_IN_FORCE_FILL_OR_KILL": 3,
}

func (x IndexerOrder_TimeInForce) String() string {
	return proto.EnumName(IndexerOrder_TimeInForce_name, int32(x))
}

func (IndexerOrder_TimeInForce) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fac8923e70f7ca3c, []int{1, 1}
}

type IndexerOrder_ConditionType int32

const (
	// CONDITION_TYPE_UNSPECIFIED represents the default behavior where an
	// order will be placed immediately on the orderbook.
	IndexerOrder_CONDITION_TYPE_UNSPECIFIED IndexerOrder_ConditionType = 0
	// CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will
	// trigger when the oracle price moves at or above the trigger price for
	// buys, and at or below the trigger price for sells.
	IndexerOrder_CONDITION_TYPE_STOP_LOSS IndexerOrder_ConditionType = 1
	// CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit
	// order will trigger when the oracle price moves at or below the trigger
	// price for buys and at or above the trigger price for sells.
	IndexerOrder_CONDITION_TYPE_TAKE_PROFIT IndexerOrder_ConditionType = 2
)

var IndexerOrder_ConditionType_name = map[int32]string{
	0: "CONDITION_TYPE_UNSPECIFIED",
	1: "CONDITION_TYPE_STOP_LOSS",
	2: "CONDITION_TYPE_TAKE_PROFIT",
}

var IndexerOrder_ConditionType_value = map[string]int32{
	"CONDITION_TYPE_UNSPECIFIED": 0,
	"CONDITION_TYPE_STOP_LOSS":   1,
	"CONDITION_TYPE_TAKE_PROFIT": 2,
}

func (x IndexerOrder_ConditionType) String() string {
	return proto.EnumName(IndexerOrder_ConditionType_name, int32(x))
}

func (IndexerOrder_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fac8923e70f7ca3c, []int{1, 2}
}

// IndexerOrderId refers to a single order belonging to a Subaccount.
type IndexerOrderId struct {
	// The subaccount ID that opened this order.
	// Note that this field has `gogoproto.nullable = false` so that it is
	// generated as a value instead of a pointer. This is because the `OrderId`
	// proto is used as a key within maps, and map comparisons will compare
	// pointers for equality (when the desired behavior is to compare the values).
	SubaccountId IndexerSubaccountId `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id"`
	// The client ID of this order, unique with respect to the specific
	// sub account (I.E., the same subaccount can't have two orders with
	// the same ClientId).
	ClientId uint32 `protobuf:"fixed32,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// order_flags represent order flags for the order. This field is invalid if
	// it's greater than 127 (larger than one byte). Each bit in the first byte
	// represents a different flag. Currently only two flags are supported.
	//
	// Starting from the bit after the most MSB (note that the MSB is used in
	// proto varint encoding, and therefore cannot be used): Bit 1 is set if this
	// order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this
	// order is a Conditional order (0x20, or 32 as a uint8).
	//
	// If neither bit is set, the order is assumed to be a Short-Term order.
	//
	// If both bits are set or bits other than the 2nd and 3rd are set, the order
	// ID is invalid.
	OrderFlags uint32 `protobuf:"varint,3,opt,name=order_flags,json=orderFlags,proto3" json:"order_flags,omitempty"`
	// ID of the CLOB the order is created for.
	ClobPairId uint32 `protobuf:"varint,4,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
}

func (m *IndexerOrderId) Reset()         { *m = IndexerOrderId{} }
func (m *IndexerOrderId) String() string { return proto.CompactTextString(m) }
func (*IndexerOrderId) ProtoMessage()    {}
func (*IndexerOrderId) Descriptor() ([]byte, []int) {
	return fileDescriptor_fac8923e70f7ca3c, []int{0}
}
func (m *IndexerOrderId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexerOrderId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexerOrderId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexerOrderId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexerOrderId.Merge(m, src)
}
func (m *IndexerOrderId) XXX_Size() int {
	return m.Size()
}
func (m *IndexerOrderId) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexerOrderId.DiscardUnknown(m)
}

var xxx_messageInfo_IndexerOrderId proto.InternalMessageInfo

func (m *IndexerOrderId) GetSubaccountId() IndexerSubaccountId {
	if m != nil {
		return m.SubaccountId
	}
	return IndexerSubaccountId{}
}

func (m *IndexerOrderId) GetClientId() uint32 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *IndexerOrderId) GetOrderFlags() uint32 {
	if m != nil {
		return m.OrderFlags
	}
	return 0
}

func (m *IndexerOrderId) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

// IndexerOrderV1 represents a single order belonging to a `Subaccount`
// for a particular `ClobPair`.
type IndexerOrder struct {
	// The unique ID of this order. Meant to be unique across all orders.
	OrderId IndexerOrderId    `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	Side    IndexerOrder_Side `protobuf:"varint,2,opt,name=side,proto3,enum=dydxprotocol.indexer.protocol.v1.IndexerOrder_Side" json:"side,omitempty"`
	// The size of this order in base quantums. Must be a multiple of
	// `ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).
	Quantums uint64 `protobuf:"varint,3,opt,name=quantums,proto3" json:"quantums,omitempty"`
	// The price level that this order will be placed at on the orderbook,
	// in subticks. Must be a multiple of ClobPair.SubticksPerTick
	// (where `ClobPair.Id = orderId.ClobPairId`).
	Subticks uint64 `protobuf:"varint,4,opt,name=subticks,proto3" json:"subticks,omitempty"`
	// Information about when the order expires.
	//
	// Types that are valid to be assigned to GoodTilOneof:
	//	*IndexerOrder_GoodTilBlock
	//	*IndexerOrder_GoodTilBlockTime
	GoodTilOneof isIndexerOrder_GoodTilOneof `protobuf_oneof:"good_til_oneof"`
	// The time in force of this order.
	TimeInForce IndexerOrder_TimeInForce `protobuf:"varint,7,opt,name=time_in_force,json=timeInForce,proto3,enum=dydxprotocol.indexer.protocol.v1.IndexerOrder_TimeInForce" json:"time_in_force,omitempty"`
	// Enforces that the order can only reduce the size of an existing position.
	// If a ReduceOnly order would change the side of the existing position,
	// its size is reduced to that of the remaining size of the position.
	// If existing orders on the book with ReduceOnly
	// would already close the position, the least aggressive (out-of-the-money)
	// ReduceOnly orders are resized and canceled first.
	ReduceOnly bool `protobuf:"varint,8,opt,name=reduce_only,json=reduceOnly,proto3" json:"reduce_only,omitempty"`
	// Set of bit flags set arbitrarily by clients and ignored by the protocol.
	// Used by indexer to infer information about a placed order.
	ClientMetadata uint32                     `protobuf:"varint,9,opt,name=client_metadata,json=clientMetadata,proto3" json:"client_metadata,omitempty"`
	ConditionType  IndexerOrder_ConditionType `protobuf:"varint,10,opt,name=condition_type,json=conditionType,proto3,enum=dydxprotocol.indexer.protocol.v1.IndexerOrder_ConditionType" json:"condition_type,omitempty"`
	// conditional_order_trigger_subticks represents the price at which this order
	// will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,
	// this value is enforced to be 0. If this value is nonzero, condition_type
	// cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.
	// Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =
	// orderId.ClobPairId`).
	ConditionalOrderTriggerSubticks uint64 `protobuf:"varint,11,opt,name=conditional_order_trigger_subticks,json=conditionalOrderTriggerSubticks,proto3" json:"conditional_order_trigger_subticks,omitempty"`
	// builder_code_params is the metadata for the partner or builder of an order.
	BuilderCodeParams *BuilderCodeParameters `protobuf:"bytes,12,opt,name=builder_code_params,json=builderCodeParams,proto3" json:"builder_code_params,omitempty"`
}

func (m *IndexerOrder) Reset()         { *m = IndexerOrder{} }
func (m *IndexerOrder) String() string { return proto.CompactTextString(m) }
func (*IndexerOrder) ProtoMessage()    {}
func (*IndexerOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_fac8923e70f7ca3c, []int{1}
}
func (m *IndexerOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexerOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexerOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexerOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexerOrder.Merge(m, src)
}
func (m *IndexerOrder) XXX_Size() int {
	return m.Size()
}
func (m *IndexerOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexerOrder.DiscardUnknown(m)
}

var xxx_messageInfo_IndexerOrder proto.InternalMessageInfo

type isIndexerOrder_GoodTilOneof interface {
	isIndexerOrder_GoodTilOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IndexerOrder_GoodTilBlock struct {
	GoodTilBlock uint32 `protobuf:"varint,5,opt,name=good_til_block,json=goodTilBlock,proto3,oneof" json:"good_til_block,omitempty"`
}
type IndexerOrder_GoodTilBlockTime struct {
	GoodTilBlockTime uint32 `protobuf:"fixed32,6,opt,name=good_til_block_time,json=goodTilBlockTime,proto3,oneof" json:"good_til_block_time,omitempty"`
}

func (*IndexerOrder_GoodTilBlock) isIndexerOrder_GoodTilOneof()     {}
func (*IndexerOrder_GoodTilBlockTime) isIndexerOrder_GoodTilOneof() {}

func (m *IndexerOrder) GetGoodTilOneof() isIndexerOrder_GoodTilOneof {
	if m != nil {
		return m.GoodTilOneof
	}
	return nil
}

func (m *IndexerOrder) GetOrderId() IndexerOrderId {
	if m != nil {
		return m.OrderId
	}
	return IndexerOrderId{}
}

func (m *IndexerOrder) GetSide() IndexerOrder_Side {
	if m != nil {
		return m.Side
	}
	return IndexerOrder_SIDE_UNSPECIFIED
}

func (m *IndexerOrder) GetQuantums() uint64 {
	if m != nil {
		return m.Quantums
	}
	return 0
}

func (m *IndexerOrder) GetSubticks() uint64 {
	if m != nil {
		return m.Subticks
	}
	return 0
}

func (m *IndexerOrder) GetGoodTilBlock() uint32 {
	if x, ok := m.GetGoodTilOneof().(*IndexerOrder_GoodTilBlock); ok {
		return x.GoodTilBlock
	}
	return 0
}

func (m *IndexerOrder) GetGoodTilBlockTime() uint32 {
	if x, ok := m.GetGoodTilOneof().(*IndexerOrder_GoodTilBlockTime); ok {
		return x.GoodTilBlockTime
	}
	return 0
}

func (m *IndexerOrder) GetTimeInForce() IndexerOrder_TimeInForce {
	if m != nil {
		return m.TimeInForce
	}
	return IndexerOrder_TIME_IN_FORCE_UNSPECIFIED
}

func (m *IndexerOrder) GetReduceOnly() bool {
	if m != nil {
		return m.ReduceOnly
	}
	return false
}

func (m *IndexerOrder) GetClientMetadata() uint32 {
	if m != nil {
		return m.ClientMetadata
	}
	return 0
}

func (m *IndexerOrder) GetConditionType() IndexerOrder_ConditionType {
	if m != nil {
		return m.ConditionType
	}
	return IndexerOrder_CONDITION_TYPE_UNSPECIFIED
}

func (m *IndexerOrder) GetConditionalOrderTriggerSubticks() uint64 {
	if m != nil {
		return m.ConditionalOrderTriggerSubticks
	}
	return 0
}

func (m *IndexerOrder) GetBuilderCodeParams() *BuilderCodeParameters {
	if m != nil {
		return m.BuilderCodeParams
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IndexerOrder) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IndexerOrder_GoodTilBlock)(nil),
		(*IndexerOrder_GoodTilBlockTime)(nil),
	}
}

// BuilderCodeParameters represents the metadata for the partner or builder of
// an order. This allows them to specify a fee for providing there service which
// will be paid out in the event of an order fill.
type BuilderCodeParameters struct {
	// The address of the builder to which the fee will be paid.
	BuilderAddress string `protobuf:"bytes,1,opt,name=builder_address,json=builderAddress,proto3" json:"builder_address,omitempty"`
	// The fee enforced on the order in ppm.
	FeePpm uint32 `protobuf:"varint,2,opt,name=fee_ppm,json=feePpm,proto3" json:"fee_ppm,omitempty"`
}

func (m *BuilderCodeParameters) Reset()         { *m = BuilderCodeParameters{} }
func (m *BuilderCodeParameters) String() string { return proto.CompactTextString(m) }
func (*BuilderCodeParameters) ProtoMessage()    {}
func (*BuilderCodeParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_fac8923e70f7ca3c, []int{2}
}
func (m *BuilderCodeParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuilderCodeParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuilderCodeParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuilderCodeParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuilderCodeParameters.Merge(m, src)
}
func (m *BuilderCodeParameters) XXX_Size() int {
	return m.Size()
}
func (m *BuilderCodeParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_BuilderCodeParameters.DiscardUnknown(m)
}

var xxx_messageInfo_BuilderCodeParameters proto.InternalMessageInfo

func (m *BuilderCodeParameters) GetBuilderAddress() string {
	if m != nil {
		return m.BuilderAddress
	}
	return ""
}

func (m *BuilderCodeParameters) GetFeePpm() uint32 {
	if m != nil {
		return m.FeePpm
	}
	return 0
}

func init() {
	proto.RegisterEnum("dydxprotocol.indexer.protocol.v1.ClobPairStatus", ClobPairStatus_name, ClobPairStatus_value)
	proto.RegisterEnum("dydxprotocol.indexer.protocol.v1.IndexerOrder_Side", IndexerOrder_Side_name, IndexerOrder_Side_value)
	proto.RegisterEnum("dydxprotocol.indexer.protocol.v1.IndexerOrder_TimeInForce", IndexerOrder_TimeInForce_name, IndexerOrder_TimeInForce_value)
	proto.RegisterEnum("dydxprotocol.indexer.protocol.v1.IndexerOrder_ConditionType", IndexerOrder_ConditionType_name, IndexerOrder_ConditionType_value)
	proto.RegisterType((*IndexerOrderId)(nil), "dydxprotocol.indexer.protocol.v1.IndexerOrderId")
	proto.RegisterType((*IndexerOrder)(nil), "dydxprotocol.indexer.protocol.v1.IndexerOrder")
	proto.RegisterType((*BuilderCodeParameters)(nil), "dydxprotocol.indexer.protocol.v1.BuilderCodeParameters")
}

func init() {
	proto.RegisterFile("dydxprotocol/indexer/protocol/v1/clob.proto", fileDescriptor_fac8923e70f7ca3c)
}

var fileDescriptor_fac8923e70f7ca3c = []byte{
	// 918 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x95, 0x4d, 0x6f, 0xe3, 0x44,
	0x18, 0xc7, 0xe3, 0x34, 0xdb, 0xa6, 0x93, 0x17, 0xbc, 0xb3, 0xbb, 0xaa, 0x69, 0x77, 0xd3, 0x6c,
	0x24, 0xa0, 0x02, 0x91, 0xd0, 0x5d, 0x10, 0x02, 0x71, 0x49, 0x5c, 0x67, 0x77, 0x54, 0xd7, 0x36,
	0xb6, 0x8b, 0xd4, 0x95, 0x60, 0x70, 0x3c, 0x93, 0xec, 0x68, 0x1d, 0x4f, 0xb0, 0x9d, 0x6a, 0x73,
	0xe3, 0x23, 0xf0, 0x8d, 0xb8, 0xee, 0x71, 0xc5, 0x89, 0x13, 0x42, 0xed, 0x97, 0xe0, 0x88, 0xc6,
	0x4e, 0xdd, 0xbc, 0x54, 0x94, 0xde, 0x3c, 0xbf, 0xe7, 0x79, 0xfe, 0x7a, 0xde, 0x3c, 0x03, 0x3e,
	0x23, 0x33, 0xf2, 0x76, 0x12, 0xf1, 0x84, 0xfb, 0x3c, 0xe8, 0xb0, 0x90, 0xd0, 0xb7, 0x34, 0xea,
	0xe4, 0xe0, 0xfc, 0xb0, 0xe3, 0x07, 0x7c, 0xd0, 0x4e, 0x01, 0x6c, 0x2e, 0x3a, 0xb7, 0xe7, 0xce,
	0xed, 0x1c, 0x9c, 0x1f, 0xee, 0x1e, 0xde, 0x2a, 0x17, 0x4f, 0x07, 0x9e, 0xef, 0xf3, 0x69, 0x98,
	0x64, 0x81, 0xbb, 0x0f, 0x47, 0x7c, 0xc4, 0xd3, 0xcf, 0x8e, 0xf8, 0xca, 0x68, 0xeb, 0x0f, 0x09,
	0xd4, 0x51, 0x16, 0x6e, 0x46, 0x84, 0x46, 0x88, 0xc0, 0x9f, 0x41, 0xed, 0x3a, 0x18, 0x33, 0xa2,
	0x48, 0x4d, 0xe9, 0xa0, 0xf2, 0xec, 0xab, 0xf6, 0x6d, 0x59, 0xb5, 0xe7, 0x42, 0x4e, 0x1e, 0x8d,
	0x48, 0xaf, 0xf4, 0xee, 0xaf, 0xfd, 0x82, 0x5d, 0x8d, 0x17, 0x18, 0xdc, 0x03, 0xdb, 0x7e, 0xc0,
	0x68, 0xa6, 0x5e, 0x6c, 0x4a, 0x07, 0x5b, 0x76, 0x39, 0x03, 0x88, 0xc0, 0x7d, 0x50, 0xe1, 0x22,
	0x13, 0x3c, 0x0c, 0xbc, 0x51, 0xac, 0x6c, 0x34, 0xa5, 0x83, 0x9a, 0x0d, 0x52, 0xd4, 0x17, 0x04,
	0x36, 0x41, 0x55, 0xf4, 0x0a, 0x4f, 0x3c, 0x16, 0x09, 0x81, 0x52, 0xe6, 0x21, 0x98, 0xe5, 0xb1,
	0x08, 0x91, 0xd6, 0xef, 0x65, 0x50, 0x5d, 0x2c, 0x0a, 0x7e, 0x0f, 0xca, 0x99, 0x66, 0x5e, 0xcd,
	0x17, 0xff, 0xbb, 0x9a, 0x79, 0x5b, 0xe6, 0x85, 0x6c, 0xf1, 0x79, 0x97, 0x5e, 0x80, 0x52, 0xcc,
	0x08, 0x4d, 0xd3, 0xaf, 0x3f, 0x7b, 0x7e, 0x37, 0xb9, 0xb6, 0xc3, 0x08, 0xb5, 0x53, 0x01, 0xb8,
	0x0b, 0xca, 0xbf, 0x4c, 0xbd, 0x30, 0x99, 0x8e, 0xb3, 0x62, 0x4b, 0x76, 0x7e, 0x16, 0xb6, 0x78,
	0x3a, 0x48, 0x98, 0xff, 0x26, 0x4e, 0xcb, 0x2c, 0xd9, 0xf9, 0x19, 0x7e, 0x0c, 0xea, 0x23, 0xce,
	0x09, 0x4e, 0x58, 0x80, 0x07, 0x01, 0xf7, 0xdf, 0x28, 0xf7, 0x44, 0x23, 0x5e, 0x16, 0xec, 0xaa,
	0xe0, 0x2e, 0x0b, 0x7a, 0x82, 0xc2, 0x0e, 0x78, 0xb0, 0xec, 0x87, 0x13, 0x36, 0xa6, 0xca, 0xa6,
	0x68, 0xfb, 0xcb, 0x82, 0x2d, 0x2f, 0x3a, 0xbb, 0x6c, 0x4c, 0xe1, 0x4f, 0xa0, 0x26, 0x3c, 0x30,
	0x0b, 0xf1, 0x90, 0x47, 0x3e, 0x55, 0xb6, 0xd2, 0x12, 0xbf, 0xbd, 0x63, 0x89, 0x42, 0x0b, 0x85,
	0x7d, 0xa1, 0x60, 0x57, 0x92, 0xeb, 0x83, 0x18, 0x70, 0x44, 0xc9, 0xd4, 0xa7, 0x98, 0x87, 0xc1,
	0x4c, 0x29, 0x37, 0xa5, 0x83, 0xb2, 0x0d, 0x32, 0x64, 0x86, 0xc1, 0x0c, 0x7e, 0x02, 0x3e, 0x98,
	0xaf, 0xc7, 0x98, 0x26, 0x1e, 0xf1, 0x12, 0x4f, 0xd9, 0x4e, 0x67, 0x5c, 0xcf, 0xf0, 0xc9, 0x9c,
	0x42, 0x1f, 0xd4, 0x7d, 0x1e, 0x12, 0x96, 0x30, 0x1e, 0xe2, 0x64, 0x36, 0xa1, 0x0a, 0x48, 0x53,
	0xfd, 0xee, 0x8e, 0xa9, 0xaa, 0x57, 0x22, 0xee, 0x6c, 0x42, 0xed, 0x9a, 0xbf, 0x78, 0x84, 0xc7,
	0xa0, 0x95, 0x03, 0x2f, 0xc0, 0xd9, 0x1e, 0x25, 0x11, 0x1b, 0x8d, 0x68, 0x84, 0xf3, 0xe9, 0x54,
	0xd2, 0xe9, 0xec, 0x2f, 0x78, 0xa6, 0xd2, 0x6e, 0xe6, 0xe7, 0x5c, 0x0d, 0x6d, 0x04, 0x1e, 0x0c,
	0xa6, 0x2c, 0x10, 0x12, 0x3e, 0x27, 0x14, 0x4f, 0xbc, 0xc8, 0x1b, 0xc7, 0x4a, 0x35, 0xdd, 0xc9,
	0xaf, 0x6f, 0x4f, 0xbb, 0x97, 0x05, 0xab, 0x9c, 0x50, 0x4b, 0x84, 0xd2, 0x84, 0x46, 0xb1, 0x7d,
	0x7f, 0xb0, 0x82, 0xe3, 0xd6, 0x37, 0xa0, 0x24, 0x76, 0x0c, 0x3e, 0x04, 0xb2, 0x83, 0x8e, 0x34,
	0x7c, 0x6a, 0x38, 0x96, 0xa6, 0xa2, 0x3e, 0xd2, 0x8e, 0xe4, 0x02, 0xac, 0x82, 0x72, 0x4a, 0x7b,
	0xa7, 0x67, 0xb2, 0x04, 0x6b, 0x60, 0x3b, 0x3d, 0x39, 0x9a, 0xae, 0xcb, 0xc5, 0xd6, 0xaf, 0x12,
	0xa8, 0x2c, 0x0c, 0x0f, 0x3e, 0x01, 0x1f, 0xba, 0xe8, 0x44, 0xc3, 0xc8, 0xc0, 0x7d, 0xd3, 0x56,
	0x57, 0xb5, 0x1e, 0x81, 0xfb, 0xcb, 0x66, 0x64, 0xaa, 0xb2, 0x04, 0xf7, 0xc0, 0xce, 0x32, 0xb6,
	0x4c, 0xc7, 0xc5, 0xa6, 0xa1, 0x9f, 0xc9, 0x45, 0xd8, 0x00, 0xbb, 0xcb, 0xc6, 0x3e, 0xd2, 0x75,
	0x6c, 0xda, 0xf8, 0x18, 0xe9, 0xba, 0xbc, 0xd1, 0x1a, 0x83, 0xda, 0xd2, 0x4c, 0x44, 0x80, 0x6a,
	0x1a, 0x47, 0xc8, 0x45, 0xa6, 0x81, 0xdd, 0x33, 0x6b, 0x35, 0x89, 0xc7, 0x40, 0x59, 0xb1, 0x3b,
	0xae, 0x69, 0x61, 0xdd, 0x74, 0x1c, 0x59, 0xba, 0x21, 0xda, 0xed, 0x1e, 0x6b, 0xd8, 0xb2, 0xcd,
	0x3e, 0x72, 0xe5, 0x62, 0x4f, 0x5e, 0xf8, 0x95, 0x78, 0x48, 0xf9, 0xb0, 0x75, 0x06, 0x1e, 0xdd,
	0xd8, 0x6a, 0xb1, 0x9b, 0x57, 0x03, 0xf4, 0x08, 0x89, 0x68, 0x1c, 0xa7, 0x17, 0xca, 0xb6, 0x5d,
	0x9f, 0xe3, 0x6e, 0x46, 0xe1, 0x0e, 0xd8, 0x1a, 0x52, 0x8a, 0x27, 0x93, 0x71, 0x7a, 0x45, 0xd4,
	0xec, 0xcd, 0x21, 0xa5, 0xd6, 0x64, 0xfc, 0xe9, 0x3f, 0x12, 0xa8, 0xab, 0xf3, 0xbb, 0xca, 0x49,
	0xbc, 0x64, 0x2a, 0x6e, 0xb4, 0xc7, 0xaa, 0x6e, 0xf6, 0xb0, 0xd5, 0x45, 0x36, 0x76, 0xdc, 0xae,
	0x7b, 0xea, 0xac, 0xd4, 0xb7, 0x07, 0x76, 0xd6, 0x3c, 0xba, 0xaa, 0x8b, 0x7e, 0xd0, 0xb2, 0x56,
	0xaf, 0x19, 0xad, 0xee, 0xa9, 0xa3, 0x1d, 0xc9, 0xc5, 0x1b, 0xb5, 0xd5, 0xae, 0xa1, 0x6a, 0x7a,
	0x36, 0x8c, 0x8d, 0xb4, 0x3b, 0x6b, 0xe1, 0xf9, 0xb0, 0x4a, 0xf0, 0x29, 0x78, 0xb2, 0x66, 0x47,
	0x06, 0x72, 0x51, 0x57, 0x47, 0xaf, 0x90, 0xf1, 0x42, 0xbe, 0x07, 0x3f, 0x02, 0x4f, 0xd7, 0x5c,
	0xfa, 0xc8, 0xe8, 0xea, 0xd8, 0xd1, 0x5c, 0x57, 0xd7, 0x4e, 0x34, 0xc3, 0x95, 0x37, 0x7b, 0x3f,
	0xbe, 0xbb, 0x68, 0x48, 0xef, 0x2f, 0x1a, 0xd2, 0xdf, 0x17, 0x0d, 0xe9, 0xb7, 0xcb, 0x46, 0xe1,
	0xfd, 0x65, 0xa3, 0xf0, 0xe7, 0x65, 0xa3, 0xf0, 0x4a, 0x1d, 0xb1, 0xe4, 0xf5, 0x74, 0xd0, 0xf6,
	0xf9, 0xb8, 0xb3, 0xf4, 0xb4, 0x9d, 0x7f, 0xf9, 0xb9, 0xff, 0xda, 0x63, 0x61, 0xe7, 0x3f, 0x1f,
	0x3b, 0xf1, 0xef, 0xc7, 0x83, 0xcd, 0x14, 0x3d, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x0e, 0xf8,
	0xf6, 0x0f, 0x6c, 0x07, 0x00, 0x00,
}

func (m *IndexerOrderId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexerOrderId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexerOrderId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClobPairId != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x20
	}
	if m.OrderFlags != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.OrderFlags))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientId != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ClientId))
		i--
		dAtA[i] = 0x15
	}
	{
		size, err := m.SubaccountId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClob(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexerOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexerOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexerOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BuilderCodeParams != nil {
		{
			size, err := m.BuilderCodeParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintClob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ConditionalOrderTriggerSubticks != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.ConditionalOrderTriggerSubticks))
		i--
		dAtA[i] = 0x58
	}
	if m.ConditionType != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.ConditionType))
		i--
		dAtA[i] = 0x50
	}
	if m.ClientMetadata != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.ClientMetadata))
		i--
		dAtA[i] = 0x48
	}
	if m.ReduceOnly {
		i--
		if m.ReduceOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.TimeInForce != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.TimeInForce))
		i--
		dAtA[i] = 0x38
	}
	if m.GoodTilOneof != nil {
		{
			size := m.GoodTilOneof.Size()
			i -= size
			if _, err := m.GoodTilOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Subticks != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.Subticks))
		i--
		dAtA[i] = 0x20
	}
	if m.Quantums != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.Quantums))
		i--
		dAtA[i] = 0x18
	}
	if m.Side != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.Side))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.OrderId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClob(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexerOrder_GoodTilBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexerOrder_GoodTilBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintClob(dAtA, i, uint64(m.GoodTilBlock))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *IndexerOrder_GoodTilBlockTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexerOrder_GoodTilBlockTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.GoodTilBlockTime))
	i--
	dAtA[i] = 0x35
	return len(dAtA) - i, nil
}
func (m *BuilderCodeParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuilderCodeParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuilderCodeParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FeePpm != 0 {
		i = encodeVarintClob(dAtA, i, uint64(m.FeePpm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BuilderAddress) > 0 {
		i -= len(m.BuilderAddress)
		copy(dAtA[i:], m.BuilderAddress)
		i = encodeVarintClob(dAtA, i, uint64(len(m.BuilderAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintClob(dAtA []byte, offset int, v uint64) int {
	offset -= sovClob(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IndexerOrderId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SubaccountId.Size()
	n += 1 + l + sovClob(uint64(l))
	if m.ClientId != 0 {
		n += 5
	}
	if m.OrderFlags != 0 {
		n += 1 + sovClob(uint64(m.OrderFlags))
	}
	if m.ClobPairId != 0 {
		n += 1 + sovClob(uint64(m.ClobPairId))
	}
	return n
}

func (m *IndexerOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OrderId.Size()
	n += 1 + l + sovClob(uint64(l))
	if m.Side != 0 {
		n += 1 + sovClob(uint64(m.Side))
	}
	if m.Quantums != 0 {
		n += 1 + sovClob(uint64(m.Quantums))
	}
	if m.Subticks != 0 {
		n += 1 + sovClob(uint64(m.Subticks))
	}
	if m.GoodTilOneof != nil {
		n += m.GoodTilOneof.Size()
	}
	if m.TimeInForce != 0 {
		n += 1 + sovClob(uint64(m.TimeInForce))
	}
	if m.ReduceOnly {
		n += 2
	}
	if m.ClientMetadata != 0 {
		n += 1 + sovClob(uint64(m.ClientMetadata))
	}
	if m.ConditionType != 0 {
		n += 1 + sovClob(uint64(m.ConditionType))
	}
	if m.ConditionalOrderTriggerSubticks != 0 {
		n += 1 + sovClob(uint64(m.ConditionalOrderTriggerSubticks))
	}
	if m.BuilderCodeParams != nil {
		l = m.BuilderCodeParams.Size()
		n += 1 + l + sovClob(uint64(l))
	}
	return n
}

func (m *IndexerOrder_GoodTilBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovClob(uint64(m.GoodTilBlock))
	return n
}
func (m *IndexerOrder_GoodTilBlockTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *BuilderCodeParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuilderAddress)
	if l > 0 {
		n += 1 + l + sovClob(uint64(l))
	}
	if m.FeePpm != 0 {
		n += 1 + sovClob(uint64(m.FeePpm))
	}
	return n
}

func sovClob(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozClob(x uint64) (n int) {
	return sovClob(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IndexerOrderId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexerOrderId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexerOrderId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderFlags", wireType)
			}
			m.OrderFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderFlags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipClob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexerOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexerOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexerOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= IndexerOrder_Side(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantums", wireType)
			}
			m.Quantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subticks", wireType)
			}
			m.Subticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subticks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlock", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GoodTilOneof = &IndexerOrder_GoodTilBlock{v}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTilBlockTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GoodTilOneof = &IndexerOrder_GoodTilBlockTime{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeInForce", wireType)
			}
			m.TimeInForce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeInForce |= IndexerOrder_TimeInForce(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReduceOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReduceOnly = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientMetadata", wireType)
			}
			m.ClientMetadata = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientMetadata |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			m.ConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionType |= IndexerOrder_ConditionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalOrderTriggerSubticks", wireType)
			}
			m.ConditionalOrderTriggerSubticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionalOrderTriggerSubticks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuilderCodeParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuilderCodeParams == nil {
				m.BuilderCodeParams = &BuilderCodeParameters{}
			}
			if err := m.BuilderCodeParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuilderCodeParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuilderCodeParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuilderCodeParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuilderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuilderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeePpm", wireType)
			}
			m.FeePpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeePpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipClob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClob(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClob
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClob
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupClob
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthClob
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthClob        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClob          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupClob = fmt.Errorf("proto: unexpected end of group")
)
