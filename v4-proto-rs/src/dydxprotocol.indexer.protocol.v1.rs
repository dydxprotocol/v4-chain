// This file is @generated by prost-build.
/// IndexerSubaccountId defines a unique identifier for a Subaccount.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerSubaccountId {
    /// The address of the wallet that owns this subaccount.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// < 128 Since 128 should be enough to start and it fits within
    /// 1 Byte (1 Bit needed to indicate that the first byte is the last).
    #[prost(uint32, tag = "2")]
    pub number: u32,
}
impl ::prost::Name for IndexerSubaccountId {
    const NAME: &'static str = "IndexerSubaccountId";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerSubaccountId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerSubaccountId".into()
    }
}
/// IndexerPerpetualPosition are an account’s positions of a `Perpetual`.
/// Therefore they hold any information needed to trade perpetuals.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerPerpetualPosition {
    /// The `Id` of the `Perpetual`.
    #[prost(uint32, tag = "1")]
    pub perpetual_id: u32,
    /// The size of the position in base quantums.
    #[prost(bytes = "vec", tag = "2")]
    pub quantums: ::prost::alloc::vec::Vec<u8>,
    /// The funding_index of the `Perpetual` the last time this position was
    /// settled.
    #[prost(bytes = "vec", tag = "3")]
    pub funding_index: ::prost::alloc::vec::Vec<u8>,
    /// Amount of funding payment (in quote quantums).
    /// Note: 1. this field is not cumulative.
    /// 2. a positive value means funding payment was paid out and
    /// a negative value means funding payment was received.
    #[prost(bytes = "vec", tag = "4")]
    pub funding_payment: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for IndexerPerpetualPosition {
    const NAME: &'static str = "IndexerPerpetualPosition";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerPerpetualPosition".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerPerpetualPosition".into()
    }
}
/// IndexerAssetPosition define an account’s positions of an `Asset`.
/// Therefore they hold any information needed to trade on Spot and Margin.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerAssetPosition {
    /// The `Id` of the `Asset`.
    #[prost(uint32, tag = "1")]
    pub asset_id: u32,
    /// The absolute size of the position in base quantums.
    #[prost(bytes = "vec", tag = "2")]
    pub quantums: ::prost::alloc::vec::Vec<u8>,
    /// The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last
    /// time this position was settled
    /// TODO(DEC-582): pending margin trading being added.
    #[prost(uint64, tag = "3")]
    pub index: u64,
}
impl ::prost::Name for IndexerAssetPosition {
    const NAME: &'static str = "IndexerAssetPosition";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerAssetPosition".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerAssetPosition".into()
    }
}
/// IndexerOrderId refers to a single order belonging to a Subaccount.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerOrderId {
    /// The subaccount ID that opened this order.
    /// Note that this field has `gogoproto.nullable = false` so that it is
    /// generated as a value instead of a pointer. This is because the `OrderId`
    /// proto is used as a key within maps, and map comparisons will compare
    /// pointers for equality (when the desired behavior is to compare the values).
    #[prost(message, optional, tag = "1")]
    pub subaccount_id: ::core::option::Option<IndexerSubaccountId>,
    /// The client ID of this order, unique with respect to the specific
    /// sub account (I.E., the same subaccount can't have two orders with
    /// the same ClientId).
    #[prost(fixed32, tag = "2")]
    pub client_id: u32,
    /// order_flags represent order flags for the order. This field is invalid if
    /// it's greater than 257. Each bit represents a different flag.
    ///
    /// The following are the valid orderId flags:
    /// ShortTerm    = uint32(0)
    /// Conditional  = uint32(32)
    /// LongTerm     = uint32(64)
    /// Twap         = uint32(128)
    /// TwapSuborder = uint32(256) (for internal use only)
    ///
    /// If both bits are set or bits other than the 2nd and 3rd are set, the order
    /// ID is invalid.
    #[prost(uint32, tag = "3")]
    pub order_flags: u32,
    /// ID of the CLOB the order is created for.
    #[prost(uint32, tag = "4")]
    pub clob_pair_id: u32,
}
impl ::prost::Name for IndexerOrderId {
    const NAME: &'static str = "IndexerOrderId";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerOrderId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerOrderId".into()
    }
}
/// IndexerOrderV1 represents a single order belonging to a `Subaccount`
/// for a particular `ClobPair`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerOrder {
    /// The unique ID of this order. Meant to be unique across all orders.
    #[prost(message, optional, tag = "1")]
    pub order_id: ::core::option::Option<IndexerOrderId>,
    #[prost(enumeration = "indexer_order::Side", tag = "2")]
    pub side: i32,
    /// The size of this order in base quantums. Must be a multiple of
    /// `ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).
    #[prost(uint64, tag = "3")]
    pub quantums: u64,
    /// The price level that this order will be placed at on the orderbook,
    /// in subticks. Must be a multiple of ClobPair.SubticksPerTick
    /// (where `ClobPair.Id = orderId.ClobPairId`).
    #[prost(uint64, tag = "4")]
    pub subticks: u64,
    /// The time in force of this order.
    #[prost(enumeration = "indexer_order::TimeInForce", tag = "7")]
    pub time_in_force: i32,
    /// Enforces that the order can only reduce the size of an existing position.
    /// If a ReduceOnly order would change the side of the existing position,
    /// its size is reduced to that of the remaining size of the position.
    /// If existing orders on the book with ReduceOnly
    /// would already close the position, the least aggressive (out-of-the-money)
    /// ReduceOnly orders are resized and canceled first.
    #[prost(bool, tag = "8")]
    pub reduce_only: bool,
    /// Set of bit flags set arbitrarily by clients and ignored by the protocol.
    /// Used by indexer to infer information about a placed order.
    #[prost(uint32, tag = "9")]
    pub client_metadata: u32,
    #[prost(enumeration = "indexer_order::ConditionType", tag = "10")]
    pub condition_type: i32,
    /// conditional_order_trigger_subticks represents the price at which this order
    /// will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,
    /// this value is enforced to be 0. If this value is nonzero, condition_type
    /// cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.
    /// Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =
    /// orderId.ClobPairId`).
    #[prost(uint64, tag = "11")]
    pub conditional_order_trigger_subticks: u64,
    /// builder_code_params is the metadata for the partner or builder of an order.
    #[prost(message, optional, tag = "12")]
    pub builder_code_params: ::core::option::Option<BuilderCodeParameters>,
    /// order_router_address is the address of the order router that forwarded this
    /// order.
    #[prost(string, tag = "13")]
    pub order_router_address: ::prost::alloc::string::String,
    /// twap_parameters represent the configuration for a TWAP order. This must be
    /// set for twap orders and will be ignored for all other order types.
    #[prost(message, optional, tag = "14")]
    pub twap_parameters: ::core::option::Option<TwapParameters>,
    /// Information about when the order expires.
    #[prost(oneof = "indexer_order::GoodTilOneof", tags = "5, 6")]
    pub good_til_oneof: ::core::option::Option<indexer_order::GoodTilOneof>,
}
/// Nested message and enum types in `IndexerOrder`.
pub mod indexer_order {
    /// Represents the side of the orderbook the order will be placed on.
    /// Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be
    /// placed on the orderbook.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Side {
        /// Default value. This value is invalid and unused.
        Unspecified = 0,
        /// SIDE_BUY is used to represent a BUY order.
        Buy = 1,
        /// SIDE_SELL is used to represent a SELL order.
        Sell = 2,
    }
    impl Side {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SIDE_UNSPECIFIED",
                Self::Buy => "SIDE_BUY",
                Self::Sell => "SIDE_SELL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SIDE_UNSPECIFIED" => Some(Self::Unspecified),
                "SIDE_BUY" => Some(Self::Buy),
                "SIDE_SELL" => Some(Self::Sell),
                _ => None,
            }
        }
    }
    /// TimeInForce indicates how long an order will remain active before it
    /// is executed or expires.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeInForce {
        /// TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an
        /// order will first match with existing orders on the book, and any
        /// remaining size will be added to the book as a maker order.
        Unspecified = 0,
        /// TIME_IN_FORCE_IOC enforces that an order only be matched with
        /// maker orders on the book. If the order has remaining size after
        /// matching with existing orders on the book, the remaining size
        /// is not placed on the book.
        Ioc = 1,
        /// TIME_IN_FORCE_POST_ONLY enforces that an order only be placed
        /// on the book as a maker order. Note this means that validators will cancel
        /// any newly-placed post only orders that would cross with other maker
        /// orders.
        PostOnly = 2,
        /// TIME_IN_FORCE_FILL_OR_KILL enforces that an order will either be filled
        /// completely and immediately by maker orders on the book or canceled if the
        /// entire amount can‘t be matched.
        FillOrKill = 3,
    }
    impl TimeInForce {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIME_IN_FORCE_UNSPECIFIED",
                Self::Ioc => "TIME_IN_FORCE_IOC",
                Self::PostOnly => "TIME_IN_FORCE_POST_ONLY",
                Self::FillOrKill => "TIME_IN_FORCE_FILL_OR_KILL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_IN_FORCE_UNSPECIFIED" => Some(Self::Unspecified),
                "TIME_IN_FORCE_IOC" => Some(Self::Ioc),
                "TIME_IN_FORCE_POST_ONLY" => Some(Self::PostOnly),
                "TIME_IN_FORCE_FILL_OR_KILL" => Some(Self::FillOrKill),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConditionType {
        /// CONDITION_TYPE_UNSPECIFIED represents the default behavior where an
        /// order will be placed immediately on the orderbook.
        Unspecified = 0,
        /// CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will
        /// trigger when the oracle price moves at or above the trigger price for
        /// buys, and at or below the trigger price for sells.
        StopLoss = 1,
        /// CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit
        /// order will trigger when the oracle price moves at or below the trigger
        /// price for buys and at or above the trigger price for sells.
        TakeProfit = 2,
    }
    impl ConditionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONDITION_TYPE_UNSPECIFIED",
                Self::StopLoss => "CONDITION_TYPE_STOP_LOSS",
                Self::TakeProfit => "CONDITION_TYPE_TAKE_PROFIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONDITION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONDITION_TYPE_STOP_LOSS" => Some(Self::StopLoss),
                "CONDITION_TYPE_TAKE_PROFIT" => Some(Self::TakeProfit),
                _ => None,
            }
        }
    }
    /// Information about when the order expires.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GoodTilOneof {
        /// The last block this order can be executed at (after which it will be
        /// unfillable). Used only for Short-Term orders. If this value is non-zero
        /// then the order is assumed to be a Short-Term order.
        #[prost(uint32, tag = "5")]
        GoodTilBlock(u32),
        /// good_til_block_time represents the unix timestamp (in seconds) at which a
        /// stateful order will be considered expired. The
        /// good_til_block_time is always evaluated against the previous block's
        /// `BlockTime` instead of the block in which the order is committed. If this
        /// value is non-zero then the order is assumed to be a stateful or
        /// conditional order.
        #[prost(fixed32, tag = "6")]
        GoodTilBlockTime(u32),
    }
}
impl ::prost::Name for IndexerOrder {
    const NAME: &'static str = "IndexerOrder";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerOrder".into()
    }
}
/// TwapParameters represents the necessary configuration for a TWAP order.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TwapParameters {
    /// Duration of the TWAP order execution in seconds. Must be in the range
    /// \[300 (5 minutes), 86400 (24 hours)\].
    #[prost(uint32, tag = "1")]
    pub duration: u32,
    /// Interval in seconds for each suborder to execute. Must be a
    /// whole number, a factor of the duration, and in the range
    /// \[30 (30 seconds), 3600 (1 hour)\].
    #[prost(uint32, tag = "2")]
    pub interval: u32,
    /// Price tolerance in ppm for each suborder. This will be applied to
    /// the oracle price each time a suborder is triggered. Must be
    /// be in the range [0, 1_000_000).
    #[prost(uint32, tag = "3")]
    pub price_tolerance: u32,
}
impl ::prost::Name for TwapParameters {
    const NAME: &'static str = "TwapParameters";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.TwapParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.TwapParameters".into()
    }
}
/// BuilderCodeParameters represents the metadata for the partner or builder of
/// an order. This allows them to specify a fee for providing there service which
/// will be paid out in the event of an order fill.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuilderCodeParameters {
    /// The address of the builder to which the fee will be paid.
    #[prost(string, tag = "1")]
    pub builder_address: ::prost::alloc::string::String,
    /// The fee enforced on the order in ppm.
    #[prost(uint32, tag = "2")]
    pub fee_ppm: u32,
}
impl ::prost::Name for BuilderCodeParameters {
    const NAME: &'static str = "BuilderCodeParameters";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.BuilderCodeParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.BuilderCodeParameters".into()
    }
}
/// Status of the CLOB.
/// Defined in clob.clob_pair
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClobPairStatus {
    /// Default value. This value is invalid and unused.
    Unspecified = 0,
    /// CLOB_PAIR_STATUS_ACTIVE behavior is unfinalized.
    /// TODO(DEC-600): update this documentation.
    Active = 1,
    /// CLOB_PAIR_STATUS_PAUSED behavior is unfinalized.
    /// TODO(DEC-600): update this documentation.
    Paused = 2,
    /// CLOB_PAIR_STATUS_CANCEL_ONLY behavior is unfinalized.
    /// TODO(DEC-600): update this documentation.
    CancelOnly = 3,
    /// CLOB_PAIR_STATUS_POST_ONLY behavior is unfinalized.
    /// TODO(DEC-600): update this documentation.
    PostOnly = 4,
    /// CLOB_PAIR_STATUS_INITIALIZING represents a newly-added clob pair.
    /// Clob pairs in this state only accept orders which are
    /// both short-term and post-only.
    Initializing = 5,
    /// CLOB_PAIR_STATUS_FINAL_SETTLEMENT represents a clob pair that has been
    /// deactivated. Clob pairs in this state do not accept new orders and trading
    /// is blocked. All open positions are closed and open stateful orders canceled
    /// by the protocol when the clob pair transitions to this status. All
    /// short-term orders are left to expire.
    FinalSettlement = 6,
}
impl ClobPairStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOB_PAIR_STATUS_UNSPECIFIED",
            Self::Active => "CLOB_PAIR_STATUS_ACTIVE",
            Self::Paused => "CLOB_PAIR_STATUS_PAUSED",
            Self::CancelOnly => "CLOB_PAIR_STATUS_CANCEL_ONLY",
            Self::PostOnly => "CLOB_PAIR_STATUS_POST_ONLY",
            Self::Initializing => "CLOB_PAIR_STATUS_INITIALIZING",
            Self::FinalSettlement => "CLOB_PAIR_STATUS_FINAL_SETTLEMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOB_PAIR_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "CLOB_PAIR_STATUS_ACTIVE" => Some(Self::Active),
            "CLOB_PAIR_STATUS_PAUSED" => Some(Self::Paused),
            "CLOB_PAIR_STATUS_CANCEL_ONLY" => Some(Self::CancelOnly),
            "CLOB_PAIR_STATUS_POST_ONLY" => Some(Self::PostOnly),
            "CLOB_PAIR_STATUS_INITIALIZING" => Some(Self::Initializing),
            "CLOB_PAIR_STATUS_FINAL_SETTLEMENT" => Some(Self::FinalSettlement),
            _ => None,
        }
    }
}
/// Market type of perpetual.
/// Defined in perpetual.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PerpetualMarketType {
    /// Unspecified market type.
    Unspecified = 0,
    /// Market type for cross margin perpetual markets.
    Cross = 1,
    /// Market type for isolated margin perpetual markets.
    Isolated = 2,
}
impl PerpetualMarketType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PERPETUAL_MARKET_TYPE_UNSPECIFIED",
            Self::Cross => "PERPETUAL_MARKET_TYPE_CROSS",
            Self::Isolated => "PERPETUAL_MARKET_TYPE_ISOLATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERPETUAL_MARKET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PERPETUAL_MARKET_TYPE_CROSS" => Some(Self::Cross),
            "PERPETUAL_MARKET_TYPE_ISOLATED" => Some(Self::Isolated),
            _ => None,
        }
    }
}
/// VaultStatus represents the status of a vault.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VaultStatus {
    /// Default value, invalid and unused.
    Unspecified = 0,
    /// Don’t place orders. Does not count toward global vault balances.
    Deactivated = 1,
    /// Don’t place orders. Does count towards global vault balances.
    StandBy = 2,
    /// Places orders on both sides of the book.
    Quoting = 3,
    /// Only place orders that close the position.
    CloseOnly = 4,
}
impl VaultStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VAULT_STATUS_UNSPECIFIED",
            Self::Deactivated => "VAULT_STATUS_DEACTIVATED",
            Self::StandBy => "VAULT_STATUS_STAND_BY",
            Self::Quoting => "VAULT_STATUS_QUOTING",
            Self::CloseOnly => "VAULT_STATUS_CLOSE_ONLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VAULT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "VAULT_STATUS_DEACTIVATED" => Some(Self::Deactivated),
            "VAULT_STATUS_STAND_BY" => Some(Self::StandBy),
            "VAULT_STATUS_QUOTING" => Some(Self::Quoting),
            "VAULT_STATUS_CLOSE_ONLY" => Some(Self::CloseOnly),
            _ => None,
        }
    }
}
