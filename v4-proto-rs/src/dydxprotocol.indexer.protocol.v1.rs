// This file is @generated by prost-build.
/// IndexerSubaccountId defines a unique identifier for a Subaccount.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerSubaccountId {
    /// The address of the wallet that owns this subaccount.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// < 128 Since 128 should be enough to start and it fits within
    /// 1 Byte (1 Bit needed to indicate that the first byte is the last).
    #[prost(uint32, tag = "2")]
    pub number: u32,
}
impl ::prost::Name for IndexerSubaccountId {
    const NAME: &'static str = "IndexerSubaccountId";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerSubaccountId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerSubaccountId".into()
    }
}
/// IndexerPerpetualPosition are an account’s positions of a `Perpetual`.
/// Therefore they hold any information needed to trade perpetuals.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerPerpetualPosition {
    /// The `Id` of the `Perpetual`.
    #[prost(uint32, tag = "1")]
    pub perpetual_id: u32,
    /// The size of the position in base quantums.
    #[prost(bytes = "vec", tag = "2")]
    pub quantums: ::prost::alloc::vec::Vec<u8>,
    /// The funding_index of the `Perpetual` the last time this position was
    /// settled.
    #[prost(bytes = "vec", tag = "3")]
    pub funding_index: ::prost::alloc::vec::Vec<u8>,
    /// Amount of funding payment (in quote quantums).
    /// Note: 1. this field is not cumulative.
    /// 2. a positive value means funding payment was paid out and
    /// a negative value means funding payment was received.
    #[prost(bytes = "vec", tag = "4")]
    pub funding_payment: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for IndexerPerpetualPosition {
    const NAME: &'static str = "IndexerPerpetualPosition";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerPerpetualPosition".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerPerpetualPosition".into()
    }
}
/// IndexerAssetPosition define an account’s positions of an `Asset`.
/// Therefore they hold any information needed to trade on Spot and Margin.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerAssetPosition {
    /// The `Id` of the `Asset`.
    #[prost(uint32, tag = "1")]
    pub asset_id: u32,
    /// The absolute size of the position in base quantums.
    #[prost(bytes = "vec", tag = "2")]
    pub quantums: ::prost::alloc::vec::Vec<u8>,
    /// The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last
    /// time this position was settled
    /// TODO(DEC-582): pending margin trading being added.
    #[prost(uint64, tag = "3")]
    pub index: u64,
}
impl ::prost::Name for IndexerAssetPosition {
    const NAME: &'static str = "IndexerAssetPosition";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerAssetPosition".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerAssetPosition".into()
    }
}
/// IndexerOrderId refers to a single order belonging to a Subaccount.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerOrderId {
    /// The subaccount ID that opened this order.
    /// Note that this field has `gogoproto.nullable = false` so that it is
    /// generated as a value instead of a pointer. This is because the `OrderId`
    /// proto is used as a key within maps, and map comparisons will compare
    /// pointers for equality (when the desired behavior is to compare the values).
    #[prost(message, optional, tag = "1")]
    pub subaccount_id: ::core::option::Option<IndexerSubaccountId>,
    /// The client ID of this order, unique with respect to the specific
    /// sub account (I.E., the same subaccount can't have two orders with
    /// the same ClientId).
    #[prost(fixed32, tag = "2")]
    pub client_id: u32,
    /// order_flags represent order flags for the order. This field is invalid if
    /// it's greater than 127 (larger than one byte). Each bit in the first byte
    /// represents a different flag. Currently only two flags are supported.
    ///
    /// Starting from the bit after the most MSB (note that the MSB is used in
    /// proto varint encoding, and therefore cannot be used): Bit 1 is set if this
    /// order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this
    /// order is a Conditional order (0x20, or 32 as a uint8).
    ///
    /// If neither bit is set, the order is assumed to be a Short-Term order.
    ///
    /// If both bits are set or bits other than the 2nd and 3rd are set, the order
    /// ID is invalid.
    #[prost(uint32, tag = "3")]
    pub order_flags: u32,
    /// ID of the CLOB the order is created for.
    #[prost(uint32, tag = "4")]
    pub clob_pair_id: u32,
}
impl ::prost::Name for IndexerOrderId {
    const NAME: &'static str = "IndexerOrderId";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerOrderId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerOrderId".into()
    }
}
/// IndexerOrderV1 represents a single order belonging to a `Subaccount`
/// for a particular `ClobPair`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerOrder {
    /// The unique ID of this order. Meant to be unique across all orders.
    #[prost(message, optional, tag = "1")]
    pub order_id: ::core::option::Option<IndexerOrderId>,
    #[prost(enumeration = "indexer_order::Side", tag = "2")]
    pub side: i32,
    /// The size of this order in base quantums. Must be a multiple of
    /// `ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).
    #[prost(uint64, tag = "3")]
    pub quantums: u64,
    /// The price level that this order will be placed at on the orderbook,
    /// in subticks. Must be a multiple of ClobPair.SubticksPerTick
    /// (where `ClobPair.Id = orderId.ClobPairId`).
    #[prost(uint64, tag = "4")]
    pub subticks: u64,
    /// The time in force of this order.
    #[prost(enumeration = "indexer_order::TimeInForce", tag = "7")]
    pub time_in_force: i32,
    /// Enforces that the order can only reduce the size of an existing position.
    /// If a ReduceOnly order would change the side of the existing position,
    /// its size is reduced to that of the remaining size of the position.
    /// If existing orders on the book with ReduceOnly
    /// would already close the position, the least aggressive (out-of-the-money)
    /// ReduceOnly orders are resized and canceled first.
    #[prost(bool, tag = "8")]
    pub reduce_only: bool,
    /// Set of bit flags set arbitrarily by clients and ignored by the protocol.
    /// Used by indexer to infer information about a placed order.
    #[prost(uint32, tag = "9")]
    pub client_metadata: u32,
    #[prost(enumeration = "indexer_order::ConditionType", tag = "10")]
    pub condition_type: i32,
    /// conditional_order_trigger_subticks represents the price at which this order
    /// will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,
    /// this value is enforced to be 0. If this value is nonzero, condition_type
    /// cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.
    /// Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =
    /// orderId.ClobPairId`).
    #[prost(uint64, tag = "11")]
    pub conditional_order_trigger_subticks: u64,
    /// Information about when the order expires.
    #[prost(oneof = "indexer_order::GoodTilOneof", tags = "5, 6")]
    pub good_til_oneof: ::core::option::Option<indexer_order::GoodTilOneof>,
}
/// Nested message and enum types in `IndexerOrder`.
pub mod indexer_order {
    /// Represents the side of the orderbook the order will be placed on.
    /// Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be
    /// placed on the orderbook.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Side {
        /// Default value. This value is invalid and unused.
        Unspecified = 0,
        /// SIDE_BUY is used to represent a BUY order.
        Buy = 1,
        /// SIDE_SELL is used to represent a SELL order.
        Sell = 2,
    }
    impl Side {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Side::Unspecified => "SIDE_UNSPECIFIED",
                Side::Buy => "SIDE_BUY",
                Side::Sell => "SIDE_SELL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SIDE_UNSPECIFIED" => Some(Self::Unspecified),
                "SIDE_BUY" => Some(Self::Buy),
                "SIDE_SELL" => Some(Self::Sell),
                _ => None,
            }
        }
    }
    /// TimeInForce indicates how long an order will remain active before it
    /// is executed or expires.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeInForce {
        /// TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an
        /// order will first match with existing orders on the book, and any
        /// remaining size will be added to the book as a maker order.
        Unspecified = 0,
        /// TIME_IN_FORCE_IOC enforces that an order only be matched with
        /// maker orders on the book. If the order has remaining size after
        /// matching with existing orders on the book, the remaining size
        /// is not placed on the book.
        Ioc = 1,
        /// TIME_IN_FORCE_POST_ONLY enforces that an order only be placed
        /// on the book as a maker order. Note this means that validators will cancel
        /// any newly-placed post only orders that would cross with other maker
        /// orders.
        PostOnly = 2,
        /// TIME_IN_FORCE_FILL_OR_KILL enforces that an order will either be filled
        /// completely and immediately by maker orders on the book or canceled if the
        /// entire amount can‘t be matched.
        FillOrKill = 3,
    }
    impl TimeInForce {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TimeInForce::Unspecified => "TIME_IN_FORCE_UNSPECIFIED",
                TimeInForce::Ioc => "TIME_IN_FORCE_IOC",
                TimeInForce::PostOnly => "TIME_IN_FORCE_POST_ONLY",
                TimeInForce::FillOrKill => "TIME_IN_FORCE_FILL_OR_KILL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_IN_FORCE_UNSPECIFIED" => Some(Self::Unspecified),
                "TIME_IN_FORCE_IOC" => Some(Self::Ioc),
                "TIME_IN_FORCE_POST_ONLY" => Some(Self::PostOnly),
                "TIME_IN_FORCE_FILL_OR_KILL" => Some(Self::FillOrKill),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConditionType {
        /// CONDITION_TYPE_UNSPECIFIED represents the default behavior where an
        /// order will be placed immediately on the orderbook.
        Unspecified = 0,
        /// CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will
        /// trigger when the oracle price moves at or above the trigger price for
        /// buys, and at or below the trigger price for sells.
        StopLoss = 1,
        /// CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit
        /// order will trigger when the oracle price moves at or below the trigger
        /// price for buys and at or above the trigger price for sells.
        TakeProfit = 2,
    }
    impl ConditionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConditionType::Unspecified => "CONDITION_TYPE_UNSPECIFIED",
                ConditionType::StopLoss => "CONDITION_TYPE_STOP_LOSS",
                ConditionType::TakeProfit => "CONDITION_TYPE_TAKE_PROFIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONDITION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONDITION_TYPE_STOP_LOSS" => Some(Self::StopLoss),
                "CONDITION_TYPE_TAKE_PROFIT" => Some(Self::TakeProfit),
                _ => None,
            }
        }
    }
    /// Information about when the order expires.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GoodTilOneof {
        /// The last block this order can be executed at (after which it will be
        /// unfillable). Used only for Short-Term orders. If this value is non-zero
        /// then the order is assumed to be a Short-Term order.
        #[prost(uint32, tag = "5")]
        GoodTilBlock(u32),
        /// good_til_block_time represents the unix timestamp (in seconds) at which a
        /// stateful order will be considered expired. The
        /// good_til_block_time is always evaluated against the previous block's
        /// `BlockTime` instead of the block in which the order is committed. If this
        /// value is non-zero then the order is assumed to be a stateful or
        /// conditional order.
        #[prost(fixed32, tag = "6")]
        GoodTilBlockTime(u32),
    }
}
impl ::prost::Name for IndexerOrder {
    const NAME: &'static str = "IndexerOrder";
    const PACKAGE: &'static str = "dydxprotocol.indexer.protocol.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.protocol.v1.IndexerOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.protocol.v1.IndexerOrder".into()
    }
}
/// Status of the CLOB.
/// Defined in clob.clob_pair
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClobPairStatus {
    /// Default value. This value is invalid and unused.
    Unspecified = 0,
    /// CLOB_PAIR_STATUS_ACTIVE behavior is unfinalized.
    /// TODO(DEC-600): update this documentation.
    Active = 1,
    /// CLOB_PAIR_STATUS_PAUSED behavior is unfinalized.
    /// TODO(DEC-600): update this documentation.
    Paused = 2,
    /// CLOB_PAIR_STATUS_CANCEL_ONLY behavior is unfinalized.
    /// TODO(DEC-600): update this documentation.
    CancelOnly = 3,
    /// CLOB_PAIR_STATUS_POST_ONLY behavior is unfinalized.
    /// TODO(DEC-600): update this documentation.
    PostOnly = 4,
    /// CLOB_PAIR_STATUS_INITIALIZING represents a newly-added clob pair.
    /// Clob pairs in this state only accept orders which are
    /// both short-term and post-only.
    Initializing = 5,
    /// CLOB_PAIR_STATUS_FINAL_SETTLEMENT represents a clob pair that has been
    /// deactivated. Clob pairs in this state do not accept new orders and trading
    /// is blocked. All open positions are closed and open stateful orders canceled
    /// by the protocol when the clob pair transitions to this status. All
    /// short-term orders are left to expire.
    FinalSettlement = 6,
}
impl ClobPairStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ClobPairStatus::Unspecified => "CLOB_PAIR_STATUS_UNSPECIFIED",
            ClobPairStatus::Active => "CLOB_PAIR_STATUS_ACTIVE",
            ClobPairStatus::Paused => "CLOB_PAIR_STATUS_PAUSED",
            ClobPairStatus::CancelOnly => "CLOB_PAIR_STATUS_CANCEL_ONLY",
            ClobPairStatus::PostOnly => "CLOB_PAIR_STATUS_POST_ONLY",
            ClobPairStatus::Initializing => "CLOB_PAIR_STATUS_INITIALIZING",
            ClobPairStatus::FinalSettlement => "CLOB_PAIR_STATUS_FINAL_SETTLEMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOB_PAIR_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "CLOB_PAIR_STATUS_ACTIVE" => Some(Self::Active),
            "CLOB_PAIR_STATUS_PAUSED" => Some(Self::Paused),
            "CLOB_PAIR_STATUS_CANCEL_ONLY" => Some(Self::CancelOnly),
            "CLOB_PAIR_STATUS_POST_ONLY" => Some(Self::PostOnly),
            "CLOB_PAIR_STATUS_INITIALIZING" => Some(Self::Initializing),
            "CLOB_PAIR_STATUS_FINAL_SETTLEMENT" => Some(Self::FinalSettlement),
            _ => None,
        }
    }
}
/// Market type of perpetual.
/// Defined in perpetual.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PerpetualMarketType {
    /// Unspecified market type.
    Unspecified = 0,
    /// Market type for cross margin perpetual markets.
    Cross = 1,
    /// Market type for isolated margin perpetual markets.
    Isolated = 2,
}
impl PerpetualMarketType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PerpetualMarketType::Unspecified => "PERPETUAL_MARKET_TYPE_UNSPECIFIED",
            PerpetualMarketType::Cross => "PERPETUAL_MARKET_TYPE_CROSS",
            PerpetualMarketType::Isolated => "PERPETUAL_MARKET_TYPE_ISOLATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERPETUAL_MARKET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PERPETUAL_MARKET_TYPE_CROSS" => Some(Self::Cross),
            "PERPETUAL_MARKET_TYPE_ISOLATED" => Some(Self::Isolated),
            _ => None,
        }
    }
}
