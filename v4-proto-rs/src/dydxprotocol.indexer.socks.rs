// This file is @generated by prost-build.
/// Message to be sent through the 'to-websockets-orderbooks` kafka topic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderbookMessage {
    /// Stringified JSON object of all events to be streamed.
    #[prost(string, tag = "1")]
    pub contents: ::prost::alloc::string::String,
    /// Clob pair id of the Orderbook message.
    #[prost(string, tag = "2")]
    pub clob_pair_id: ::prost::alloc::string::String,
    /// Version of the websocket message.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for OrderbookMessage {
    const NAME: &'static str = "OrderbookMessage";
    const PACKAGE: &'static str = "dydxprotocol.indexer.socks";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.socks.OrderbookMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.socks.OrderbookMessage".into()
    }
}
/// Message to be sent through the 'to-websockets-subaccounts` kafka topic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubaccountMessage {
    /// Block height where the contents occur.
    #[prost(string, tag = "1")]
    pub block_height: ::prost::alloc::string::String,
    /// Transaction index where the contents occur.
    #[prost(int32, tag = "2")]
    pub transaction_index: i32,
    /// Event index where the contents occur.
    #[prost(uint32, tag = "3")]
    pub event_index: u32,
    /// Stringified JSON object of all events to be streamed.
    #[prost(string, tag = "4")]
    pub contents: ::prost::alloc::string::String,
    /// Subaccount id that the content corresponds to.
    #[prost(message, optional, tag = "5")]
    pub subaccount_id: ::core::option::Option<super::protocol::v1::IndexerSubaccountId>,
    /// Version of the websocket message.
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for SubaccountMessage {
    const NAME: &'static str = "SubaccountMessage";
    const PACKAGE: &'static str = "dydxprotocol.indexer.socks";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.socks.SubaccountMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.socks.SubaccountMessage".into()
    }
}
/// Message to be sent through the 'to-websockets-trades` kafka topic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradeMessage {
    /// Block height where the contents occur.
    #[prost(string, tag = "1")]
    pub block_height: ::prost::alloc::string::String,
    /// Stringified JSON object of all events to be streamed.
    #[prost(string, tag = "4")]
    pub contents: ::prost::alloc::string::String,
    /// Clob pair id of the Trade message.
    #[prost(string, tag = "5")]
    pub clob_pair_id: ::prost::alloc::string::String,
    /// Version of the websocket message.
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for TradeMessage {
    const NAME: &'static str = "TradeMessage";
    const PACKAGE: &'static str = "dydxprotocol.indexer.socks";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.socks.TradeMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.socks.TradeMessage".into()
    }
}
/// Message to be sent through the 'to-websockets-markets` kafka topic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketMessage {
    /// Stringified JSON object of all events to be streamed.
    #[prost(string, tag = "1")]
    pub contents: ::prost::alloc::string::String,
    /// Version of the websocket message.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for MarketMessage {
    const NAME: &'static str = "MarketMessage";
    const PACKAGE: &'static str = "dydxprotocol.indexer.socks";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.socks.MarketMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.socks.MarketMessage".into()
    }
}
/// Message to be sent through the 'to-websockets-candles` kafka topic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CandleMessage {
    /// Stringified JSON object of all events to be streamed.
    #[prost(string, tag = "1")]
    pub contents: ::prost::alloc::string::String,
    /// Clob pair id of the Candle message.
    #[prost(string, tag = "2")]
    pub clob_pair_id: ::prost::alloc::string::String,
    /// Resolution of the candle update.
    #[prost(enumeration = "candle_message::Resolution", tag = "3")]
    pub resolution: i32,
    /// Version of the websocket message.
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CandleMessage`.
pub mod candle_message {
    /// TODO(IND-210): Make this proto conform and update downstream indexer logic
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Resolution {
        /// buf:lint:ignore ENUM_VALUE_PREFIX
        /// buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
        OneMinute = 0,
        /// buf:lint:ignore ENUM_VALUE_PREFIX
        FiveMinutes = 1,
        /// buf:lint:ignore ENUM_VALUE_PREFIX
        FifteenMinutes = 2,
        /// buf:lint:ignore ENUM_VALUE_PREFIX
        ThirtyMinutes = 3,
        /// buf:lint:ignore ENUM_VALUE_PREFIX
        OneHour = 4,
        /// buf:lint:ignore ENUM_VALUE_PREFIX
        FourHours = 5,
        /// buf:lint:ignore ENUM_VALUE_PREFIX
        OneDay = 6,
    }
    impl Resolution {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Resolution::OneMinute => "ONE_MINUTE",
                Resolution::FiveMinutes => "FIVE_MINUTES",
                Resolution::FifteenMinutes => "FIFTEEN_MINUTES",
                Resolution::ThirtyMinutes => "THIRTY_MINUTES",
                Resolution::OneHour => "ONE_HOUR",
                Resolution::FourHours => "FOUR_HOURS",
                Resolution::OneDay => "ONE_DAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ONE_MINUTE" => Some(Self::OneMinute),
                "FIVE_MINUTES" => Some(Self::FiveMinutes),
                "FIFTEEN_MINUTES" => Some(Self::FifteenMinutes),
                "THIRTY_MINUTES" => Some(Self::ThirtyMinutes),
                "ONE_HOUR" => Some(Self::OneHour),
                "FOUR_HOURS" => Some(Self::FourHours),
                "ONE_DAY" => Some(Self::OneDay),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for CandleMessage {
    const NAME: &'static str = "CandleMessage";
    const PACKAGE: &'static str = "dydxprotocol.indexer.socks";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.socks.CandleMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.socks.CandleMessage".into()
    }
}
