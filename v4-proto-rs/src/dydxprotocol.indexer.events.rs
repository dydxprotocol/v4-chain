// This file is @generated by prost-build.
/// FundingUpdate is used for funding update events and includes a funding
/// value and an optional funding index that correspond to a perpetual market.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FundingUpdateV1 {
    /// The id of the perpetual market.
    #[prost(uint32, tag = "1")]
    pub perpetual_id: u32,
    /// funding value (in parts-per-million) can be premium vote, premium sample,
    /// or funding rate.
    #[prost(int32, tag = "2")]
    pub funding_value_ppm: i32,
    /// funding index is required if and only if parent `FundingEvent` type is
    /// `TYPE_FUNDING_RATE_AND_INDEX`.
    #[prost(bytes = "vec", tag = "3")]
    pub funding_index: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for FundingUpdateV1 {
    const NAME: &'static str = "FundingUpdateV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.FundingUpdateV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.FundingUpdateV1".into()
    }
}
/// FundingEvent message contains a list of per-market funding values. The
/// funding values in the list is of the same type and the types are: which can
/// have one of the following types:
/// 1. Premium vote: votes on the premium values injected by block proposers.
/// 2. Premium sample: combined value from all premium votes during a
///     `funding-sample` epoch.
/// 3. Funding rate and index: final funding rate combining all premium samples
///     during a `funding-tick` epoch and funding index accordingly updated with
///     `funding rate * price`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FundingEventV1 {
    /// updates is a list of per-market funding updates for all existing perpetual
    /// markets. The list is sorted by `perpetualId`s which are unique.
    #[prost(message, repeated, tag = "1")]
    pub updates: ::prost::alloc::vec::Vec<FundingUpdateV1>,
    /// type stores the type of funding updates.
    #[prost(enumeration = "funding_event_v1::Type", tag = "2")]
    pub r#type: i32,
}
/// Nested message and enum types in `FundingEventV1`.
pub mod funding_event_v1 {
    /// Type is the type for funding values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Unspecified type.
        Unspecified = 0,
        /// Premium sample is the combined value from all premium votes during a
        /// `funding-sample` epoch.
        PremiumSample = 1,
        /// Funding rate is the final funding rate combining all premium samples
        /// during a `funding-tick` epoch.
        FundingRateAndIndex = 2,
        /// TODO(DEC-1513): Investigate whether premium vote values need to be
        /// sent to indexer.
        PremiumVote = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::PremiumSample => "TYPE_PREMIUM_SAMPLE",
                Type::FundingRateAndIndex => "TYPE_FUNDING_RATE_AND_INDEX",
                Type::PremiumVote => "TYPE_PREMIUM_VOTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_PREMIUM_SAMPLE" => Some(Self::PremiumSample),
                "TYPE_FUNDING_RATE_AND_INDEX" => Some(Self::FundingRateAndIndex),
                "TYPE_PREMIUM_VOTE" => Some(Self::PremiumVote),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for FundingEventV1 {
    const NAME: &'static str = "FundingEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.FundingEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.FundingEventV1".into()
    }
}
/// MarketEvent message contains all the information about a market event on
/// the dYdX chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketEventV1 {
    /// market id.
    #[prost(uint32, tag = "1")]
    pub market_id: u32,
    /// either an event for price update, market creation, or market modification.
    #[prost(oneof = "market_event_v1::Event", tags = "2, 3, 4")]
    pub event: ::core::option::Option<market_event_v1::Event>,
}
/// Nested message and enum types in `MarketEventV1`.
pub mod market_event_v1 {
    /// either an event for price update, market creation, or market modification.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "2")]
        PriceUpdate(super::MarketPriceUpdateEventV1),
        #[prost(message, tag = "3")]
        MarketCreate(super::MarketCreateEventV1),
        #[prost(message, tag = "4")]
        MarketModify(super::MarketModifyEventV1),
    }
}
impl ::prost::Name for MarketEventV1 {
    const NAME: &'static str = "MarketEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.MarketEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.MarketEventV1".into()
    }
}
/// MarketPriceUpdateEvent message contains all the information about a price
/// update on the dYdX chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketPriceUpdateEventV1 {
    /// price_with_exponent. Multiply by 10 ^ Exponent to get the human readable
    /// price in dollars. For example if `Exponent == -5` then a `exponent_price`
    /// of `1,000,000,000` represents â€œ$10,000`.
    #[prost(uint64, tag = "1")]
    pub price_with_exponent: u64,
}
impl ::prost::Name for MarketPriceUpdateEventV1 {
    const NAME: &'static str = "MarketPriceUpdateEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.MarketPriceUpdateEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.MarketPriceUpdateEventV1".into()
    }
}
/// shared fields between MarketCreateEvent and MarketModifyEvent
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketBaseEventV1 {
    /// String representation of the market pair, e.g. `BTC-USD`
    #[prost(string, tag = "1")]
    pub pair: ::prost::alloc::string::String,
    /// The minimum allowable change in the Price value for a given update.
    /// Measured as 1e-6.
    #[prost(uint32, tag = "2")]
    pub min_price_change_ppm: u32,
}
impl ::prost::Name for MarketBaseEventV1 {
    const NAME: &'static str = "MarketBaseEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.MarketBaseEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.MarketBaseEventV1".into()
    }
}
/// MarketCreateEvent message contains all the information about a new market on
/// the dYdX chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketCreateEventV1 {
    #[prost(message, optional, tag = "1")]
    pub base: ::core::option::Option<MarketBaseEventV1>,
    /// Static value. The exponent of the price.
    /// For example if Exponent == -5 then a `exponent_price` of 1,000,000,000
    /// represents $10,000. Therefore 10 ^ Exponent represents the smallest
    /// price step (in dollars) that can be recorded.
    #[prost(sint32, tag = "2")]
    pub exponent: i32,
}
impl ::prost::Name for MarketCreateEventV1 {
    const NAME: &'static str = "MarketCreateEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.MarketCreateEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.MarketCreateEventV1".into()
    }
}
/// MarketModifyEvent message contains all the information about a market update
/// on the dYdX chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketModifyEventV1 {
    #[prost(message, optional, tag = "1")]
    pub base: ::core::option::Option<MarketBaseEventV1>,
}
impl ::prost::Name for MarketModifyEventV1 {
    const NAME: &'static str = "MarketModifyEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.MarketModifyEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.MarketModifyEventV1".into()
    }
}
/// SourceOfFunds is the source of funds in a transfer event.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceOfFunds {
    ///   one of below
    /// - a subaccount ID
    /// - a wallet address
    #[prost(oneof = "source_of_funds::Source", tags = "1, 2")]
    pub source: ::core::option::Option<source_of_funds::Source>,
}
/// Nested message and enum types in `SourceOfFunds`.
pub mod source_of_funds {
    ///   one of below
    /// - a subaccount ID
    /// - a wallet address
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        SubaccountId(super::super::protocol::v1::IndexerSubaccountId),
        #[prost(string, tag = "2")]
        Address(::prost::alloc::string::String),
    }
}
impl ::prost::Name for SourceOfFunds {
    const NAME: &'static str = "SourceOfFunds";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.SourceOfFunds".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.SourceOfFunds".into()
    }
}
/// TransferEvent message contains all the information about a transfer,
/// deposit-to-subaccount, or withdraw-from-subaccount on the dYdX chain.
/// When a subaccount is involved, a SubaccountUpdateEvent message will
/// be produced with the updated asset positions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferEventV1 {
    #[prost(message, optional, tag = "1")]
    pub sender_subaccount_id: ::core::option::Option<
        super::protocol::v1::IndexerSubaccountId,
    >,
    #[prost(message, optional, tag = "2")]
    pub recipient_subaccount_id: ::core::option::Option<
        super::protocol::v1::IndexerSubaccountId,
    >,
    /// Id of the asset transfered.
    #[prost(uint32, tag = "3")]
    pub asset_id: u32,
    /// The amount of asset in quantums to transfer.
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    /// The sender is one of below
    /// - a subaccount ID (in transfer and withdraw events).
    /// - a wallet address (in deposit events).
    #[prost(message, optional, tag = "5")]
    pub sender: ::core::option::Option<SourceOfFunds>,
    /// The recipient is one of below
    /// - a subaccount ID (in transfer and deposit events).
    /// - a wallet address (in withdraw events).
    #[prost(message, optional, tag = "6")]
    pub recipient: ::core::option::Option<SourceOfFunds>,
}
impl ::prost::Name for TransferEventV1 {
    const NAME: &'static str = "TransferEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.TransferEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.TransferEventV1".into()
    }
}
/// OrderFillEvent message contains all the information from an order match in
/// the dYdX chain. This includes the maker/taker orders that matched and the
/// amount filled.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderFillEventV1 {
    #[prost(message, optional, tag = "1")]
    pub maker_order: ::core::option::Option<super::protocol::v1::IndexerOrder>,
    /// Fill amount in base quantums.
    #[prost(uint64, tag = "3")]
    pub fill_amount: u64,
    /// Maker fee in USDC quantums.
    #[prost(sint64, tag = "5")]
    pub maker_fee: i64,
    /// Taker fee in USDC quantums. If the taker order is a liquidation, then this
    /// represents the special liquidation fee, not the standard taker fee.
    #[prost(sint64, tag = "6")]
    pub taker_fee: i64,
    /// Total filled of the maker order in base quantums.
    #[prost(uint64, tag = "7")]
    pub total_filled_maker: u64,
    /// Total filled of the taker order in base quantums.
    #[prost(uint64, tag = "8")]
    pub total_filled_taker: u64,
    /// The type of order fill this event represents.
    #[prost(oneof = "order_fill_event_v1::TakerOrder", tags = "2, 4")]
    pub taker_order: ::core::option::Option<order_fill_event_v1::TakerOrder>,
}
/// Nested message and enum types in `OrderFillEventV1`.
pub mod order_fill_event_v1 {
    /// The type of order fill this event represents.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TakerOrder {
        #[prost(message, tag = "2")]
        Order(super::super::protocol::v1::IndexerOrder),
        #[prost(message, tag = "4")]
        LiquidationOrder(super::LiquidationOrderV1),
    }
}
impl ::prost::Name for OrderFillEventV1 {
    const NAME: &'static str = "OrderFillEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.OrderFillEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.OrderFillEventV1".into()
    }
}
/// DeleveragingEvent message contains all the information for a deleveraging
/// on the dYdX chain. This includes the liquidated/offsetting subaccounts and
/// the amount filled.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleveragingEventV1 {
    /// ID of the subaccount that was liquidated.
    #[prost(message, optional, tag = "1")]
    pub liquidated: ::core::option::Option<super::protocol::v1::IndexerSubaccountId>,
    /// ID of the subaccount that was used to offset the position.
    #[prost(message, optional, tag = "2")]
    pub offsetting: ::core::option::Option<super::protocol::v1::IndexerSubaccountId>,
    /// The ID of the perpetual that was liquidated.
    #[prost(uint32, tag = "3")]
    pub perpetual_id: u32,
    /// The amount filled between the liquidated and offsetting position, in
    /// base quantums.
    #[prost(uint64, tag = "4")]
    pub fill_amount: u64,
    /// Total quote quantums filled.
    #[prost(uint64, tag = "5")]
    pub total_quote_quantums: u64,
    /// `true` if liquidating a short position, `false` otherwise.
    #[prost(bool, tag = "6")]
    pub is_buy: bool,
    /// `true` if the deleveraging event is for final settlement, indicating
    /// the match occurred at the oracle price rather than bankruptcy price.
    /// When this flag is `false`, the fill price is the bankruptcy price
    /// of the liquidated subaccount.
    #[prost(bool, tag = "7")]
    pub is_final_settlement: bool,
}
impl ::prost::Name for DeleveragingEventV1 {
    const NAME: &'static str = "DeleveragingEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.DeleveragingEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.DeleveragingEventV1".into()
    }
}
/// LiquidationOrder represents the liquidation taker order to be included in a
/// liquidation order fill event.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiquidationOrderV1 {
    /// ID of the subaccount that was liquidated.
    #[prost(message, optional, tag = "1")]
    pub liquidated: ::core::option::Option<super::protocol::v1::IndexerSubaccountId>,
    /// The ID of the clob pair involved in the liquidation.
    #[prost(uint32, tag = "2")]
    pub clob_pair_id: u32,
    /// The ID of the perpetual involved in the liquidation.
    #[prost(uint32, tag = "3")]
    pub perpetual_id: u32,
    /// The total size of the liquidation order including any unfilled size,
    /// in base quantums.
    #[prost(uint64, tag = "4")]
    pub total_size: u64,
    /// `true` if liquidating a short position, `false` otherwise.
    #[prost(bool, tag = "5")]
    pub is_buy: bool,
    /// The fillable price in subticks.
    /// This represents the lower-price-bound for liquidating longs
    /// and the upper-price-bound for liquidating shorts.
    /// Must be a multiple of ClobPair.SubticksPerTick
    /// (where `ClobPair.Id = orderId.ClobPairId`).
    #[prost(uint64, tag = "6")]
    pub subticks: u64,
}
impl ::prost::Name for LiquidationOrderV1 {
    const NAME: &'static str = "LiquidationOrderV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.LiquidationOrderV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.LiquidationOrderV1".into()
    }
}
/// SubaccountUpdateEvent message contains information about an update to a
/// subaccount in the dYdX chain. This includes the list of updated perpetual
/// and asset positions for the subaccount.
/// Note: This event message will contain all the updates to a subaccount
/// at the end of a block which is why multiple asset/perpetual position
/// updates may exist.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubaccountUpdateEventV1 {
    #[prost(message, optional, tag = "1")]
    pub subaccount_id: ::core::option::Option<super::protocol::v1::IndexerSubaccountId>,
    /// updated_perpetual_positions will each be for unique perpetuals.
    #[prost(message, repeated, tag = "3")]
    pub updated_perpetual_positions: ::prost::alloc::vec::Vec<
        super::protocol::v1::IndexerPerpetualPosition,
    >,
    /// updated_asset_positions will each be for unique assets.
    #[prost(message, repeated, tag = "4")]
    pub updated_asset_positions: ::prost::alloc::vec::Vec<
        super::protocol::v1::IndexerAssetPosition,
    >,
}
impl ::prost::Name for SubaccountUpdateEventV1 {
    const NAME: &'static str = "SubaccountUpdateEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.SubaccountUpdateEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.SubaccountUpdateEventV1".into()
    }
}
/// StatefulOrderEvent message contains information about a change to a stateful
/// order. Currently, this is either the placement of a long-term order, the
/// placement or triggering of a conditional order, or the removal of a
/// stateful order.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatefulOrderEventV1 {
    /// The type of event that this StatefulOrderEvent contains.
    #[prost(oneof = "stateful_order_event_v1::Event", tags = "1, 4, 5, 6, 7, 8")]
    pub event: ::core::option::Option<stateful_order_event_v1::Event>,
}
/// Nested message and enum types in `StatefulOrderEventV1`.
pub mod stateful_order_event_v1 {
    /// A stateful order placement contains an order.
    /// Deprecated in favor of LongTermOrderPlacementV1.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatefulOrderPlacementV1 {
        #[prost(message, optional, tag = "1")]
        pub order: ::core::option::Option<super::super::protocol::v1::IndexerOrder>,
    }
    impl ::prost::Name for StatefulOrderPlacementV1 {
        const NAME: &'static str = "StatefulOrderPlacementV1";
        const PACKAGE: &'static str = "dydxprotocol.indexer.events";
        fn full_name() -> ::prost::alloc::string::String {
            "dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderPlacementV1"
                .into()
        }
    }
    /// A stateful order removal contains the id of an order that was already
    /// placed and is now removed and the reason for the removal.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatefulOrderRemovalV1 {
        #[prost(message, optional, tag = "1")]
        pub removed_order_id: ::core::option::Option<
            super::super::protocol::v1::IndexerOrderId,
        >,
        #[prost(enumeration = "super::super::shared::OrderRemovalReason", tag = "2")]
        pub reason: i32,
    }
    impl ::prost::Name for StatefulOrderRemovalV1 {
        const NAME: &'static str = "StatefulOrderRemovalV1";
        const PACKAGE: &'static str = "dydxprotocol.indexer.events";
        fn full_name() -> ::prost::alloc::string::String {
            "dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/dydxprotocol.indexer.events.StatefulOrderEventV1.StatefulOrderRemovalV1"
                .into()
        }
    }
    /// A conditional order placement contains an order. The order is newly-placed
    /// and untriggered when this event is emitted.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConditionalOrderPlacementV1 {
        #[prost(message, optional, tag = "1")]
        pub order: ::core::option::Option<super::super::protocol::v1::IndexerOrder>,
    }
    impl ::prost::Name for ConditionalOrderPlacementV1 {
        const NAME: &'static str = "ConditionalOrderPlacementV1";
        const PACKAGE: &'static str = "dydxprotocol.indexer.events";
        fn full_name() -> ::prost::alloc::string::String {
            "dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderPlacementV1"
                .into()
        }
    }
    /// A conditional order trigger event contains an order id and is emitted when
    /// an order is triggered.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConditionalOrderTriggeredV1 {
        #[prost(message, optional, tag = "1")]
        pub triggered_order_id: ::core::option::Option<
            super::super::protocol::v1::IndexerOrderId,
        >,
    }
    impl ::prost::Name for ConditionalOrderTriggeredV1 {
        const NAME: &'static str = "ConditionalOrderTriggeredV1";
        const PACKAGE: &'static str = "dydxprotocol.indexer.events";
        fn full_name() -> ::prost::alloc::string::String {
            "dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/dydxprotocol.indexer.events.StatefulOrderEventV1.ConditionalOrderTriggeredV1"
                .into()
        }
    }
    /// A long term order placement contains an order.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LongTermOrderPlacementV1 {
        #[prost(message, optional, tag = "1")]
        pub order: ::core::option::Option<super::super::protocol::v1::IndexerOrder>,
    }
    impl ::prost::Name for LongTermOrderPlacementV1 {
        const NAME: &'static str = "LongTermOrderPlacementV1";
        const PACKAGE: &'static str = "dydxprotocol.indexer.events";
        fn full_name() -> ::prost::alloc::string::String {
            "dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderPlacementV1"
                .into()
        }
    }
    /// A long term order placement contains an order.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LongTermOrderReplacementV1 {
        #[prost(message, optional, tag = "1")]
        pub order: ::core::option::Option<super::super::protocol::v1::IndexerOrder>,
    }
    impl ::prost::Name for LongTermOrderReplacementV1 {
        const NAME: &'static str = "LongTermOrderReplacementV1";
        const PACKAGE: &'static str = "dydxprotocol.indexer.events";
        fn full_name() -> ::prost::alloc::string::String {
            "dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderReplacementV1"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/dydxprotocol.indexer.events.StatefulOrderEventV1.LongTermOrderReplacementV1"
                .into()
        }
    }
    /// The type of event that this StatefulOrderEvent contains.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        /// Deprecated in favor of long_term_order_placement
        #[prost(message, tag = "1")]
        OrderPlace(StatefulOrderPlacementV1),
        #[prost(message, tag = "4")]
        OrderRemoval(StatefulOrderRemovalV1),
        #[prost(message, tag = "5")]
        ConditionalOrderPlacement(ConditionalOrderPlacementV1),
        #[prost(message, tag = "6")]
        ConditionalOrderTriggered(ConditionalOrderTriggeredV1),
        #[prost(message, tag = "7")]
        LongTermOrderPlacement(LongTermOrderPlacementV1),
        #[prost(message, tag = "8")]
        OrderReplace(LongTermOrderReplacementV1),
    }
}
impl ::prost::Name for StatefulOrderEventV1 {
    const NAME: &'static str = "StatefulOrderEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.StatefulOrderEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.StatefulOrderEventV1".into()
    }
}
/// AssetCreateEventV1 message contains all the information about an new Asset on
/// the dYdX chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetCreateEventV1 {
    /// Unique, sequentially-generated.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// The human readable symbol of the `Asset` (e.g. `USDC`, `ATOM`).
    /// Must be uppercase, unique and correspond to the canonical symbol of the
    /// full coin.
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
    /// `true` if this `Asset` has a valid `MarketId` value.
    #[prost(bool, tag = "3")]
    pub has_market: bool,
    /// The `Id` of the `Market` associated with this `Asset`. It acts as the
    /// oracle price for the purposes of calculating collateral
    /// and margin requirements.
    #[prost(uint32, tag = "4")]
    pub market_id: u32,
    /// The exponent for converting an atomic amount (1 'quantum')
    /// to a full coin. For example, if `atomic_resolution = -8`
    /// then an `asset_position` with `base_quantums = 1e8` is equivalent to
    /// a position size of one full coin.
    #[prost(sint32, tag = "5")]
    pub atomic_resolution: i32,
}
impl ::prost::Name for AssetCreateEventV1 {
    const NAME: &'static str = "AssetCreateEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.AssetCreateEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.AssetCreateEventV1".into()
    }
}
/// PerpetualMarketCreateEventV1 message contains all the information about a
/// new Perpetual Market on the dYdX chain.
/// Deprecated. See PerpetualMarketCreateEventV2 for the most up to date message
/// for the event to create a new Perpetual Market.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerpetualMarketCreateEventV1 {
    /// Unique Perpetual id.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Unique clob pair Id associated with this perpetual market
    /// Defined in clob.clob_pair
    #[prost(uint32, tag = "2")]
    pub clob_pair_id: u32,
    /// The name of the `Perpetual` (e.g. `BTC-USD`).
    /// Defined in perpetuals.perpetual
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// Unique id of market param associated with this perpetual market.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "4")]
    pub market_id: u32,
    /// Status of the CLOB
    #[prost(enumeration = "super::protocol::v1::ClobPairStatus", tag = "5")]
    pub status: i32,
    /// `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
    /// per Subtick.
    /// Defined in clob.clob_pair
    #[prost(sint32, tag = "6")]
    pub quantum_conversion_exponent: i32,
    /// The exponent for converting an atomic amount (`size = 1`)
    /// to a full coin. For example, if `AtomicResolution = -8`
    /// then a `PerpetualPosition` with `size = 1e8` is equivalent to
    /// a position size of one full coin.
    /// Defined in perpetuals.perpetual
    #[prost(sint32, tag = "7")]
    pub atomic_resolution: i32,
    /// Defines the tick size of the orderbook by defining how many subticks
    /// are in one tick. That is, the subticks of any valid order must be a
    /// multiple of this value. Generally this value should start `>= 100`to
    /// allow room for decreasing it.
    /// Defined in clob.clob_pair
    #[prost(uint32, tag = "8")]
    pub subticks_per_tick: u32,
    /// Minimum increment in the size of orders on the CLOB, in base quantums.
    /// Defined in clob.clob_pair
    #[prost(uint64, tag = "9")]
    pub step_base_quantums: u64,
    /// The liquidity_tier that this perpetual is associated with.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "10")]
    pub liquidity_tier: u32,
}
impl ::prost::Name for PerpetualMarketCreateEventV1 {
    const NAME: &'static str = "PerpetualMarketCreateEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.PerpetualMarketCreateEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.PerpetualMarketCreateEventV1".into()
    }
}
/// PerpetualMarketCreateEventV2 message contains all the information about a
/// new Perpetual Market on the dYdX chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerpetualMarketCreateEventV2 {
    /// Unique Perpetual id.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Unique clob pair Id associated with this perpetual market
    /// Defined in clob.clob_pair
    #[prost(uint32, tag = "2")]
    pub clob_pair_id: u32,
    /// The name of the `Perpetual` (e.g. `BTC-USD`).
    /// Defined in perpetuals.perpetual
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// Unique id of market param associated with this perpetual market.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "4")]
    pub market_id: u32,
    /// Status of the CLOB
    #[prost(enumeration = "super::protocol::v1::ClobPairStatus", tag = "5")]
    pub status: i32,
    /// `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
    /// per Subtick.
    /// Defined in clob.clob_pair
    #[prost(sint32, tag = "6")]
    pub quantum_conversion_exponent: i32,
    /// The exponent for converting an atomic amount (`size = 1`)
    /// to a full coin. For example, if `AtomicResolution = -8`
    /// then a `PerpetualPosition` with `size = 1e8` is equivalent to
    /// a position size of one full coin.
    /// Defined in perpetuals.perpetual
    #[prost(sint32, tag = "7")]
    pub atomic_resolution: i32,
    /// Defines the tick size of the orderbook by defining how many subticks
    /// are in one tick. That is, the subticks of any valid order must be a
    /// multiple of this value. Generally this value should start `>= 100`to
    /// allow room for decreasing it.
    /// Defined in clob.clob_pair
    #[prost(uint32, tag = "8")]
    pub subticks_per_tick: u32,
    /// Minimum increment in the size of orders on the CLOB, in base quantums.
    /// Defined in clob.clob_pair
    #[prost(uint64, tag = "9")]
    pub step_base_quantums: u64,
    /// The liquidity_tier that this perpetual is associated with.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "10")]
    pub liquidity_tier: u32,
    /// Market type of the perpetual.
    #[prost(enumeration = "super::protocol::v1::PerpetualMarketType", tag = "11")]
    pub market_type: i32,
}
impl ::prost::Name for PerpetualMarketCreateEventV2 {
    const NAME: &'static str = "PerpetualMarketCreateEventV2";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.PerpetualMarketCreateEventV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.PerpetualMarketCreateEventV2".into()
    }
}
/// LiquidityTierUpsertEventV1 message contains all the information to
/// create/update a Liquidity Tier on the dYdX chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiquidityTierUpsertEventV1 {
    /// Unique id.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// The name of the tier purely for mnemonic purposes, e.g. "Gold".
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// The margin fraction needed to open a position.
    /// In parts-per-million.
    #[prost(uint32, tag = "3")]
    pub initial_margin_ppm: u32,
    /// The fraction of the initial-margin that the maintenance-margin is,
    /// e.g. 50%. In parts-per-million.
    #[prost(uint32, tag = "4")]
    pub maintenance_fraction_ppm: u32,
    /// The maximum position size at which the margin requirements are
    /// not increased over the default values. Above this position size,
    /// the margin requirements increase at a rate of sqrt(size).
    ///
    /// Deprecated since v3.x.
    #[deprecated]
    #[prost(uint64, tag = "5")]
    pub base_position_notional: u64,
}
impl ::prost::Name for LiquidityTierUpsertEventV1 {
    const NAME: &'static str = "LiquidityTierUpsertEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.LiquidityTierUpsertEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.LiquidityTierUpsertEventV1".into()
    }
}
/// UpdateClobPairEventV1 message contains all the information about an update to
/// a clob pair on the dYdX chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClobPairEventV1 {
    /// Unique clob pair Id associated with this perpetual market
    /// Defined in clob.clob_pair
    #[prost(uint32, tag = "1")]
    pub clob_pair_id: u32,
    /// Status of the CLOB
    #[prost(enumeration = "super::protocol::v1::ClobPairStatus", tag = "2")]
    pub status: i32,
    /// `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
    /// per Subtick.
    /// Defined in clob.clob_pair
    #[prost(sint32, tag = "3")]
    pub quantum_conversion_exponent: i32,
    /// Defines the tick size of the orderbook by defining how many subticks
    /// are in one tick. That is, the subticks of any valid order must be a
    /// multiple of this value. Generally this value should start `>= 100`to
    /// allow room for decreasing it.
    /// Defined in clob.clob_pair
    #[prost(uint32, tag = "4")]
    pub subticks_per_tick: u32,
    /// Minimum increment in the size of orders on the CLOB, in base quantums.
    /// Defined in clob.clob_pair
    #[prost(uint64, tag = "5")]
    pub step_base_quantums: u64,
}
impl ::prost::Name for UpdateClobPairEventV1 {
    const NAME: &'static str = "UpdateClobPairEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.UpdateClobPairEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.UpdateClobPairEventV1".into()
    }
}
/// UpdatePerpetualEventV1 message contains all the information about an update
/// to a perpetual on the dYdX chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePerpetualEventV1 {
    /// Unique Perpetual id.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// The name of the `Perpetual` (e.g. `BTC-USD`).
    /// Defined in perpetuals.perpetual
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Unique id of market param associated with this perpetual market.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "3")]
    pub market_id: u32,
    /// The exponent for converting an atomic amount (`size = 1`)
    /// to a full coin. For example, if `AtomicResolution = -8`
    /// then a `PerpetualPosition` with `size = 1e8` is equivalent to
    /// a position size of one full coin.
    /// Defined in perpetuals.perpetual
    #[prost(sint32, tag = "4")]
    pub atomic_resolution: i32,
    /// The liquidity_tier that this perpetual is associated with.
    /// Defined in perpetuals.perpetual
    #[prost(uint32, tag = "5")]
    pub liquidity_tier: u32,
}
impl ::prost::Name for UpdatePerpetualEventV1 {
    const NAME: &'static str = "UpdatePerpetualEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.UpdatePerpetualEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.UpdatePerpetualEventV1".into()
    }
}
/// TradingRewardsEventV1 is communicates all trading rewards for all accounts
/// that receive trade rewards in the block.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradingRewardsEventV1 {
    /// The list of all trading rewards in the block.
    #[prost(message, repeated, tag = "1")]
    pub trading_rewards: ::prost::alloc::vec::Vec<AddressTradingReward>,
}
impl ::prost::Name for TradingRewardsEventV1 {
    const NAME: &'static str = "TradingRewardsEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.TradingRewardsEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.TradingRewardsEventV1".into()
    }
}
/// AddressTradingReward contains info on an instance of an address receiving a
/// reward
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressTradingReward {
    /// The address of the wallet that will receive the trading reward.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// The amount of trading rewards earned by the address above in denoms. 1e18
    /// denoms is equivalent to a single coin.
    #[prost(bytes = "vec", tag = "2")]
    pub denom_amount: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for AddressTradingReward {
    const NAME: &'static str = "AddressTradingReward";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.AddressTradingReward".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.AddressTradingReward".into()
    }
}
/// OpenInterestUpdateEventV1 is used for open interest update events
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenInterestUpdateEventV1 {
    /// The list of all open interest updates in the block.
    #[prost(message, repeated, tag = "1")]
    pub open_interest_updates: ::prost::alloc::vec::Vec<OpenInterestUpdate>,
}
impl ::prost::Name for OpenInterestUpdateEventV1 {
    const NAME: &'static str = "OpenInterestUpdateEventV1";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.OpenInterestUpdateEventV1".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.OpenInterestUpdateEventV1".into()
    }
}
/// OpenInterestUpdate contains a single open interest update for a perpetual
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenInterestUpdate {
    /// The ID of the perpetual market.
    #[prost(uint32, tag = "1")]
    pub perpetual_id: u32,
    /// The new open interest value for the perpetual market.
    #[prost(bytes = "vec", tag = "2")]
    pub open_interest: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for OpenInterestUpdate {
    const NAME: &'static str = "OpenInterestUpdate";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.OpenInterestUpdate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.OpenInterestUpdate".into()
    }
}
/// LiquidationEventV2 message contains all the information needed to update
/// the liquidity tiers. It contains all the fields from V1 along with the
/// open interest caps.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiquidityTierUpsertEventV2 {
    /// Unique id.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// The name of the tier purely for mnemonic purposes, e.g. "Gold".
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// The margin fraction needed to open a position.
    /// In parts-per-million.
    #[prost(uint32, tag = "3")]
    pub initial_margin_ppm: u32,
    /// The fraction of the initial-margin that the maintenance-margin is,
    /// e.g. 50%. In parts-per-million.
    #[prost(uint32, tag = "4")]
    pub maintenance_fraction_ppm: u32,
    /// The maximum position size at which the margin requirements are
    /// not increased over the default values. Above this position size,
    /// the margin requirements increase at a rate of sqrt(size).
    ///
    /// Deprecated since v3.x.
    #[deprecated]
    #[prost(uint64, tag = "5")]
    pub base_position_notional: u64,
    /// Lower cap of open interest in quote quantums. optional
    #[prost(uint64, tag = "6")]
    pub open_interest_lower_cap: u64,
    /// Upper cap of open interest in quote quantums.
    #[prost(uint64, tag = "7")]
    pub open_interest_upper_cap: u64,
}
impl ::prost::Name for LiquidityTierUpsertEventV2 {
    const NAME: &'static str = "LiquidityTierUpsertEventV2";
    const PACKAGE: &'static str = "dydxprotocol.indexer.events";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.indexer.events.LiquidityTierUpsertEventV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.indexer.events.LiquidityTierUpsertEventV2".into()
    }
}
