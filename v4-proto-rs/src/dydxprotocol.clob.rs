// This file is @generated by prost-build.
/// Defines the block rate limits for CLOB specific operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRateLimitConfiguration {
    /// How many short term order attempts (successful and failed) are allowed for
    /// an account per N blocks. Note that the rate limits are applied
    /// in an AND fashion such that an order placement must pass all rate limit
    /// configurations.
    ///
    /// Specifying 0 values disables this rate limit.
    /// Deprecated in favor of `max_short_term_orders_and_cancels_per_n_blocks`
    /// for v5.x onwards.
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub max_short_term_orders_per_n_blocks: ::prost::alloc::vec::Vec<
        MaxPerNBlocksRateLimit,
    >,
    /// How many stateful order attempts (successful and failed) are allowed for
    /// an account per N blocks. Note that the rate limits are applied
    /// in an AND fashion such that an order placement must pass all rate limit
    /// configurations.
    ///
    /// Specifying 0 values disables this rate limit.
    #[prost(message, repeated, tag = "2")]
    pub max_stateful_orders_per_n_blocks: ::prost::alloc::vec::Vec<
        MaxPerNBlocksRateLimit,
    >,
    /// How many short term order cancellation attempts (successful and failed) are
    /// allowed for an account per N blocks. Note that the rate limits are
    /// applied in an AND fashion such that an order cancellation must pass all
    /// rate limit configurations.
    ///
    /// Specifying 0 values disables this rate limit.
    /// Deprecated in favor of `max_short_term_orders_and_cancels_per_n_blocks`
    /// for v5.x onwards.
    #[deprecated]
    #[prost(message, repeated, tag = "3")]
    pub max_short_term_order_cancellations_per_n_blocks: ::prost::alloc::vec::Vec<
        MaxPerNBlocksRateLimit,
    >,
    /// How many short term order place and cancel attempts (successful and failed)
    /// are allowed for an account per N blocks. Note that the rate limits are
    /// applied in an AND fashion such that an order placement must pass all rate
    /// limit configurations.
    ///
    /// Specifying 0 values disables this rate limit.
    #[prost(message, repeated, tag = "4")]
    pub max_short_term_orders_and_cancels_per_n_blocks: ::prost::alloc::vec::Vec<
        MaxPerNBlocksRateLimit,
    >,
}
impl ::prost::Name for BlockRateLimitConfiguration {
    const NAME: &'static str = "BlockRateLimitConfiguration";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.BlockRateLimitConfiguration".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.BlockRateLimitConfiguration".into()
    }
}
/// Defines a rate limit over a specific number of blocks.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaxPerNBlocksRateLimit {
    /// How many blocks the rate limit is over.
    /// Specifying 0 is invalid.
    #[prost(uint32, tag = "1")]
    pub num_blocks: u32,
    /// What the limit is for `num_blocks`.
    /// Specifying 0 is invalid.
    #[prost(uint32, tag = "2")]
    pub limit: u32,
}
impl ::prost::Name for MaxPerNBlocksRateLimit {
    const NAME: &'static str = "MaxPerNBlocksRateLimit";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MaxPerNBlocksRateLimit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MaxPerNBlocksRateLimit".into()
    }
}
/// PerpetualClobMetadata contains metadata for a `ClobPair`
/// representing a Perpetual product.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerpetualClobMetadata {
    /// Id of the Perpetual the CLOB allows trading of.
    #[prost(uint32, tag = "1")]
    pub perpetual_id: u32,
}
impl ::prost::Name for PerpetualClobMetadata {
    const NAME: &'static str = "PerpetualClobMetadata";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.PerpetualClobMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.PerpetualClobMetadata".into()
    }
}
/// PerpetualClobMetadata contains metadata for a `ClobPair`
/// representing a Spot product.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpotClobMetadata {
    /// Id of the base Asset in the trading pair.
    #[prost(uint32, tag = "1")]
    pub base_asset_id: u32,
    /// Id of the quote Asset in the trading pair.
    #[prost(uint32, tag = "2")]
    pub quote_asset_id: u32,
}
impl ::prost::Name for SpotClobMetadata {
    const NAME: &'static str = "SpotClobMetadata";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.SpotClobMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.SpotClobMetadata".into()
    }
}
/// ClobPair represents a single CLOB pair for a given product
/// in state.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClobPair {
    /// ID of the orderbook that stores all resting liquidity for this CLOB.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Minimum increment in the size of orders on the CLOB, in base quantums.
    #[prost(uint64, tag = "4")]
    pub step_base_quantums: u64,
    /// Defines the tick size of the orderbook by defining how many subticks
    /// are in one tick. That is, the subticks of any valid order must be a
    /// multiple of this value. Generally this value should start `>= 100`to
    /// allow room for decreasing it.
    #[prost(uint32, tag = "5")]
    pub subticks_per_tick: u32,
    /// `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
    /// per Subtick.
    #[prost(sint32, tag = "6")]
    pub quantum_conversion_exponent: i32,
    #[prost(enumeration = "clob_pair::Status", tag = "7")]
    pub status: i32,
    /// Product-specific metadata. Perpetual CLOBs will have
    /// PerpetualClobMetadata, and Spot CLOBs will have SpotClobMetadata.
    #[prost(oneof = "clob_pair::Metadata", tags = "2, 3")]
    pub metadata: ::core::option::Option<clob_pair::Metadata>,
}
/// Nested message and enum types in `ClobPair`.
pub mod clob_pair {
    /// Status of the CLOB.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Default value. This value is invalid and unused.
        Unspecified = 0,
        /// STATUS_ACTIVE represents an active clob pair.
        Active = 1,
        /// STATUS_PAUSED behavior is unfinalized.
        /// TODO(DEC-600): update this documentation.
        Paused = 2,
        /// STATUS_CANCEL_ONLY behavior is unfinalized.
        /// TODO(DEC-600): update this documentation.
        CancelOnly = 3,
        /// STATUS_POST_ONLY behavior is unfinalized.
        /// TODO(DEC-600): update this documentation.
        PostOnly = 4,
        /// STATUS_INITIALIZING represents a newly-added clob pair.
        /// Clob pairs in this state only accept orders which are
        /// both short-term and post-only.
        Initializing = 5,
        /// STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated
        /// and trading has ceased. All open positions will be closed by the
        /// protocol. Open stateful orders will be cancelled. Open short-term
        /// orders will be left to expire.
        FinalSettlement = 6,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Active => "STATUS_ACTIVE",
                Self::Paused => "STATUS_PAUSED",
                Self::CancelOnly => "STATUS_CANCEL_ONLY",
                Self::PostOnly => "STATUS_POST_ONLY",
                Self::Initializing => "STATUS_INITIALIZING",
                Self::FinalSettlement => "STATUS_FINAL_SETTLEMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_ACTIVE" => Some(Self::Active),
                "STATUS_PAUSED" => Some(Self::Paused),
                "STATUS_CANCEL_ONLY" => Some(Self::CancelOnly),
                "STATUS_POST_ONLY" => Some(Self::PostOnly),
                "STATUS_INITIALIZING" => Some(Self::Initializing),
                "STATUS_FINAL_SETTLEMENT" => Some(Self::FinalSettlement),
                _ => None,
            }
        }
    }
    /// Product-specific metadata. Perpetual CLOBs will have
    /// PerpetualClobMetadata, and Spot CLOBs will have SpotClobMetadata.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        #[prost(message, tag = "2")]
        PerpetualClobMetadata(super::PerpetualClobMetadata),
        #[prost(message, tag = "3")]
        SpotClobMetadata(super::SpotClobMetadata),
    }
}
impl ::prost::Name for ClobPair {
    const NAME: &'static str = "ClobPair";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.ClobPair".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.ClobPair".into()
    }
}
/// Defines the set of equity tiers to limit how many open orders
/// a subaccount is allowed to have.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquityTierLimitConfiguration {
    /// How many short term stateful orders are allowed per equity tier.
    /// Specifying 0 values disables this limit.
    #[prost(message, repeated, tag = "1")]
    pub short_term_order_equity_tiers: ::prost::alloc::vec::Vec<EquityTierLimit>,
    /// How many open stateful orders are allowed per equity tier.
    /// Specifying 0 values disables this limit.
    #[prost(message, repeated, tag = "2")]
    pub stateful_order_equity_tiers: ::prost::alloc::vec::Vec<EquityTierLimit>,
}
impl ::prost::Name for EquityTierLimitConfiguration {
    const NAME: &'static str = "EquityTierLimitConfiguration";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.EquityTierLimitConfiguration".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.EquityTierLimitConfiguration".into()
    }
}
/// Defines an equity tier limit.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquityTierLimit {
    /// The total net collateral in USDC quote quantums of equity required.
    #[prost(bytes = "vec", tag = "1")]
    pub usd_tnc_required: ::prost::alloc::vec::Vec<u8>,
    /// What the limit is for `usd_tnc_required`.
    #[prost(uint32, tag = "2")]
    pub limit: u32,
}
impl ::prost::Name for EquityTierLimit {
    const NAME: &'static str = "EquityTierLimit";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.EquityTierLimit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.EquityTierLimit".into()
    }
}
/// ClobStagedFinalizeBlockEvent defines a CLOB event staged during
/// FinalizeBlock.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClobStagedFinalizeBlockEvent {
    /// event is the staged event.
    #[prost(oneof = "clob_staged_finalize_block_event::Event", tags = "1")]
    pub event: ::core::option::Option<clob_staged_finalize_block_event::Event>,
}
/// Nested message and enum types in `ClobStagedFinalizeBlockEvent`.
pub mod clob_staged_finalize_block_event {
    /// event is the staged event.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Event {
        /// create_clob_pair indicates a new CLOB pair creation.
        #[prost(message, tag = "1")]
        CreateClobPair(super::ClobPair),
    }
}
impl ::prost::Name for ClobStagedFinalizeBlockEvent {
    const NAME: &'static str = "ClobStagedFinalizeBlockEvent";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.ClobStagedFinalizeBlockEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.ClobStagedFinalizeBlockEvent".into()
    }
}
/// LiquidationsConfig stores all configurable fields related to liquidations.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LiquidationsConfig {
    /// The maximum liquidation fee (in parts-per-million). This fee goes
    /// 100% to the insurance fund.
    #[prost(uint32, tag = "1")]
    pub max_liquidation_fee_ppm: u32,
    /// Limits around how much of a single position can be liquidated
    /// within a single block.
    #[prost(message, optional, tag = "2")]
    pub position_block_limits: ::core::option::Option<PositionBlockLimits>,
    /// Limits around how many quote quantums from a single subaccount can
    /// be liquidated within a single block.
    #[prost(message, optional, tag = "3")]
    pub subaccount_block_limits: ::core::option::Option<SubaccountBlockLimits>,
    /// Config about how the fillable-price spread from the oracle price
    /// increases based on the adjusted bankruptcy rating of the subaccount.
    #[prost(message, optional, tag = "4")]
    pub fillable_price_config: ::core::option::Option<FillablePriceConfig>,
}
impl ::prost::Name for LiquidationsConfig {
    const NAME: &'static str = "LiquidationsConfig";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.LiquidationsConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.LiquidationsConfig".into()
    }
}
/// PositionBlockLimits stores all configurable fields related to limits
/// around how much of a single position can be liquidated within a single block.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PositionBlockLimits {
    /// The minimum amount of quantums to liquidate for each message (in
    /// quote quantums).
    /// Overridden by the maximum size of the position.
    #[prost(uint64, tag = "1")]
    pub min_position_notional_liquidated: u64,
    /// The maximum portion of the position liquidated (in parts-per-
    /// million). Overridden by min_position_notional_liquidated.
    #[prost(uint32, tag = "2")]
    pub max_position_portion_liquidated_ppm: u32,
}
impl ::prost::Name for PositionBlockLimits {
    const NAME: &'static str = "PositionBlockLimits";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.PositionBlockLimits".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.PositionBlockLimits".into()
    }
}
/// SubaccountBlockLimits stores all configurable fields related to limits
/// around how many quote quantums from a single subaccount can
/// be liquidated within a single block.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubaccountBlockLimits {
    /// The maximum notional amount that a single subaccount can have
    /// liquidated (in quote quantums) per block.
    #[prost(uint64, tag = "1")]
    pub max_notional_liquidated: u64,
    /// The maximum insurance-fund payout amount for a given subaccount
    /// per block. I.e. how much it can cover for that subaccount.
    #[prost(uint64, tag = "2")]
    pub max_quantums_insurance_lost: u64,
}
impl ::prost::Name for SubaccountBlockLimits {
    const NAME: &'static str = "SubaccountBlockLimits";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.SubaccountBlockLimits".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.SubaccountBlockLimits".into()
    }
}
/// FillablePriceConfig stores all configurable fields related to calculating
/// the fillable price for liquidating a position.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FillablePriceConfig {
    /// The rate at which the Adjusted Bankruptcy Rating increases.
    #[prost(uint32, tag = "1")]
    pub bankruptcy_adjustment_ppm: u32,
    /// The maximum value that the liquidation spread can take, as
    /// a ratio against the position's maintenance margin.
    #[prost(uint32, tag = "2")]
    pub spread_to_maintenance_margin_ratio_ppm: u32,
}
impl ::prost::Name for FillablePriceConfig {
    const NAME: &'static str = "FillablePriceConfig";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.FillablePriceConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.FillablePriceConfig".into()
    }
}
/// GenesisState defines the clob module's genesis state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    #[prost(message, repeated, tag = "1")]
    pub clob_pairs: ::prost::alloc::vec::Vec<ClobPair>,
    #[prost(message, optional, tag = "2")]
    pub liquidations_config: ::core::option::Option<LiquidationsConfig>,
    #[prost(message, optional, tag = "3")]
    pub block_rate_limit_config: ::core::option::Option<BlockRateLimitConfiguration>,
    #[prost(message, optional, tag = "4")]
    pub equity_tier_limit_config: ::core::option::Option<EquityTierLimitConfiguration>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.GenesisState".into()
    }
}
/// PerpetualLiquidationInfo holds information about a liquidation that occurred
/// for a position held by a subaccount.
/// Note this proto is defined to make it easier to hash
/// the metadata of a liquidation, and is never written to state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerpetualLiquidationInfo {
    /// The id of the subaccount that got liquidated/deleveraged or was deleveraged
    /// onto.
    #[prost(message, optional, tag = "1")]
    pub subaccount_id: ::core::option::Option<super::subaccounts::SubaccountId>,
    /// The id of the perpetual involved.
    #[prost(uint32, tag = "2")]
    pub perpetual_id: u32,
}
impl ::prost::Name for PerpetualLiquidationInfo {
    const NAME: &'static str = "PerpetualLiquidationInfo";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.PerpetualLiquidationInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.PerpetualLiquidationInfo".into()
    }
}
/// SubaccountLiquidationInfo holds liquidation information per-subaccount in the
/// current block.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubaccountLiquidationInfo {
    /// An unsorted list of unique perpetual IDs that the subaccount has previously
    /// liquidated.
    #[prost(uint32, repeated, tag = "1")]
    pub perpetuals_liquidated: ::prost::alloc::vec::Vec<u32>,
    /// The notional value (in quote quantums, determined by the oracle price) of
    /// all positions liquidated for this subaccount.
    #[prost(uint64, tag = "2")]
    pub notional_liquidated: u64,
    /// The amount of funds that the insurance fund has lost
    /// covering this subaccount.
    #[prost(uint64, tag = "3")]
    pub quantums_insurance_lost: u64,
}
impl ::prost::Name for SubaccountLiquidationInfo {
    const NAME: &'static str = "SubaccountLiquidationInfo";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.SubaccountLiquidationInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.SubaccountLiquidationInfo".into()
    }
}
/// SubaccountOpenPositionInfo holds information about open positions for a
/// perpetual.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubaccountOpenPositionInfo {
    /// The id of the perpetual.
    #[prost(uint32, tag = "1")]
    pub perpetual_id: u32,
    /// The ids of the subaccounts with long positions.
    #[prost(message, repeated, tag = "2")]
    pub subaccounts_with_long_position: ::prost::alloc::vec::Vec<
        super::subaccounts::SubaccountId,
    >,
    /// The ids of the subaccounts with short positions.
    #[prost(message, repeated, tag = "3")]
    pub subaccounts_with_short_position: ::prost::alloc::vec::Vec<
        super::subaccounts::SubaccountId,
    >,
}
impl ::prost::Name for SubaccountOpenPositionInfo {
    const NAME: &'static str = "SubaccountOpenPositionInfo";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.SubaccountOpenPositionInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.SubaccountOpenPositionInfo".into()
    }
}
/// OrderId refers to a single order belonging to a Subaccount.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderId {
    /// The subaccount ID that opened this order.
    /// Note that this field has `gogoproto.nullable = false` so that it is
    /// generated as a value instead of a pointer. This is because the `OrderId`
    /// proto is used as a key within maps, and map comparisons will compare
    /// pointers for equality (when the desired behavior is to compare the values).
    #[prost(message, optional, tag = "1")]
    pub subaccount_id: ::core::option::Option<super::subaccounts::SubaccountId>,
    /// The client ID of this order, unique with respect to the specific
    /// sub account (I.E., the same subaccount can't have two orders with
    /// the same ClientId).
    #[prost(fixed32, tag = "2")]
    pub client_id: u32,
    /// order_flags represent order flags for the order. This field is invalid if
    /// it's greater than 257. Each bit represents a different flag.
    ///
    /// The following are the valid orderId flags:
    /// ShortTerm    = uint32(0)
    /// Conditional  = uint32(32)
    /// LongTerm     = uint32(64)
    /// Twap         = uint32(128)
    /// TwapSuborder = uint32(256) (for internal use only)
    ///
    /// If both bits are set or bits other than the 2nd and 3rd are set, the order
    /// ID is invalid.
    #[prost(uint32, tag = "3")]
    pub order_flags: u32,
    /// ID of the CLOB the order is created for.
    #[prost(uint32, tag = "4")]
    pub clob_pair_id: u32,
}
impl ::prost::Name for OrderId {
    const NAME: &'static str = "OrderId";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.OrderId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.OrderId".into()
    }
}
/// OrdersFilledDuringLatestBlock represents a list of `OrderIds` that were
/// filled by any non-zero amount in the latest block.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrdersFilledDuringLatestBlock {
    /// A list of unique order_ids that were filled by any non-zero amount in the
    /// latest block.
    #[prost(message, repeated, tag = "1")]
    pub order_ids: ::prost::alloc::vec::Vec<OrderId>,
}
impl ::prost::Name for OrdersFilledDuringLatestBlock {
    const NAME: &'static str = "OrdersFilledDuringLatestBlock";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.OrdersFilledDuringLatestBlock".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.OrdersFilledDuringLatestBlock".into()
    }
}
/// PotentiallyPrunableOrders represents a list of orders that may be prunable
/// from state at a future block height.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PotentiallyPrunableOrders {
    /// A list of unique order_ids that may potentially be pruned from state at a
    /// future block height.
    #[prost(message, repeated, tag = "1")]
    pub order_ids: ::prost::alloc::vec::Vec<OrderId>,
}
impl ::prost::Name for PotentiallyPrunableOrders {
    const NAME: &'static str = "PotentiallyPrunableOrders";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.PotentiallyPrunableOrders".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.PotentiallyPrunableOrders".into()
    }
}
/// OrderFillState represents the fill amount of an order according to on-chain
/// state. This proto includes both the current on-chain fill amount of the
/// order, as well as the block at which this information can be pruned from
/// state.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OrderFillState {
    /// The current fillAmount of the order according to on-chain state.
    #[prost(uint64, tag = "1")]
    pub fill_amount: u64,
    /// The block height at which the fillAmount state for this order can be
    /// pruned.
    #[prost(uint32, tag = "2")]
    pub prunable_block_height: u32,
}
impl ::prost::Name for OrderFillState {
    const NAME: &'static str = "OrderFillState";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.OrderFillState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.OrderFillState".into()
    }
}
/// StatefulOrderTimeSliceValue represents the type of the value of the
/// `StatefulOrdersTimeSlice` in state. The `StatefulOrdersTimeSlice`
/// in state consists of key/value pairs where the keys are UTF-8-encoded
/// `RFC3339NANO` timestamp strings with right-padded zeroes and no
/// time zone info, and the values are of type `StatefulOrderTimeSliceValue`.
/// This `StatefulOrderTimeSliceValue` in state is used for managing stateful
/// order expiration. Stateful order expirations can be for either long term
/// or conditional orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatefulOrderTimeSliceValue {
    /// A unique list of order_ids that expire at this timestamp, sorted in
    /// ascending order by block height and transaction index of each stateful
    /// order.
    #[prost(message, repeated, tag = "1")]
    pub order_ids: ::prost::alloc::vec::Vec<OrderId>,
}
impl ::prost::Name for StatefulOrderTimeSliceValue {
    const NAME: &'static str = "StatefulOrderTimeSliceValue";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StatefulOrderTimeSliceValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StatefulOrderTimeSliceValue".into()
    }
}
/// LongTermOrderPlacement represents the placement of a stateful order in
/// state. It stores the stateful order itself and the `BlockHeight` and
/// `TransactionIndex` at which the order was placed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LongTermOrderPlacement {
    #[prost(message, optional, tag = "1")]
    pub order: ::core::option::Option<Order>,
    /// The block height and transaction index at which the order was placed.
    /// Used for ordering by time priority when the chain is restarted.
    #[prost(message, optional, tag = "2")]
    pub placement_index: ::core::option::Option<TransactionOrdering>,
}
impl ::prost::Name for LongTermOrderPlacement {
    const NAME: &'static str = "LongTermOrderPlacement";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.LongTermOrderPlacement".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.LongTermOrderPlacement".into()
    }
}
/// TwapOrderPlacement represents the placement of a TWAP order in
/// the TWAP Order State. It will store the original parent TWAP order as
/// well as maintain the state of the remaining legs and quantums
/// to be executed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TwapOrderPlacement {
    #[prost(message, optional, tag = "1")]
    pub order: ::core::option::Option<Order>,
    /// The number of legs remaining to be executed.
    #[prost(uint32, tag = "2")]
    pub remaining_legs: u32,
    /// The number of quantums remaining to be executed.
    #[prost(uint64, tag = "3")]
    pub remaining_quantums: u64,
}
impl ::prost::Name for TwapOrderPlacement {
    const NAME: &'static str = "TwapOrderPlacement";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.TwapOrderPlacement".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.TwapOrderPlacement".into()
    }
}
/// ConditionalOrderPlacement represents the placement of a conditional order in
/// state. It stores the stateful order itself, the `BlockHeight` and
/// `TransactionIndex` at which the order was placed and triggered.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionalOrderPlacement {
    #[prost(message, optional, tag = "1")]
    pub order: ::core::option::Option<Order>,
    /// The block height and transaction index at which the order was placed.
    #[prost(message, optional, tag = "2")]
    pub placement_index: ::core::option::Option<TransactionOrdering>,
    /// The block height and transaction index at which the order was triggered.
    /// Set to be nil if the transaction has not been triggered.
    /// Used for ordering by time priority when the chain is restarted.
    #[prost(message, optional, tag = "3")]
    pub trigger_index: ::core::option::Option<TransactionOrdering>,
}
impl ::prost::Name for ConditionalOrderPlacement {
    const NAME: &'static str = "ConditionalOrderPlacement";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.ConditionalOrderPlacement".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.ConditionalOrderPlacement".into()
    }
}
/// Order represents a single order belonging to a `Subaccount`
/// for a particular `ClobPair`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Order {
    /// The unique ID of this order. Meant to be unique across all orders.
    #[prost(message, optional, tag = "1")]
    pub order_id: ::core::option::Option<OrderId>,
    #[prost(enumeration = "order::Side", tag = "2")]
    pub side: i32,
    /// The size of this order in base quantums. Must be a multiple of
    /// `ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).
    #[prost(uint64, tag = "3")]
    pub quantums: u64,
    /// The price level that this order will be placed at on the orderbook,
    /// in subticks. Must be a multiple of ClobPair.SubticksPerTick
    /// (where `ClobPair.Id = orderId.ClobPairId`).
    #[prost(uint64, tag = "4")]
    pub subticks: u64,
    /// The time in force of this order.
    #[prost(enumeration = "order::TimeInForce", tag = "7")]
    pub time_in_force: i32,
    /// Enforces that the order can only reduce the size of an existing position.
    /// If a ReduceOnly order would change the side of the existing position,
    /// its size is reduced to that of the remaining size of the position.
    /// If existing orders on the book with ReduceOnly
    /// would already close the position, the least aggressive (out-of-the-money)
    /// ReduceOnly orders are resized and canceled first.
    #[prost(bool, tag = "8")]
    pub reduce_only: bool,
    /// Set of bit flags set arbitrarily by clients and ignored by the protocol.
    /// Used by indexer to infer information about a placed order.
    #[prost(uint32, tag = "9")]
    pub client_metadata: u32,
    #[prost(enumeration = "order::ConditionType", tag = "10")]
    pub condition_type: i32,
    /// conditional_order_trigger_subticks represents the price at which this order
    /// will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,
    /// this value is enforced to be 0. If this value is nonzero, condition_type
    /// cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.
    /// Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =
    /// orderId.ClobPairId`).
    #[prost(uint64, tag = "11")]
    pub conditional_order_trigger_subticks: u64,
    /// twap_parameters represent the configuration for a TWAP order. This must be
    /// set for twap orders and will be ignored for all other order types.
    #[prost(message, optional, tag = "12")]
    pub twap_parameters: ::core::option::Option<TwapParameters>,
    /// builder_code_parameters is the metadata for the
    /// partner or builder of an order specifying the fees charged.
    #[prost(message, optional, tag = "13")]
    pub builder_code_parameters: ::core::option::Option<BuilderCodeParameters>,
    /// order_router_address is the address of the order router that placed the
    /// order.
    #[prost(string, tag = "14")]
    pub order_router_address: ::prost::alloc::string::String,
    /// Information about when the order expires.
    #[prost(oneof = "order::GoodTilOneof", tags = "5, 6")]
    pub good_til_oneof: ::core::option::Option<order::GoodTilOneof>,
}
/// Nested message and enum types in `Order`.
pub mod order {
    /// Represents the side of the orderbook the order will be placed on.
    /// Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be
    /// placed on the orderbook.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Side {
        /// Default value. This value is invalid and unused.
        Unspecified = 0,
        /// SIDE_BUY is used to represent a BUY order.
        Buy = 1,
        /// SIDE_SELL is used to represent a SELL order.
        Sell = 2,
    }
    impl Side {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SIDE_UNSPECIFIED",
                Self::Buy => "SIDE_BUY",
                Self::Sell => "SIDE_SELL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SIDE_UNSPECIFIED" => Some(Self::Unspecified),
                "SIDE_BUY" => Some(Self::Buy),
                "SIDE_SELL" => Some(Self::Sell),
                _ => None,
            }
        }
    }
    /// TimeInForce indicates how long an order will remain active before it
    /// is executed or expires.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeInForce {
        /// TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an
        /// order will first match with existing orders on the book, and any
        /// remaining size will be added to the book as a maker order.
        Unspecified = 0,
        /// TIME_IN_FORCE_IOC enforces that an order only be matched with
        /// maker orders on the book. If the order has remaining size after
        /// matching with existing orders on the book, the remaining size
        /// is not placed on the book.
        Ioc = 1,
        /// TIME_IN_FORCE_POST_ONLY enforces that an order only be placed
        /// on the book as a maker order. Note this means that validators will cancel
        /// any newly-placed post only orders that would cross with other maker
        /// orders.
        PostOnly = 2,
        /// TIME_IN_FORCE_FILL_OR_KILL has been deprecated and will be removed in
        /// future versions.
        FillOrKill = 3,
    }
    impl TimeInForce {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIME_IN_FORCE_UNSPECIFIED",
                Self::Ioc => "TIME_IN_FORCE_IOC",
                Self::PostOnly => "TIME_IN_FORCE_POST_ONLY",
                Self::FillOrKill => "TIME_IN_FORCE_FILL_OR_KILL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_IN_FORCE_UNSPECIFIED" => Some(Self::Unspecified),
                "TIME_IN_FORCE_IOC" => Some(Self::Ioc),
                "TIME_IN_FORCE_POST_ONLY" => Some(Self::PostOnly),
                "TIME_IN_FORCE_FILL_OR_KILL" => Some(Self::FillOrKill),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConditionType {
        /// CONDITION_TYPE_UNSPECIFIED represents the default behavior where an
        /// order will be placed immediately on the orderbook.
        Unspecified = 0,
        /// CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will
        /// trigger when the oracle price moves at or above the trigger price for
        /// buys, and at or below the trigger price for sells.
        StopLoss = 1,
        /// CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit
        /// order will trigger when the oracle price moves at or below the trigger
        /// price for buys and at or above the trigger price for sells.
        TakeProfit = 2,
    }
    impl ConditionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONDITION_TYPE_UNSPECIFIED",
                Self::StopLoss => "CONDITION_TYPE_STOP_LOSS",
                Self::TakeProfit => "CONDITION_TYPE_TAKE_PROFIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONDITION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONDITION_TYPE_STOP_LOSS" => Some(Self::StopLoss),
                "CONDITION_TYPE_TAKE_PROFIT" => Some(Self::TakeProfit),
                _ => None,
            }
        }
    }
    /// Information about when the order expires.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GoodTilOneof {
        /// The last block this order can be executed at (after which it will be
        /// unfillable). Used only for Short-Term orders. If this value is non-zero
        /// then the order is assumed to be a Short-Term order.
        #[prost(uint32, tag = "5")]
        GoodTilBlock(u32),
        /// good_til_block_time represents the unix timestamp (in seconds) at which a
        /// stateful order will be considered expired. The
        /// good_til_block_time is always evaluated against the previous block's
        /// `BlockTime` instead of the block in which the order is committed. If this
        /// value is non-zero then the order is assumed to be a stateful or
        /// conditional order.
        #[prost(fixed32, tag = "6")]
        GoodTilBlockTime(u32),
    }
}
impl ::prost::Name for Order {
    const NAME: &'static str = "Order";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.Order".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.Order".into()
    }
}
/// TwapParameters represents the necessary configuration for a TWAP order.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TwapParameters {
    /// Duration of the TWAP order execution in seconds. Must be in the range
    /// \[300 (5 minutes), 86400 (24 hours)\].
    #[prost(uint32, tag = "1")]
    pub duration: u32,
    /// Interval in seconds for each suborder to execute. Must be a
    /// whole number, a factor of the duration, and in the range
    /// \[30 (30 seconds), 3600 (1 hour)\].
    #[prost(uint32, tag = "2")]
    pub interval: u32,
    /// Price tolerance in ppm for each suborder. This will be applied to
    /// the oracle price each time a suborder is triggered. Must be
    /// be in the range [0, 1_000_000).
    #[prost(uint32, tag = "3")]
    pub price_tolerance: u32,
}
impl ::prost::Name for TwapParameters {
    const NAME: &'static str = "TwapParameters";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.TwapParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.TwapParameters".into()
    }
}
/// BuilderCodeParameters represents the metadata for the partner or builder of
/// an order. This allows them to specify a fee for providing there service which
/// will be paid out in the event of an order fill.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuilderCodeParameters {
    /// The address of the builder to which the fee will be paid.
    #[prost(string, tag = "1")]
    pub builder_address: ::prost::alloc::string::String,
    /// The fee enforced on the order in ppm.
    #[prost(uint32, tag = "2")]
    pub fee_ppm: u32,
}
impl ::prost::Name for BuilderCodeParameters {
    const NAME: &'static str = "BuilderCodeParameters";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.BuilderCodeParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.BuilderCodeParameters".into()
    }
}
/// TransactionOrdering represents a unique location in the block where a
/// transaction was placed. This proto includes both block height and the
/// transaction index that the specific transaction was placed. This information
/// is used for ordering by time priority when the chain is restarted.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionOrdering {
    /// Block height in which the transaction was placed.
    #[prost(uint32, tag = "1")]
    pub block_height: u32,
    /// Within the block, the unique transaction index.
    #[prost(uint32, tag = "2")]
    pub transaction_index: u32,
}
impl ::prost::Name for TransactionOrdering {
    const NAME: &'static str = "TransactionOrdering";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.TransactionOrdering".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.TransactionOrdering".into()
    }
}
/// StreamLiquidationOrder represents an protocol-generated IOC liquidation
/// order. Used in full node streaming.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamLiquidationOrder {
    /// Information about this liquidation order.
    #[prost(message, optional, tag = "1")]
    pub liquidation_info: ::core::option::Option<PerpetualLiquidationInfo>,
    /// CLOB pair ID of the CLOB pair the liquidation order will be matched
    /// against.
    #[prost(uint32, tag = "2")]
    pub clob_pair_id: u32,
    /// True if this is a buy order liquidating a short position, false if vice
    /// versa.
    #[prost(bool, tag = "3")]
    pub is_buy: bool,
    /// The number of base quantums for this liquidation order.
    #[prost(uint64, tag = "4")]
    pub quantums: u64,
    /// The subticks this liquidation order will be submitted at.
    #[prost(uint64, tag = "5")]
    pub subticks: u64,
}
impl ::prost::Name for StreamLiquidationOrder {
    const NAME: &'static str = "StreamLiquidationOrder";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StreamLiquidationOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StreamLiquidationOrder".into()
    }
}
/// ClobMatch represents an operations queue entry around all different types
/// of matches, specifically regular matches, liquidation matches, and
/// deleveraging matches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClobMatch {
    /// The match type that this message includes.
    #[prost(oneof = "clob_match::Match", tags = "1, 2, 3")]
    pub r#match: ::core::option::Option<clob_match::Match>,
}
/// Nested message and enum types in `ClobMatch`.
pub mod clob_match {
    /// The match type that this message includes.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Match {
        #[prost(message, tag = "1")]
        MatchOrders(super::MatchOrders),
        #[prost(message, tag = "2")]
        MatchPerpetualLiquidation(super::MatchPerpetualLiquidation),
        #[prost(message, tag = "3")]
        MatchPerpetualDeleveraging(super::MatchPerpetualDeleveraging),
    }
}
impl ::prost::Name for ClobMatch {
    const NAME: &'static str = "ClobMatch";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.ClobMatch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.ClobMatch".into()
    }
}
/// MakerFill represents the filled amount of a matched maker order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakerFill {
    /// The filled amount of the matched maker order, in base quantums.
    /// TODO(CLOB-571): update to use SerializableInt.
    #[prost(uint64, tag = "1")]
    pub fill_amount: u64,
    /// The `OrderId` of the matched maker order.
    #[prost(message, optional, tag = "2")]
    pub maker_order_id: ::core::option::Option<OrderId>,
}
impl ::prost::Name for MakerFill {
    const NAME: &'static str = "MakerFill";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MakerFill".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MakerFill".into()
    }
}
/// MatchOrders is an injected message used for matching orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchOrders {
    /// The `OrderId` of the taker order.
    #[prost(message, optional, tag = "1")]
    pub taker_order_id: ::core::option::Option<OrderId>,
    /// An ordered list of fills created by this taker order.
    #[prost(message, repeated, tag = "2")]
    pub fills: ::prost::alloc::vec::Vec<MakerFill>,
}
impl ::prost::Name for MatchOrders {
    const NAME: &'static str = "MatchOrders";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MatchOrders".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MatchOrders".into()
    }
}
/// MatchPerpetualLiquidation is an injected message used for liquidating a
/// subaccount.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchPerpetualLiquidation {
    /// ID of the subaccount that was liquidated.
    #[prost(message, optional, tag = "1")]
    pub liquidated: ::core::option::Option<super::subaccounts::SubaccountId>,
    /// The ID of the clob pair involved in the liquidation.
    #[prost(uint32, tag = "2")]
    pub clob_pair_id: u32,
    /// The ID of the perpetual involved in the liquidation.
    #[prost(uint32, tag = "3")]
    pub perpetual_id: u32,
    /// The total size of the liquidation order including any unfilled size.
    #[prost(uint64, tag = "4")]
    pub total_size: u64,
    /// `true` if liquidating a short position, `false` otherwise.
    #[prost(bool, tag = "5")]
    pub is_buy: bool,
    /// An ordered list of fills created by this liquidation.
    #[prost(message, repeated, tag = "6")]
    pub fills: ::prost::alloc::vec::Vec<MakerFill>,
}
impl ::prost::Name for MatchPerpetualLiquidation {
    const NAME: &'static str = "MatchPerpetualLiquidation";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MatchPerpetualLiquidation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MatchPerpetualLiquidation".into()
    }
}
/// MatchPerpetualDeleveraging is an injected message used for deleveraging a
/// subaccount.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchPerpetualDeleveraging {
    /// ID of the subaccount that was liquidated.
    #[prost(message, optional, tag = "1")]
    pub liquidated: ::core::option::Option<super::subaccounts::SubaccountId>,
    /// The ID of the perpetual that was liquidated.
    #[prost(uint32, tag = "2")]
    pub perpetual_id: u32,
    /// An ordered list of fills created by this liquidation.
    #[prost(message, repeated, tag = "3")]
    pub fills: ::prost::alloc::vec::Vec<match_perpetual_deleveraging::Fill>,
    /// Flag denoting whether the deleveraging operation was for the purpose
    /// of final settlement. Final settlement matches are at the oracle price,
    /// whereas deleveraging happens at the bankruptcy price of the deleveraged
    /// subaccount.
    #[prost(bool, tag = "4")]
    pub is_final_settlement: bool,
}
/// Nested message and enum types in `MatchPerpetualDeleveraging`.
pub mod match_perpetual_deleveraging {
    /// Fill represents a fill between the liquidated and offsetting subaccount.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Fill {
        /// ID of the subaccount that was used to offset the liquidated subaccount's
        /// position.
        #[prost(message, optional, tag = "1")]
        pub offsetting_subaccount_id: ::core::option::Option<
            super::super::subaccounts::SubaccountId,
        >,
        /// The amount filled between the liquidated and offsetting position, in
        /// base quantums.
        /// TODO(CLOB-571): update to use SerializableInt.
        #[prost(uint64, tag = "2")]
        pub fill_amount: u64,
    }
    impl ::prost::Name for Fill {
        const NAME: &'static str = "Fill";
        const PACKAGE: &'static str = "dydxprotocol.clob";
        fn full_name() -> ::prost::alloc::string::String {
            "dydxprotocol.clob.MatchPerpetualDeleveraging.Fill".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/dydxprotocol.clob.MatchPerpetualDeleveraging.Fill".into()
        }
    }
}
impl ::prost::Name for MatchPerpetualDeleveraging {
    const NAME: &'static str = "MatchPerpetualDeleveraging";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MatchPerpetualDeleveraging".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MatchPerpetualDeleveraging".into()
    }
}
/// MEVMatch represents all necessary data to calculate MEV for a regular match.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MevMatch {
    #[prost(message, optional, tag = "1")]
    pub taker_order_subaccount_id: ::core::option::Option<
        super::subaccounts::SubaccountId,
    >,
    #[prost(int32, tag = "2")]
    pub taker_fee_ppm: i32,
    #[prost(message, optional, tag = "3")]
    pub maker_order_subaccount_id: ::core::option::Option<
        super::subaccounts::SubaccountId,
    >,
    #[prost(uint64, tag = "4")]
    pub maker_order_subticks: u64,
    #[prost(bool, tag = "5")]
    pub maker_order_is_buy: bool,
    #[prost(int32, tag = "6")]
    pub maker_fee_ppm: i32,
    #[prost(uint32, tag = "7")]
    pub clob_pair_id: u32,
    #[prost(uint64, tag = "8")]
    pub fill_amount: u64,
}
impl ::prost::Name for MevMatch {
    const NAME: &'static str = "MEVMatch";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MEVMatch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MEVMatch".into()
    }
}
/// MEVLiquidationMatch represents all necessary data to calculate MEV for a
/// liquidation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MevLiquidationMatch {
    #[prost(message, optional, tag = "1")]
    pub liquidated_subaccount_id: ::core::option::Option<
        super::subaccounts::SubaccountId,
    >,
    #[prost(int64, tag = "2")]
    pub insurance_fund_delta_quote_quantums: i64,
    #[prost(message, optional, tag = "3")]
    pub maker_order_subaccount_id: ::core::option::Option<
        super::subaccounts::SubaccountId,
    >,
    #[prost(uint64, tag = "4")]
    pub maker_order_subticks: u64,
    #[prost(bool, tag = "5")]
    pub maker_order_is_buy: bool,
    #[prost(int32, tag = "6")]
    pub maker_fee_ppm: i32,
    #[prost(uint32, tag = "7")]
    pub clob_pair_id: u32,
    #[prost(uint64, tag = "8")]
    pub fill_amount: u64,
}
impl ::prost::Name for MevLiquidationMatch {
    const NAME: &'static str = "MEVLiquidationMatch";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MEVLiquidationMatch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MEVLiquidationMatch".into()
    }
}
/// ClobMidPrice contains the mid price of a CLOB pair, represented by it's ID.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClobMidPrice {
    #[prost(message, optional, tag = "1")]
    pub clob_pair: ::core::option::Option<ClobPair>,
    #[prost(uint64, tag = "2")]
    pub subticks: u64,
}
impl ::prost::Name for ClobMidPrice {
    const NAME: &'static str = "ClobMidPrice";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.ClobMidPrice".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.ClobMidPrice".into()
    }
}
/// ValidatorMevMatches contains all matches from the validator's local
/// operations queue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorMevMatches {
    #[prost(message, repeated, tag = "1")]
    pub matches: ::prost::alloc::vec::Vec<MevMatch>,
    #[prost(message, repeated, tag = "2")]
    pub liquidation_matches: ::prost::alloc::vec::Vec<MevLiquidationMatch>,
}
impl ::prost::Name for ValidatorMevMatches {
    const NAME: &'static str = "ValidatorMevMatches";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.ValidatorMevMatches".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.ValidatorMevMatches".into()
    }
}
/// MevNodeToNodeMetrics is a data structure for encapsulating all MEV node <>
/// node metrics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MevNodeToNodeMetrics {
    #[prost(message, optional, tag = "1")]
    pub validator_mev_matches: ::core::option::Option<ValidatorMevMatches>,
    #[prost(message, repeated, tag = "2")]
    pub clob_mid_prices: ::prost::alloc::vec::Vec<ClobMidPrice>,
    #[prost(message, optional, tag = "3")]
    pub bp_mev_matches: ::core::option::Option<ValidatorMevMatches>,
    #[prost(uint64, tag = "4")]
    pub proposal_receive_time: u64,
}
impl ::prost::Name for MevNodeToNodeMetrics {
    const NAME: &'static str = "MevNodeToNodeMetrics";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MevNodeToNodeMetrics".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MevNodeToNodeMetrics".into()
    }
}
/// OrderRemoval is a request type used for forced removal of stateful orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderRemoval {
    #[prost(message, optional, tag = "1")]
    pub order_id: ::core::option::Option<OrderId>,
    #[prost(enumeration = "order_removal::RemovalReason", tag = "2")]
    pub removal_reason: i32,
}
/// Nested message and enum types in `OrderRemoval`.
pub mod order_removal {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RemovalReason {
        /// REMOVAL_REASON_UNSPECIFIED represents an unspecified removal reason. This
        /// removal reason is used as a catchall and should never appear on an
        /// OrderRemoval in the operations queue.
        Unspecified = 0,
        /// REMOVAL_REASON_UNDERCOLLATERALIZED represents a removal of an order which
        /// if filled in isolation with respect to the current state of the
        /// subaccount would leave the subaccount undercollateralized.
        Undercollateralized = 1,
        /// REMOVAL_REASON_INVALID_REDUCE_ONLY represents a removal of a reduce-only
        /// order which if filled in isolation with respect to the current state of
        /// the subaccount would cause the subaccount's existing position to increase
        /// or change sides.
        InvalidReduceOnly = 2,
        /// REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER represents a removal of
        /// a stateful post-only order that was deemed invalid because it crossed
        /// maker orders on the book of the proposer.
        PostOnlyWouldCrossMakerOrder = 3,
        /// REMOVAL_REASON_INVALID_SELF_TRADE represents a removal of a stateful
        /// order that was deemed invalid because it constituted a self trade on the
        /// proposers orderbook.
        InvalidSelfTrade = 4,
        /// REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED represents a
        /// removal of a conditional FOK order that was deemed invalid because it
        /// could not be completely filled. Conditional FOK orders should always be
        /// fully-filled or removed in the block after they are triggered.
        ConditionalFokCouldNotBeFullyFilled = 5,
        /// REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK represents a removal
        /// of a conditional IOC order.
        /// Conditional IOC orders should always have their remaining size removed
        /// in the block after they are triggered.
        ConditionalIocWouldRestOnBook = 6,
        /// REMOVAL_REASON_FULLY_FILLED represents a removal of an order that
        /// was fully filled and should therefore be removed from state.
        FullyFilled = 7,
        /// REMOVAL_REASON_FULLY_FILLED represents a removal of an order that
        ///   would lead to the subaccount violating isolated subaccount constraints.
        ViolatesIsolatedSubaccountConstraints = 8,
        /// REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED represents a removal of an order
        /// that was placed using an expired permissioned key.
        PermissionedKeyExpired = 9,
    }
    impl RemovalReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REMOVAL_REASON_UNSPECIFIED",
                Self::Undercollateralized => "REMOVAL_REASON_UNDERCOLLATERALIZED",
                Self::InvalidReduceOnly => "REMOVAL_REASON_INVALID_REDUCE_ONLY",
                Self::PostOnlyWouldCrossMakerOrder => {
                    "REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER"
                }
                Self::InvalidSelfTrade => "REMOVAL_REASON_INVALID_SELF_TRADE",
                Self::ConditionalFokCouldNotBeFullyFilled => {
                    "REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED"
                }
                Self::ConditionalIocWouldRestOnBook => {
                    "REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK"
                }
                Self::FullyFilled => "REMOVAL_REASON_FULLY_FILLED",
                Self::ViolatesIsolatedSubaccountConstraints => {
                    "REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS"
                }
                Self::PermissionedKeyExpired => "REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REMOVAL_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "REMOVAL_REASON_UNDERCOLLATERALIZED" => Some(Self::Undercollateralized),
                "REMOVAL_REASON_INVALID_REDUCE_ONLY" => Some(Self::InvalidReduceOnly),
                "REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER" => {
                    Some(Self::PostOnlyWouldCrossMakerOrder)
                }
                "REMOVAL_REASON_INVALID_SELF_TRADE" => Some(Self::InvalidSelfTrade),
                "REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED" => {
                    Some(Self::ConditionalFokCouldNotBeFullyFilled)
                }
                "REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK" => {
                    Some(Self::ConditionalIocWouldRestOnBook)
                }
                "REMOVAL_REASON_FULLY_FILLED" => Some(Self::FullyFilled),
                "REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS" => {
                    Some(Self::ViolatesIsolatedSubaccountConstraints)
                }
                "REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED" => {
                    Some(Self::PermissionedKeyExpired)
                }
                _ => None,
            }
        }
    }
}
impl ::prost::Name for OrderRemoval {
    const NAME: &'static str = "OrderRemoval";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.OrderRemoval".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.OrderRemoval".into()
    }
}
/// MsgCreateClobPair is a message used by x/gov for creating a new clob pair.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateClobPair {
    /// The address that controls the module.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// `clob_pair` defines parameters for the new clob pair.
    #[prost(message, optional, tag = "2")]
    pub clob_pair: ::core::option::Option<ClobPair>,
}
impl ::prost::Name for MsgCreateClobPair {
    const NAME: &'static str = "MsgCreateClobPair";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgCreateClobPair".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgCreateClobPair".into()
    }
}
/// MsgCreateClobPairResponse defines the CreateClobPair response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCreateClobPairResponse {}
impl ::prost::Name for MsgCreateClobPairResponse {
    const NAME: &'static str = "MsgCreateClobPairResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgCreateClobPairResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgCreateClobPairResponse".into()
    }
}
/// MsgProposedOperations is a message injected by block proposers to
/// specify the operations that occurred in a block.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgProposedOperations {
    /// The list of operations proposed by the block proposer.
    #[prost(message, repeated, tag = "1")]
    pub operations_queue: ::prost::alloc::vec::Vec<OperationRaw>,
}
impl ::prost::Name for MsgProposedOperations {
    const NAME: &'static str = "MsgProposedOperations";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgProposedOperations".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgProposedOperations".into()
    }
}
/// MsgProposedOperationsResponse is the response type of the message injected
/// by block proposers to specify the operations that occurred in a block.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgProposedOperationsResponse {}
impl ::prost::Name for MsgProposedOperationsResponse {
    const NAME: &'static str = "MsgProposedOperationsResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgProposedOperationsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgProposedOperationsResponse".into()
    }
}
/// MsgPlaceOrder is a request type used for placing orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgPlaceOrder {
    #[prost(message, optional, tag = "1")]
    pub order: ::core::option::Option<Order>,
}
impl ::prost::Name for MsgPlaceOrder {
    const NAME: &'static str = "MsgPlaceOrder";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgPlaceOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgPlaceOrder".into()
    }
}
/// MsgPlaceOrderResponse is a response type used for placing orders.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgPlaceOrderResponse {}
impl ::prost::Name for MsgPlaceOrderResponse {
    const NAME: &'static str = "MsgPlaceOrderResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgPlaceOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgPlaceOrderResponse".into()
    }
}
/// MsgCancelOrder is a request type used for canceling orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCancelOrder {
    #[prost(message, optional, tag = "1")]
    pub order_id: ::core::option::Option<OrderId>,
    /// Information about when the order cancellation expires.
    #[prost(oneof = "msg_cancel_order::GoodTilOneof", tags = "2, 3")]
    pub good_til_oneof: ::core::option::Option<msg_cancel_order::GoodTilOneof>,
}
/// Nested message and enum types in `MsgCancelOrder`.
pub mod msg_cancel_order {
    /// Information about when the order cancellation expires.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GoodTilOneof {
        /// The last block this order cancellation can be executed at.
        /// Used only for Short-Term orders and must be zero for stateful orders.
        #[prost(uint32, tag = "2")]
        GoodTilBlock(u32),
        /// good_til_block_time represents the unix timestamp (in seconds) at which a
        /// stateful order cancellation will be considered expired. The
        /// good_til_block_time is always evaluated against the previous block's
        /// `BlockTime` instead of the block in which the order is committed.
        /// This value must be zero for Short-Term orders.
        #[prost(fixed32, tag = "3")]
        GoodTilBlockTime(u32),
    }
}
impl ::prost::Name for MsgCancelOrder {
    const NAME: &'static str = "MsgCancelOrder";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgCancelOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgCancelOrder".into()
    }
}
/// MsgCancelOrderResponse is a response type used for canceling orders.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCancelOrderResponse {}
impl ::prost::Name for MsgCancelOrderResponse {
    const NAME: &'static str = "MsgCancelOrderResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgCancelOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgCancelOrderResponse".into()
    }
}
/// MsgBatchCancel is a request type used for batch canceling orders.
/// This msg is not atomic. Cancels will be performed optimistically even
/// if some cancels are invalid or fail.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBatchCancel {
    /// The subaccount this batch cancel will be applied for.
    #[prost(message, optional, tag = "1")]
    pub subaccount_id: ::core::option::Option<super::subaccounts::SubaccountId>,
    /// The batch of short term orders that will be cancelled.
    #[prost(message, repeated, tag = "2")]
    pub short_term_cancels: ::prost::alloc::vec::Vec<OrderBatch>,
    /// The last block the short term order cancellations can be executed at.
    #[prost(uint32, tag = "3")]
    pub good_til_block: u32,
}
impl ::prost::Name for MsgBatchCancel {
    const NAME: &'static str = "MsgBatchCancel";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgBatchCancel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgBatchCancel".into()
    }
}
/// OrderBatch represents a batch of orders all belonging to a single clob pair
/// id. Along with a subaccount id and an order flag, is used to represent a
/// batch of orders that share the same subaccount, order flag, and clob pair id.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderBatch {
    /// The Clob Pair ID all orders in this order batch belong to.
    #[prost(uint32, tag = "1")]
    pub clob_pair_id: u32,
    /// List of client ids in this order batch.
    /// Note that this is serialized as a uint32 instead of a fixed32 to
    /// avoid issues when decoding repeated packed fixed32.
    #[prost(uint32, repeated, tag = "2")]
    pub client_ids: ::prost::alloc::vec::Vec<u32>,
}
impl ::prost::Name for OrderBatch {
    const NAME: &'static str = "OrderBatch";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.OrderBatch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.OrderBatch".into()
    }
}
/// MsgBatchCancelResponse is a response type used for batch canceling orders.
/// It indicates which cancel orders have succeeded or failed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBatchCancelResponse {
    /// A batch of short term cancel orders that have succeeded.
    #[prost(message, repeated, tag = "1")]
    pub short_term_succeeded: ::prost::alloc::vec::Vec<OrderBatch>,
    /// A batch of short term cancel orders that have failed.
    #[prost(message, repeated, tag = "2")]
    pub short_term_failed: ::prost::alloc::vec::Vec<OrderBatch>,
}
impl ::prost::Name for MsgBatchCancelResponse {
    const NAME: &'static str = "MsgBatchCancelResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgBatchCancelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgBatchCancelResponse".into()
    }
}
/// MsgUpdateClobPair is a request type used for updating a ClobPair in state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateClobPair {
    /// Authority is the address that may send this message.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// `clob_pair` is the ClobPair to write to state.
    #[prost(message, optional, tag = "2")]
    pub clob_pair: ::core::option::Option<ClobPair>,
}
impl ::prost::Name for MsgUpdateClobPair {
    const NAME: &'static str = "MsgUpdateClobPair";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgUpdateClobPair".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgUpdateClobPair".into()
    }
}
/// MsgUpdateClobPairResponse is a response type used for setting a ClobPair's
/// status.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateClobPairResponse {}
impl ::prost::Name for MsgUpdateClobPairResponse {
    const NAME: &'static str = "MsgUpdateClobPairResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgUpdateClobPairResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgUpdateClobPairResponse".into()
    }
}
/// OperationRaw represents an operation in the proposed operations.
/// Note that the `order_placement` operation is a signed message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationRaw {
    /// operationRaw represents an operation that occurred, which can be a match,
    /// a signed order placement, or an order removal.
    #[prost(oneof = "operation_raw::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<operation_raw::Operation>,
}
/// Nested message and enum types in `OperationRaw`.
pub mod operation_raw {
    /// operationRaw represents an operation that occurred, which can be a match,
    /// a signed order placement, or an order removal.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "1")]
        Match(super::ClobMatch),
        #[prost(bytes, tag = "2")]
        ShortTermOrderPlacement(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "3")]
        OrderRemoval(super::OrderRemoval),
    }
}
impl ::prost::Name for OperationRaw {
    const NAME: &'static str = "OperationRaw";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.OperationRaw".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.OperationRaw".into()
    }
}
/// MsgUpdateEquityTierLimitConfiguration is the Msg/EquityTierLimitConfiguration
/// request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateEquityTierLimitConfiguration {
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// Defines the equity tier limit configuration to update to. All fields must
    /// be set.
    #[prost(message, optional, tag = "2")]
    pub equity_tier_limit_config: ::core::option::Option<EquityTierLimitConfiguration>,
}
impl ::prost::Name for MsgUpdateEquityTierLimitConfiguration {
    const NAME: &'static str = "MsgUpdateEquityTierLimitConfiguration";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgUpdateEquityTierLimitConfiguration".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgUpdateEquityTierLimitConfiguration".into()
    }
}
/// MsgUpdateEquityTierLimitConfiguration is the Msg/EquityTierLimitConfiguration
/// response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateEquityTierLimitConfigurationResponse {}
impl ::prost::Name for MsgUpdateEquityTierLimitConfigurationResponse {
    const NAME: &'static str = "MsgUpdateEquityTierLimitConfigurationResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgUpdateEquityTierLimitConfigurationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgUpdateEquityTierLimitConfigurationResponse".into()
    }
}
/// MsgUpdateBlockRateLimitConfiguration is the Msg/BlockRateLimitConfiguration
/// request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateBlockRateLimitConfiguration {
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// Defines the block rate limit configuration to update to. All fields must be
    /// set.
    #[prost(message, optional, tag = "3")]
    pub block_rate_limit_config: ::core::option::Option<BlockRateLimitConfiguration>,
}
impl ::prost::Name for MsgUpdateBlockRateLimitConfiguration {
    const NAME: &'static str = "MsgUpdateBlockRateLimitConfiguration";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgUpdateBlockRateLimitConfiguration".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgUpdateBlockRateLimitConfiguration".into()
    }
}
/// MsgUpdateBlockRateLimitConfiguration is a response type for updating the
/// liquidations config.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateBlockRateLimitConfigurationResponse {}
impl ::prost::Name for MsgUpdateBlockRateLimitConfigurationResponse {
    const NAME: &'static str = "MsgUpdateBlockRateLimitConfigurationResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgUpdateBlockRateLimitConfigurationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgUpdateBlockRateLimitConfigurationResponse".into()
    }
}
/// MsgUpdateLiquidationsConfig is a request type for updating the liquidations
/// config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateLiquidationsConfig {
    /// Authority is the address that may send this message.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// Defines the liquidations configuration to update to. All fields must
    /// be set.
    #[prost(message, optional, tag = "2")]
    pub liquidations_config: ::core::option::Option<LiquidationsConfig>,
}
impl ::prost::Name for MsgUpdateLiquidationsConfig {
    const NAME: &'static str = "MsgUpdateLiquidationsConfig";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgUpdateLiquidationsConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgUpdateLiquidationsConfig".into()
    }
}
/// MsgUpdateLiquidationsConfig is the Msg/LiquidationsConfig response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateLiquidationsConfigResponse {}
impl ::prost::Name for MsgUpdateLiquidationsConfigResponse {
    const NAME: &'static str = "MsgUpdateLiquidationsConfigResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MsgUpdateLiquidationsConfigResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MsgUpdateLiquidationsConfigResponse".into()
    }
}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg defines the Msg service.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    #[cfg(feature = "grpc-transport")]
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// ProposedOperations is a temporary message used by block proposers
        /// for matching orders as part of the ABCI++ workaround.
        pub async fn proposed_operations(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgProposedOperations>,
        ) -> std::result::Result<
            tonic::Response<super::MsgProposedOperationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/ProposedOperations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Msg", "ProposedOperations"));
            self.inner.unary(req, path, codec).await
        }
        /// PlaceOrder allows accounts to place orders on the orderbook.
        pub async fn place_order(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgPlaceOrder>,
        ) -> std::result::Result<
            tonic::Response<super::MsgPlaceOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/PlaceOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Msg", "PlaceOrder"));
            self.inner.unary(req, path, codec).await
        }
        /// CancelOrder allows accounts to cancel existing orders on the orderbook.
        pub async fn cancel_order(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCancelOrder>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCancelOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/CancelOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Msg", "CancelOrder"));
            self.inner.unary(req, path, codec).await
        }
        /// BatchCancel allows accounts to cancel a batch of orders on the orderbook.
        pub async fn batch_cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgBatchCancel>,
        ) -> std::result::Result<
            tonic::Response<super::MsgBatchCancelResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/BatchCancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Msg", "BatchCancel"));
            self.inner.unary(req, path, codec).await
        }
        /// CreateClobPair creates a new clob pair.
        pub async fn create_clob_pair(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateClobPair>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCreateClobPairResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/CreateClobPair",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Msg", "CreateClobPair"));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateClobPair sets the status of a clob pair. Should return an error
        /// if the authority is not in the clob keeper's set of authorities,
        /// if the ClobPair id is not found in state, or if the update includes
        /// an unsupported status transition.
        pub async fn update_clob_pair(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateClobPair>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateClobPairResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/UpdateClobPair",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Msg", "UpdateClobPair"));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateEquityTierLimitConfiguration updates the equity tier limit
        /// configuration in state.
        pub async fn update_equity_tier_limit_configuration(
            &mut self,
            request: impl tonic::IntoRequest<
                super::MsgUpdateEquityTierLimitConfiguration,
            >,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateEquityTierLimitConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/UpdateEquityTierLimitConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dydxprotocol.clob.Msg",
                        "UpdateEquityTierLimitConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateBlockRateLimitConfiguration updates the block rate limit
        /// configuration in state.
        pub async fn update_block_rate_limit_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateBlockRateLimitConfiguration>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateBlockRateLimitConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/UpdateBlockRateLimitConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dydxprotocol.clob.Msg",
                        "UpdateBlockRateLimitConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateLiquidationsConfig updates the liquidations configuration in state.
        pub async fn update_liquidations_config(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateLiquidationsConfig>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateLiquidationsConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Msg/UpdateLiquidationsConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dydxprotocol.clob.Msg", "UpdateLiquidationsConfig"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Operation represents an operation in the proposed operations. Operation is
/// used internally within the memclob only.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operation {
    /// operation represents the operation that occurred, which can be a match,
    /// short term order placement, short term order cancellation, or the placement
    /// of a pre-existing stateful order.
    #[prost(oneof = "operation::Operation", tags = "1, 2, 3, 4")]
    pub operation: ::core::option::Option<operation::Operation>,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    /// operation represents the operation that occurred, which can be a match,
    /// short term order placement, short term order cancellation, or the placement
    /// of a pre-existing stateful order.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "1")]
        Match(super::ClobMatch),
        #[prost(message, tag = "2")]
        ShortTermOrderPlacement(super::MsgPlaceOrder),
        #[prost(message, tag = "3")]
        ShortTermOrderCancellation(super::MsgCancelOrder),
        #[prost(message, tag = "4")]
        PreexistingStatefulOrder(super::OrderId),
    }
}
impl ::prost::Name for Operation {
    const NAME: &'static str = "Operation";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.Operation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.Operation".into()
    }
}
/// InternalOperation represents an internal operation in the operations to
/// propose. InternalOperation is used internally within the memclob only.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternalOperation {
    /// operation represents the operation that occurred, which can be a match,
    /// Short-Term order placement, or the placement of a pre-existing stateful
    /// order.
    #[prost(oneof = "internal_operation::Operation", tags = "1, 2, 3, 4")]
    pub operation: ::core::option::Option<internal_operation::Operation>,
}
/// Nested message and enum types in `InternalOperation`.
pub mod internal_operation {
    /// operation represents the operation that occurred, which can be a match,
    /// Short-Term order placement, or the placement of a pre-existing stateful
    /// order.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "1")]
        Match(super::ClobMatch),
        #[prost(message, tag = "2")]
        ShortTermOrderPlacement(super::MsgPlaceOrder),
        #[prost(message, tag = "3")]
        PreexistingStatefulOrder(super::OrderId),
        #[prost(message, tag = "4")]
        OrderRemoval(super::OrderRemoval),
    }
}
impl ::prost::Name for InternalOperation {
    const NAME: &'static str = "InternalOperation";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.InternalOperation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.InternalOperation".into()
    }
}
/// ProcessProposerMatchesEvents is used for communicating which events occurred
/// in the last block that require updating the state of the memclob in the
/// Commit blocker. It contains information about the following state updates:
/// - Long term order IDs that were placed in the last block.
/// - Stateful order IDs that were expired in the last block.
/// - Order IDs that were filled in the last block.
/// - Stateful cancellations order IDs that were placed in the last block.
/// - Stateful order IDs forcefully removed in the last block.
/// - Conditional order IDs triggered in the last block.
/// - Conditional order IDs placed, but not triggered in the last block.
/// - The height of the block in which the events occurred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessProposerMatchesEvents {
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub placed_long_term_order_ids: ::prost::alloc::vec::Vec<OrderId>,
    #[prost(message, repeated, tag = "2")]
    pub expired_stateful_order_ids: ::prost::alloc::vec::Vec<OrderId>,
    #[prost(message, repeated, tag = "3")]
    pub order_ids_filled_in_last_block: ::prost::alloc::vec::Vec<OrderId>,
    #[deprecated]
    #[prost(message, repeated, tag = "4")]
    pub placed_stateful_cancellation_order_ids: ::prost::alloc::vec::Vec<OrderId>,
    #[prost(message, repeated, tag = "5")]
    pub removed_stateful_order_ids: ::prost::alloc::vec::Vec<OrderId>,
    #[prost(message, repeated, tag = "6")]
    pub conditional_order_ids_triggered_in_last_block: ::prost::alloc::vec::Vec<OrderId>,
    #[deprecated]
    #[prost(message, repeated, tag = "7")]
    pub placed_conditional_order_ids: ::prost::alloc::vec::Vec<OrderId>,
    #[prost(uint32, tag = "8")]
    pub block_height: u32,
}
impl ::prost::Name for ProcessProposerMatchesEvents {
    const NAME: &'static str = "ProcessProposerMatchesEvents";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.ProcessProposerMatchesEvents".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.ProcessProposerMatchesEvents".into()
    }
}
/// QueryGetClobPairRequest is request type for the ClobPair method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetClobPairRequest {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
impl ::prost::Name for QueryGetClobPairRequest {
    const NAME: &'static str = "QueryGetClobPairRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryGetClobPairRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryGetClobPairRequest".into()
    }
}
/// QueryClobPairResponse is response type for the ClobPair method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryClobPairResponse {
    #[prost(message, optional, tag = "1")]
    pub clob_pair: ::core::option::Option<ClobPair>,
}
impl ::prost::Name for QueryClobPairResponse {
    const NAME: &'static str = "QueryClobPairResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryClobPairResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryClobPairResponse".into()
    }
}
/// QueryAllClobPairRequest is request type for the ClobPairAll method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllClobPairRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllClobPairRequest {
    const NAME: &'static str = "QueryAllClobPairRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryAllClobPairRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryAllClobPairRequest".into()
    }
}
/// QueryClobPairAllResponse is response type for the ClobPairAll method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClobPairAllResponse {
    #[prost(message, repeated, tag = "1")]
    pub clob_pair: ::prost::alloc::vec::Vec<ClobPair>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryClobPairAllResponse {
    const NAME: &'static str = "QueryClobPairAllResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryClobPairAllResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryClobPairAllResponse".into()
    }
}
/// MevNodeToNodeCalculationRequest is a request message used to run the
/// MEV node <> node calculation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MevNodeToNodeCalculationRequest {
    /// Represents the matches on the "block proposer". Note that this field
    /// does not need to be the actual block proposer's matches for a block, since
    /// the MEV calculation logic is run with this nodes matches as the "block
    /// proposer" matches.
    #[prost(message, optional, tag = "1")]
    pub block_proposer_matches: ::core::option::Option<ValidatorMevMatches>,
    /// Represents the matches and mid-prices on the validator.
    #[prost(message, optional, tag = "2")]
    pub validator_mev_metrics: ::core::option::Option<MevNodeToNodeMetrics>,
}
impl ::prost::Name for MevNodeToNodeCalculationRequest {
    const NAME: &'static str = "MevNodeToNodeCalculationRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MevNodeToNodeCalculationRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MevNodeToNodeCalculationRequest".into()
    }
}
/// MevNodeToNodeCalculationResponse is a response message that contains the
/// MEV node <> node calculation result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MevNodeToNodeCalculationResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<
        mev_node_to_node_calculation_response::MevAndVolumePerClob,
    >,
}
/// Nested message and enum types in `MevNodeToNodeCalculationResponse`.
pub mod mev_node_to_node_calculation_response {
    /// MevAndVolumePerClob contains information about the MEV and volume per CLOB.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MevAndVolumePerClob {
        #[prost(uint32, tag = "1")]
        pub clob_pair_id: u32,
        #[prost(float, tag = "2")]
        pub mev: f32,
        #[prost(uint64, tag = "3")]
        pub volume: u64,
    }
    impl ::prost::Name for MevAndVolumePerClob {
        const NAME: &'static str = "MevAndVolumePerClob";
        const PACKAGE: &'static str = "dydxprotocol.clob";
        fn full_name() -> ::prost::alloc::string::String {
            "dydxprotocol.clob.MevNodeToNodeCalculationResponse.MevAndVolumePerClob"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/dydxprotocol.clob.MevNodeToNodeCalculationResponse.MevAndVolumePerClob"
                .into()
        }
    }
}
impl ::prost::Name for MevNodeToNodeCalculationResponse {
    const NAME: &'static str = "MevNodeToNodeCalculationResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.MevNodeToNodeCalculationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.MevNodeToNodeCalculationResponse".into()
    }
}
/// QueryEquityTierLimitConfigurationRequest is a request message for
/// EquityTierLimitConfiguration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryEquityTierLimitConfigurationRequest {}
impl ::prost::Name for QueryEquityTierLimitConfigurationRequest {
    const NAME: &'static str = "QueryEquityTierLimitConfigurationRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryEquityTierLimitConfigurationRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryEquityTierLimitConfigurationRequest".into()
    }
}
/// QueryEquityTierLimitConfigurationResponse is a response message that contains
/// the EquityTierLimitConfiguration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryEquityTierLimitConfigurationResponse {
    #[prost(message, optional, tag = "1")]
    pub equity_tier_limit_config: ::core::option::Option<EquityTierLimitConfiguration>,
}
impl ::prost::Name for QueryEquityTierLimitConfigurationResponse {
    const NAME: &'static str = "QueryEquityTierLimitConfigurationResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryEquityTierLimitConfigurationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryEquityTierLimitConfigurationResponse".into()
    }
}
/// QueryBlockRateLimitConfigurationRequest is a request message for
/// BlockRateLimitConfiguration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryBlockRateLimitConfigurationRequest {}
impl ::prost::Name for QueryBlockRateLimitConfigurationRequest {
    const NAME: &'static str = "QueryBlockRateLimitConfigurationRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryBlockRateLimitConfigurationRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryBlockRateLimitConfigurationRequest".into()
    }
}
/// QueryBlockRateLimitConfigurationResponse is a response message that contains
/// the BlockRateLimitConfiguration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBlockRateLimitConfigurationResponse {
    #[prost(message, optional, tag = "1")]
    pub block_rate_limit_config: ::core::option::Option<BlockRateLimitConfiguration>,
}
impl ::prost::Name for QueryBlockRateLimitConfigurationResponse {
    const NAME: &'static str = "QueryBlockRateLimitConfigurationResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryBlockRateLimitConfigurationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryBlockRateLimitConfigurationResponse".into()
    }
}
/// QueryStatefulOrderRequest is a request message for StatefulOrder.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStatefulOrderRequest {
    /// Order id to query.
    #[prost(message, optional, tag = "1")]
    pub order_id: ::core::option::Option<OrderId>,
}
impl ::prost::Name for QueryStatefulOrderRequest {
    const NAME: &'static str = "QueryStatefulOrderRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryStatefulOrderRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryStatefulOrderRequest".into()
    }
}
/// QueryStatefulOrderResponse is a response message that contains the stateful
/// order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStatefulOrderResponse {
    /// Stateful order placement.
    #[prost(message, optional, tag = "1")]
    pub order_placement: ::core::option::Option<LongTermOrderPlacement>,
    /// Fill amounts.
    #[prost(uint64, tag = "2")]
    pub fill_amount: u64,
    /// Triggered status.
    #[prost(bool, tag = "3")]
    pub triggered: bool,
}
impl ::prost::Name for QueryStatefulOrderResponse {
    const NAME: &'static str = "QueryStatefulOrderResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryStatefulOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryStatefulOrderResponse".into()
    }
}
/// QueryLiquidationsConfigurationRequest is a request message for
/// LiquidationsConfiguration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLiquidationsConfigurationRequest {}
impl ::prost::Name for QueryLiquidationsConfigurationRequest {
    const NAME: &'static str = "QueryLiquidationsConfigurationRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryLiquidationsConfigurationRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryLiquidationsConfigurationRequest".into()
    }
}
/// QueryLiquidationsConfigurationResponse is a response message that contains
/// the LiquidationsConfiguration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLiquidationsConfigurationResponse {
    #[prost(message, optional, tag = "1")]
    pub liquidations_config: ::core::option::Option<LiquidationsConfig>,
}
impl ::prost::Name for QueryLiquidationsConfigurationResponse {
    const NAME: &'static str = "QueryLiquidationsConfigurationResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryLiquidationsConfigurationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryLiquidationsConfigurationResponse".into()
    }
}
/// QueryNextClobPairIdRequest is a request message for the next clob pair id
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryNextClobPairIdRequest {}
impl ::prost::Name for QueryNextClobPairIdRequest {
    const NAME: &'static str = "QueryNextClobPairIdRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryNextClobPairIdRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryNextClobPairIdRequest".into()
    }
}
/// QueryNextClobPairIdResponse is a response message for the next clob pair id
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryNextClobPairIdResponse {
    #[prost(uint32, tag = "1")]
    pub next_clob_pair_id: u32,
}
impl ::prost::Name for QueryNextClobPairIdResponse {
    const NAME: &'static str = "QueryNextClobPairIdResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.QueryNextClobPairIdResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.QueryNextClobPairIdResponse".into()
    }
}
/// StreamOrderbookUpdatesRequest is a request message for the
/// StreamOrderbookUpdates method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamOrderbookUpdatesRequest {
    /// Clob pair ids to stream orderbook updates for.
    #[prost(uint32, repeated, tag = "1")]
    pub clob_pair_id: ::prost::alloc::vec::Vec<u32>,
    /// Subaccount ids to stream subaccount updates for.
    #[prost(message, repeated, tag = "2")]
    pub subaccount_ids: ::prost::alloc::vec::Vec<super::subaccounts::SubaccountId>,
    /// Market ids for price updates.
    #[prost(uint32, repeated, tag = "3")]
    pub market_ids: ::prost::alloc::vec::Vec<u32>,
    /// Filter order updates by subaccount IDs.
    /// If true, the orderbook updates only include orders from provided subaccount
    /// IDs.
    #[prost(bool, tag = "4")]
    pub filter_orders_by_subaccount_id: bool,
}
impl ::prost::Name for StreamOrderbookUpdatesRequest {
    const NAME: &'static str = "StreamOrderbookUpdatesRequest";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StreamOrderbookUpdatesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StreamOrderbookUpdatesRequest".into()
    }
}
/// StreamOrderbookUpdatesResponse is a response message for the
/// StreamOrderbookUpdates method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamOrderbookUpdatesResponse {
    /// Batch of updates for the clob pair.
    #[prost(message, repeated, tag = "1")]
    pub updates: ::prost::alloc::vec::Vec<StreamUpdate>,
}
impl ::prost::Name for StreamOrderbookUpdatesResponse {
    const NAME: &'static str = "StreamOrderbookUpdatesResponse";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StreamOrderbookUpdatesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StreamOrderbookUpdatesResponse".into()
    }
}
/// StreamUpdate is an update that will be pushed through the
/// GRPC stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUpdate {
    /// Block height of the update.
    #[prost(uint32, tag = "1")]
    pub block_height: u32,
    /// Exec mode of the update.
    #[prost(uint32, tag = "2")]
    pub exec_mode: u32,
    /// Contains one of an StreamOrderbookUpdate,
    /// StreamOrderbookFill, StreamTakerOrderStatus.
    #[prost(oneof = "stream_update::UpdateMessage", tags = "3, 4, 5, 6, 7")]
    pub update_message: ::core::option::Option<stream_update::UpdateMessage>,
}
/// Nested message and enum types in `StreamUpdate`.
pub mod stream_update {
    /// Contains one of an StreamOrderbookUpdate,
    /// StreamOrderbookFill, StreamTakerOrderStatus.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum UpdateMessage {
        #[prost(message, tag = "3")]
        OrderbookUpdate(super::StreamOrderbookUpdate),
        #[prost(message, tag = "4")]
        OrderFill(super::StreamOrderbookFill),
        #[prost(message, tag = "5")]
        TakerOrder(super::StreamTakerOrder),
        #[prost(message, tag = "6")]
        SubaccountUpdate(super::super::subaccounts::StreamSubaccountUpdate),
        #[prost(message, tag = "7")]
        PriceUpdate(super::super::prices::StreamPriceUpdate),
    }
}
impl ::prost::Name for StreamUpdate {
    const NAME: &'static str = "StreamUpdate";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StreamUpdate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StreamUpdate".into()
    }
}
/// StreamOrderbookUpdate provides information on an orderbook update. Used in
/// the full node GRPC stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamOrderbookUpdate {
    /// Snapshot indicates if the response is from a snapshot of the orderbook.
    /// All updates should be ignored until snapshot is recieved.
    /// If the snapshot is true, then all previous entries should be
    /// discarded and the orderbook should be resynced.
    #[prost(bool, tag = "1")]
    pub snapshot: bool,
    /// Orderbook updates for the clob pair. Can contain order place, removals,
    /// or updates.
    #[prost(message, repeated, tag = "2")]
    pub updates: ::prost::alloc::vec::Vec<
        super::indexer::off_chain_updates::OffChainUpdateV1,
    >,
}
impl ::prost::Name for StreamOrderbookUpdate {
    const NAME: &'static str = "StreamOrderbookUpdate";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StreamOrderbookUpdate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StreamOrderbookUpdate".into()
    }
}
/// StreamOrderbookFill provides information on an orderbook fill. Used in
/// the full node GRPC stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamOrderbookFill {
    /// Clob match. Provides information on which orders were matched
    /// and the type of order.
    #[prost(message, optional, tag = "1")]
    pub clob_match: ::core::option::Option<ClobMatch>,
    /// All orders involved in the specified clob match. Used to look up
    /// price of a match through a given maker order id.
    #[prost(message, repeated, tag = "2")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// Resulting fill amounts for each order in the orders array.
    #[prost(uint64, repeated, tag = "3")]
    pub fill_amounts: ::prost::alloc::vec::Vec<u64>,
}
impl ::prost::Name for StreamOrderbookFill {
    const NAME: &'static str = "StreamOrderbookFill";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StreamOrderbookFill".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StreamOrderbookFill".into()
    }
}
/// StreamTakerOrder provides information on a taker order that was attempted
/// to be matched on the orderbook.
/// It is intended to be used only in full node streaming.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamTakerOrder {
    /// Information on the taker order after it is matched on the book,
    /// either successfully or unsuccessfully.
    #[prost(message, optional, tag = "3")]
    pub taker_order_status: ::core::option::Option<StreamTakerOrderStatus>,
    /// The taker order that was matched on the orderbook. Can be a
    /// regular order or a liquidation order.
    #[prost(oneof = "stream_taker_order::TakerOrder", tags = "1, 2")]
    pub taker_order: ::core::option::Option<stream_taker_order::TakerOrder>,
}
/// Nested message and enum types in `StreamTakerOrder`.
pub mod stream_taker_order {
    /// The taker order that was matched on the orderbook. Can be a
    /// regular order or a liquidation order.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TakerOrder {
        #[prost(message, tag = "1")]
        Order(super::Order),
        #[prost(message, tag = "2")]
        LiquidationOrder(super::StreamLiquidationOrder),
    }
}
impl ::prost::Name for StreamTakerOrder {
    const NAME: &'static str = "StreamTakerOrder";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StreamTakerOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StreamTakerOrder".into()
    }
}
/// StreamTakerOrderStatus is a representation of a taker order
/// after it is attempted to be matched on the orderbook.
/// It is intended to be used only in full node streaming.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamTakerOrderStatus {
    /// The state of the taker order after attempting to match it against the
    /// orderbook. Possible enum values can be found here:
    /// <https://github.com/dydxprotocol/v4-chain/blob/main/protocol/x/clob/types/orderbook.go#L105>
    #[prost(uint32, tag = "1")]
    pub order_status: u32,
    /// The amount of remaining (non-matched) base quantums of this taker order.
    #[prost(uint64, tag = "2")]
    pub remaining_quantums: u64,
    /// The amount of base quantums that were *optimistically* filled for this
    /// taker order when the order is matched against the orderbook. Note that if
    /// any quantums of this order were optimistically filled or filled in state
    /// before this invocation of the matching loop, this value will not include
    /// them.
    #[prost(uint64, tag = "3")]
    pub optimistically_filled_quantums: u64,
}
impl ::prost::Name for StreamTakerOrderStatus {
    const NAME: &'static str = "StreamTakerOrderStatus";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StreamTakerOrderStatus".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StreamTakerOrderStatus".into()
    }
}
/// Generated client implementations.
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query defines the gRPC querier service.
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    #[cfg(feature = "grpc-transport")]
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Queries a ClobPair by id.
        pub async fn clob_pair(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetClobPairRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryClobPairResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/ClobPair",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Query", "ClobPair"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of ClobPair items.
        pub async fn clob_pair_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllClobPairRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryClobPairAllResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/ClobPairAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Query", "ClobPairAll"));
            self.inner.unary(req, path, codec).await
        }
        /// Runs the MEV node <> node calculation with the provided parameters.
        pub async fn mev_node_to_node_calculation(
            &mut self,
            request: impl tonic::IntoRequest<super::MevNodeToNodeCalculationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MevNodeToNodeCalculationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/MevNodeToNodeCalculation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dydxprotocol.clob.Query",
                        "MevNodeToNodeCalculation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries EquityTierLimitConfiguration.
        pub async fn equity_tier_limit_configuration(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryEquityTierLimitConfigurationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryEquityTierLimitConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/EquityTierLimitConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dydxprotocol.clob.Query",
                        "EquityTierLimitConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries BlockRateLimitConfiguration.
        pub async fn block_rate_limit_configuration(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryBlockRateLimitConfigurationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryBlockRateLimitConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/BlockRateLimitConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dydxprotocol.clob.Query",
                        "BlockRateLimitConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries LiquidationsConfiguration.
        pub async fn liquidations_configuration(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryLiquidationsConfigurationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryLiquidationsConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/LiquidationsConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dydxprotocol.clob.Query",
                        "LiquidationsConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries the stateful order for a given order id.
        pub async fn stateful_order(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryStatefulOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryStatefulOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/StatefulOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Query", "StatefulOrder"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries the next clob pair id.
        pub async fn next_clob_pair_id(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryNextClobPairIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryNextClobPairIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/NextClobPairId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dydxprotocol.clob.Query", "NextClobPairId"));
            self.inner.unary(req, path, codec).await
        }
        /// Streams orderbook updates. Updates contain orderbook data
        /// such as order placements, updates, and fills.
        pub async fn stream_orderbook_updates(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamOrderbookUpdatesRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::StreamOrderbookUpdatesResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dydxprotocol.clob.Query/StreamOrderbookUpdates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dydxprotocol.clob.Query", "StreamOrderbookUpdates"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// StagedFinalizeBlockEvent is an event staged during `FinalizeBlock`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StagedFinalizeBlockEvent {
    /// Contains one of StreamOrderbookFill, StreamSubaccountUpdate.
    #[prost(oneof = "staged_finalize_block_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<staged_finalize_block_event::Event>,
}
/// Nested message and enum types in `StagedFinalizeBlockEvent`.
pub mod staged_finalize_block_event {
    /// Contains one of StreamOrderbookFill, StreamSubaccountUpdate.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        OrderFill(super::StreamOrderbookFill),
        #[prost(message, tag = "2")]
        SubaccountUpdate(super::super::subaccounts::StreamSubaccountUpdate),
        #[prost(message, tag = "3")]
        OrderbookUpdate(super::StreamOrderbookUpdate),
        #[prost(message, tag = "4")]
        PriceUpdate(super::super::prices::StreamPriceUpdate),
    }
}
impl ::prost::Name for StagedFinalizeBlockEvent {
    const NAME: &'static str = "StagedFinalizeBlockEvent";
    const PACKAGE: &'static str = "dydxprotocol.clob";
    fn full_name() -> ::prost::alloc::string::String {
        "dydxprotocol.clob.StagedFinalizeBlockEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/dydxprotocol.clob.StagedFinalizeBlockEvent".into()
    }
}
