"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseType = exports.parseService = exports.parseRecur = exports.parseEnum = exports.parse = exports.getParsedObjectName = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _types = require("@osmonauts/types");

var _protoParser = require("@osmonauts/proto-parser");

var _ast = require("@osmonauts/ast");

var _utils = require("./utils");

var parse = function parse(context) {
  var root = (0, _utils.getRoot)(context.ref);
  parseRecur({
    context: context,
    obj: root.root,
    scope: [],
    isNested: false
  });
};

exports.parse = parse;

var getParsedObjectName = function getParsedObjectName(ref, obj, scope) {
  var _scope = (0, _toConsumableArray2["default"])(scope);

  var root = (0, _utils.getRoot)(ref);

  var allButPackage = _scope.splice(root["package"].split('.').length); // pull off "this" name


  allButPackage.pop();
  return (0, _protoParser.getObjectName)(obj.name, [root["package"]].concat((0, _toConsumableArray2["default"])(allButPackage)));
}; // TODO potentially move this back to ast or proto bc the ast lib references MapEntries...


exports.getParsedObjectName = getParsedObjectName;

var makeKeyTypeObj = function makeKeyTypeObj(ref, field, scope) {
  var root = (0, _utils.getRoot)(ref);
  var scoped = (0, _toConsumableArray2["default"])(scope).splice(root["package"].split('.').length);
  var adhocObj = {
    type: 'Type',
    comment: undefined,
    fields: {
      key: {
        id: 1,
        type: field.keyType,
        scope: (0, _toConsumableArray2["default"])(scoped),
        parsedType: {
          name: field.keyType,
          type: field.keyType
        },
        comment: undefined,
        options: undefined
      },
      value: {
        id: 2,
        type: field.parsedType.name,
        scope: (0, _toConsumableArray2["default"])(scoped),
        parsedType: {
          name: field.type,
          type: field.parsedType.type
        },
        comment: undefined,
        options: undefined
      }
    }
  };
  return adhocObj;
};

var parseType = function parseType(context, obj, scope) {
  var isNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  obj.keyTypes.forEach(function (field) {
    var keyTypeObject = makeKeyTypeObj(context.ref, field, (0, _toConsumableArray2["default"])(scope));
    var name = getParsedObjectName(context.ref, {
      name: (0, _ast.getKeyTypeEntryName)(obj.name, field.name)
    }, (0, _toConsumableArray2["default"])(scope));
    context.addType(name, keyTypeObject, true);
  }); // parse nested names

  var name = obj.name;

  if (isNested) {
    name = getParsedObjectName(context.ref, obj, (0, _toConsumableArray2["default"])(scope));
  }

  context.addType(name, obj, isNested); // render nested LAST

  if (obj.nested) {
    Object.keys(obj.nested).forEach(function (key) {
      // isNested = true;
      parseRecur({
        context: context,
        obj: obj.nested[key],
        scope: [].concat((0, _toConsumableArray2["default"])(scope), [key]),
        isNested: true
      });
    });
  }
};

exports.parseType = parseType;

var parseEnum = function parseEnum(context, obj, scope) {
  var isNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var name = obj.name; // parse nested names

  if (isNested) {
    name = getParsedObjectName(context.ref, obj, scope);
  }

  context.addType(name, obj, isNested);
};

exports.parseEnum = parseEnum;

var parseService = function parseService(context, obj, scope) {
  var isNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var methodHash = obj.methods;

  if (!_types.ALLOWED_RPC_SERVICES.includes(obj.name)) {
    return;
  }

  Object.entries(methodHash).forEach(function (_ref) {
    var _lookup$import, _lookupResponse$impor;

    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    var lookup = context.store.get(context.ref, value.requestType);

    if (!lookup) {
      console.warn("cannot find ".concat(value.requestType));
      throw new Error('undefined symbol for service.');
    }

    var lookupResponse = context.store.get(context.ref, value.responseType);

    if (!lookupResponse) {
      console.warn("cannot find ".concat(value.requestType));
      throw new Error('undefined symbol for service.');
    }

    var serviceInfo = {
      methodName: key,
      "package": context.ref.proto["package"],
      message: lookup.importedName,
      messageImport: (_lookup$import = lookup["import"]) !== null && _lookup$import !== void 0 ? _lookup$import : context.ref.filename,
      response: lookupResponse.importedName,
      responseImport: (_lookupResponse$impor = lookupResponse["import"]) !== null && _lookupResponse$impor !== void 0 ? _lookupResponse$impor : context.ref.filename,
      comment: value.comment
    };

    switch (obj.name) {
      case 'Msg':
        context.addMutation(serviceInfo);
        break;

      case 'Query':
        context.addQuery(serviceInfo);
        break;

      default:
        context.addService(serviceInfo);
        break;
    }
  });
};

exports.parseService = parseService;

var parseRecur = function parseRecur(_ref3) {
  var context = _ref3.context,
      obj = _ref3.obj,
      scope = _ref3.scope,
      isNested = _ref3.isNested;

  switch (obj.type) {
    case 'Type':
      return parseType(context, obj, scope, isNested);

    case 'Enum':
      return parseEnum(context, obj, scope, isNested);

    case 'Service':
      return parseService(context, obj, scope, isNested);

    case 'Field':
      console.log(obj);
      return;

    case 'Root':
    case 'Namespace':
      if (obj.nested) {
        return Object.keys(obj.nested).forEach(function (key) {
          parseRecur({
            context: context,
            obj: obj.nested[key],
            scope: [].concat((0, _toConsumableArray2["default"])(scope), [key]),
            isNested: isNested
          });
        });
      } else {
        throw new Error('parseRecur() cannot find protobufjs Type');
      }

    default: // if (obj.type === 'string') return;
    // if (obj.type === 'bool') return;
    // if (obj.type === 'HttpRule') return;
    // if (obj.type === 'InterfaceDescriptor') return;
    // if (obj.type === 'ScalarDescriptor') return;
    // if (obj.type === 'ModuleDescriptor') return;
    // if (obj.type === 'TableDescriptor') return;
    // if (obj.type === 'SingletonDescriptor') return;
    // if (obj.type === 'ModuleSchemaDescriptor') return;
    // if (obj.type === 'google.api.FieldBehavior') return;
    // if (obj.type === 'google.api.ResourceReference') return;
    // if (obj.type === 'google.api.ResourceDescriptor') return;
    // if (obj.type === 'google.api.RoutingRule') return;
    // if (obj.type === 'google.api.VisibilityRule') return;
    // if (obj.type === 'google.longrunning.OperationInfo') return;
    // throw new Error('parseRecur() cannot find protobufjs Type')

  }
};

exports.parseRecur = parseRecur;