"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getImportsFromQueries = exports.getImportsFromMutations = exports.getImportStatements = exports.getDepsFromQueries = exports.getDepsFromMutations = exports.buildAllImportsFromGenericContext = exports.buildAllImports = exports.aggregateImports = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _ast = require("@osmonauts/ast");

var _utils = require("./utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var importHashToArray = function importHashToArray(hash) {
  return Object.entries(hash !== null && hash !== void 0 ? hash : {}).reduce(function (m, _ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        path = _ref2[0],
        names = _ref2[1];

    names.forEach(function (name) {
      m.push({
        type: 'import',
        name: name,
        path: path
      });
    });
    return m;
  }, []);
};

var getProtoImports = function getProtoImports(context, filename) {
  return context.proto.imports.map(function (usage) {
    if (filename === usage["import"]) return;
    var importPath = (0, _utils.getRelativePath)(filename, usage["import"]);
    return {
      type: 'import',
      name: usage.name,
      importAs: usage.importedAs,
      path: importPath
    };
  }).filter(Boolean);
};

var getAminoImports = function getAminoImports(context, filename) {
  return context.amino.imports.map(function (usage) {
    if (filename === usage["import"]) return;
    var importPath = (0, _utils.getRelativePath)(filename, usage["import"]);
    return {
      type: 'import',
      name: usage.name,
      importAs: usage.importedAs,
      path: importPath
    };
  }).filter(Boolean);
};

var getGenericImports = function getGenericImports(context, filename) {
  return context.generic.imports.map(function (usage) {
    if (filename === usage["import"]) return;
    var importPath = (0, _utils.getRelativePath)(filename, usage["import"]);
    return {
      type: 'import',
      name: usage.name,
      importAs: usage.importedAs,
      path: importPath
    };
  }).filter(Boolean);
};

var getParsedImports = function getParsedImports(context, parsedImports, filename) {
  var imports = [];
  Object.entries(parsedImports !== null && parsedImports !== void 0 ? parsedImports : {}).forEach(function (_ref3) {
    var _context$ref, _context$ref$traverse, _context$ref$traverse2;

    var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
        path = _ref4[0],
        names = _ref4[1];

    if (filename === path) return;
    var importPath = (0, _utils.getRelativePath)(filename, path);
    var aliases = (_context$ref = context.ref) === null || _context$ref === void 0 ? void 0 : (_context$ref$traverse = _context$ref.traversed) === null || _context$ref$traverse === void 0 ? void 0 : (_context$ref$traverse2 = _context$ref$traverse.importNames) === null || _context$ref$traverse2 === void 0 ? void 0 : _context$ref$traverse2[path];
    names.forEach(function (name) {
      var importAs = name;

      if (aliases && aliases[name]) {
        importAs = aliases[name];
      }

      imports.push({
        type: 'import',
        name: name,
        importAs: importAs,
        path: importPath
      });
    });
  });
  return imports;
};

var importAs = function importAs(name, _importAs, importPath) {
  return t.importDeclaration([t.importSpecifier(t.identifier(_importAs), t.identifier(name))], t.stringLiteral(importPath));
}; // __helpers__


var getImportStatements = function getImportStatements(filepath, list) {
  // swap helpers with helpers file...
  var modifiedImports = list.map(function (imp) {
    if (_utils.UTIL_HELPERS.includes(imp.path)) {
      var name = imp.path.replace(/__/g, '');
      return _objectSpread(_objectSpread({}, imp), {}, {
        path: (0, _utils.getRelativePath)(filepath, "./".concat(name))
      });
    }

    return imp;
  });
  var imports = modifiedImports.reduce(function (m, obj) {
    m[obj.path] = m[obj.path] || [];
    var exists = m[obj.path].find(function (el) {
      return el.type === obj.type && el.path === obj.path && el.name === obj.name;
    }); // MARKED AS NOT DRY [google.protobuf names]
    // TODO some have google.protobuf.Any shows up... figure out the better way to handle this

    if (/\./.test(obj.name)) {
      obj.name = obj.name.split('.')[obj.name.split('.').length - 1];
    }

    if (!exists) {
      m[obj.path].push(obj);
    }

    return m;
  }, {});
  return Object.entries(imports).reduce(function (m, _ref5) {
    var _ref6 = (0, _slicedToArray2["default"])(_ref5, 2),
        importPath = _ref6[0],
        imports = _ref6[1];

    var defaultImports = imports.filter(function (a) {
      return a.type === 'default';
    });

    if (defaultImports.length) {
      if (defaultImports.length > 1) throw new Error('more than one default name NOT allowed.');
      m.push(t.importDeclaration([t.importDefaultSpecifier(t.identifier(defaultImports[0].name))], t.stringLiteral(defaultImports[0].path)));
    }

    var namedImports = imports.filter(function (a) {
      return a.type === 'import' && (!a.importAs || a.name === a.importAs);
    });

    if (namedImports.length) {
      m.push((0, _ast.importStmt)(namedImports.map(function (i) {
        return i.name;
      }), namedImports[0].path));
    }

    var aliasNamedImports = imports.filter(function (a) {
      return a.type === 'import' && a.importAs && a.name !== a.importAs;
    });
    aliasNamedImports.forEach(function (imp) {
      m.push(importAs(imp.name, imp.importAs, imp.path));
    });
    var namespaced = imports.filter(function (a) {
      return a.type === 'namespace';
    });

    if (namespaced.length) {
      if (namespaced.length > 1) throw new Error('more than one namespaced name NOT allowed.');
      m.push(t.importDeclaration([t.importNamespaceSpecifier(t.identifier(namespaced[0].name))], t.stringLiteral(namespaced[0].path)));
    }

    return m;
  }, []);
};

exports.getImportStatements = getImportStatements;

var convertUtilsToImports = function convertUtilsToImports(context) {
  var list = [];
  var utils = Object.keys(_objectSpread(_objectSpread(_objectSpread({}, context.amino.utils), context.proto.utils), context.generic.utils));
  utils.forEach(function (util) {
    if (!_utils.UTILS.hasOwnProperty(util)) throw new Error('missing Util! ::' + util);

    if (typeof _utils.UTILS[util] === 'string') {
      list.push({
        type: 'import',
        path: _utils.UTILS[util],
        name: util
      });
    } else {
      list.push(_utils.UTILS[util]);
    }
  });
  return list;
};

var convertUtilsToImportsGenric = function convertUtilsToImportsGenric(context) {
  var list = [];
  var utils = Object.keys(_objectSpread({}, context.utils)); // MARKED AS NOT DRY - duplicate of above

  utils.forEach(function (util) {
    if (!_utils.UTILS.hasOwnProperty(util)) throw new Error('missing Util! ::' + util);

    if (typeof _utils.UTILS[util] === 'string') {
      list.push({
        type: 'import',
        path: _utils.UTILS[util],
        name: util
      });
    } else {
      list.push(_utils.UTILS[util]);
    }
  });
  return list;
};

var buildAllImports = function buildAllImports(context, allImports, filepath) {
  var imports = aggregateImports(context, allImports, filepath);
  var importStmts = getImportStatements(filepath, imports);
  return importStmts;
};

exports.buildAllImports = buildAllImports;

var buildAllImportsFromGenericContext = function buildAllImportsFromGenericContext(context, filepath) {
  var imports = convertUtilsToImportsGenric(context);
  var importStmts = getImportStatements(filepath, imports);
  return importStmts;
};

exports.buildAllImportsFromGenericContext = buildAllImportsFromGenericContext;

var addSDKTypesToImports = function addSDKTypesToImports(context, imports) {
  var ref = context.ref;
  return imports.reduce(function (m, obj) {
    // SDKType
    // probably wont need this until we start generating osmonauts/helpers inline
    if (obj.type === 'import' && obj.path.startsWith('.')) {
      var _obj$importAs;

      var lookup = null;

      try {
        lookup = context.store.getImportFromRef(ref, obj.name);
      } catch (e) {}

      var SDKTypeObject = _objectSpread(_objectSpread({}, obj), {}, {
        name: obj.name + 'SDKType',
        importAs: ((_obj$importAs = obj.importAs) !== null && _obj$importAs !== void 0 ? _obj$importAs : obj.name) + 'SDKType'
      }); // MARKED AS NOT DRY [google.protobuf names]
      // TODO some have google.protobuf.Any shows up... figure out the better way to handle this


      if (/\./.test(SDKTypeObject.name)) {
        SDKTypeObject.name = SDKTypeObject.name.split('.')[SDKTypeObject.name.split('.').length - 1];
        SDKTypeObject.importAs = SDKTypeObject.importAs.split('.')[SDKTypeObject.importAs.split('.').length - 1];
      }

      if (lookup && ['Type', 'Enum'].includes(lookup.obj.type)) {
        return [].concat((0, _toConsumableArray2["default"])(m), [obj, SDKTypeObject]);
      }
    }

    return [].concat((0, _toConsumableArray2["default"])(m), [obj]);
  }, []);
};

var aggregateImports = function aggregateImports(context, allImports, filepath) {
  var protoImports = getProtoImports(context, filepath);
  var aminoImports = getAminoImports(context, filepath);
  var genericImports = getGenericImports(context, filepath);
  var parsedImports = getParsedImports(context, context.amino.ref.traversed.parsedImports, filepath);
  var additionalImports = importHashToArray(allImports);
  var utilities = convertUtilsToImports(context);
  var list = [].concat(parsedImports).concat(utilities).concat(protoImports).concat(aminoImports).concat(genericImports).concat(additionalImports);

  if (context.options.useSDKTypes) {
    return addSDKTypesToImports(context, list);
  } else {
    return list;
  }
};

exports.aggregateImports = aggregateImports;

var getImportsFromMutations = function getImportsFromMutations(mutations) {
  return mutations.map(function (mutation) {
    return {
      "import": mutation.messageImport,
      name: mutation.message
    };
  });
}; // TODO implement ServiceQuery type (it is the same)


exports.getImportsFromMutations = getImportsFromMutations;

var getImportsFromQueries = function getImportsFromQueries(queries) {
  return queries.reduce(function (m, query) {
    var req = {
      "import": query.messageImport,
      name: query.message
    };
    var res = {
      "import": query.responseImport,
      name: query.response
    };
    return [].concat((0, _toConsumableArray2["default"])(m), [req, res]);
  }, []);
};

exports.getImportsFromQueries = getImportsFromQueries;

var getDepsFromMutations = function getDepsFromMutations(mutations, filename) {
  return getImportsFromMutations(mutations).map(function (imp) {
    var f = filename;
    var f2 = imp["import"];
    if (f === f2) return;
    var importPath = (0, _utils.getRelativePath)(f, f2);
    return _objectSpread(_objectSpread({}, imp), {}, {
      importPath: importPath
    });
  }).filter(Boolean).reduce(function (m, v) {
    var _m$v$importPath;

    m[v.importPath] = (_m$v$importPath = m[v.importPath]) !== null && _m$v$importPath !== void 0 ? _m$v$importPath : [];

    if (!m[v.importPath].includes(v.name)) {
      m[v.importPath].push(v.name);
    }

    return m;
  }, {});
};

exports.getDepsFromMutations = getDepsFromMutations;

var getDepsFromQueries = function getDepsFromQueries(queries, filename) {
  return getImportsFromQueries(queries).map(function (imp) {
    var f = filename;
    var f2 = imp["import"];
    if (f === f2) return;
    var importPath = (0, _utils.getRelativePath)(f, f2);
    return _objectSpread(_objectSpread({}, imp), {}, {
      importPath: importPath
    });
  }).filter(Boolean).reduce(function (m, v) {
    var _m$v$importPath2;

    m[v.importPath] = (_m$v$importPath2 = m[v.importPath]) !== null && _m$v$importPath2 !== void 0 ? _m$v$importPath2 : [];

    if (!m[v.importPath].includes(v.name)) {
      m[v.importPath].push(v.name);
    }

    return m;
  }, {});
};

exports.getDepsFromQueries = getDepsFromQueries;