"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var shell = _interopRequireWildcard(require("shelljs"));

var _prompt = require("../utils/prompt");

var _dargs = _interopRequireDefault(require("dargs"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var glob = require('glob').sync;

var fs = require('fs');

var path = require('path');

var repo = 'https://github.com/pyramation/tmpl-cosmwasm-module.git';

var _default = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(argv) {
    var _yield$prompt, name, questions, fullname, email, args, results, scopedResults, license, files, _loop, i, _ret;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (shell.which('git')) {
              _context.next = 3;
              break;
            }

            shell.echo('Sorry, this script requires git');
            return _context.abrupt("return", shell.exit(1));

          case 3:
            _context.next = 5;
            return (0, _prompt.prompt)([{
              type: 'string',
              name: 'name',
              message: 'Enter your new module name'
            }], argv);

          case 5:
            _yield$prompt = _context.sent;
            name = _yield$prompt.name;
            shell.exec("git clone ".concat(repo, " ").concat(name));
            shell.cd(name);
            questions = JSON.parse(fs.readFileSync(".questions.json"));
            fullname = shell.exec('git config --global user.name', {
              silent: true
            }).trim();
            email = shell.exec('git config --global user.email', {
              silent: true
            }).trim(); // @__USERNAME__/__MODULENAME__
            // __PACKAGE_IDENTIFIER__

            args = (0, _dargs["default"])(_objectSpread(_objectSpread({
              _: []
            }, argv), {}, {
              __MODULENAME__: name,
              __USERFULLNAME__: fullname,
              __USEREMAIL__: email
            }), {
              allowCamelCase: true
            });
            _context.next = 15;
            return (0, _prompt.prompt)(questions, args);

          case 15:
            results = _context.sent;
            _context.next = 18;
            return (0, _prompt.prompt)([{
              name: '__LICENSE__',
              message: 'Which license?',
              choices: ['MIT', 'closed'],
              type: 'list',
              required: true
            }], []);

          case 18:
            license = _context.sent;

            if (!(results.__ACCESS__ === 'public')) {
              _context.next = 23;
              break;
            }

            _context.next = 22;
            return (0, _prompt.prompt)([{
              type: 'confirm',
              name: 'scoped',
              message: 'use npm scopes?',
              required: true
            }], []);

          case 22:
            scopedResults = _context.sent;

          case 23:
            files = [].concat(glob(process.cwd() + '/**/.*')).concat(glob(process.cwd() + '/**/*'));

            _loop = function _loop(i) {
              var templateFile = files[i];
              if (fs.lstatSync(templateFile).isDirectory()) return "continue";
              var content = fs.readFileSync(templateFile).toString();

              if (path.basename(templateFile) === 'LICENSE' && license.__LICENSE__ === 'closed') {
                content = "Copyright (c) 2022 __USERFULLNAME__ <__USEREMAIL__> - All Rights Reserved\nUnauthorized copying via any medium is strictly prohibited\nProprietary and confidential";
              }

              Object.keys(results).forEach(function (key) {
                if (/^__/.test(key)) {
                  content = content.replace(new RegExp(key, 'g'), results[key]);
                }
              });

              if (results.__ACCESS__ === 'public') {
                if (scopedResults.scoped) {
                  content = content.replace(/__PACKAGE_IDENTIFIER__/g, "@".concat(results.__USERNAME__, "/").concat(results.__MODULENAME__));
                } else {
                  content = content.replace(/__PACKAGE_IDENTIFIER__/g, "".concat(results.__MODULENAME__));
                }
              } else {
                content = content.replace(/__PACKAGE_IDENTIFIER__/g, "@".concat(results.__USERNAME__, "/").concat(results.__MODULENAME__));
              }

              if (path.basename(templateFile) === 'README.md') {
                content = "# ".concat(results.__MODULENAME__);
              }

              fs.writeFileSync(templateFile, content);
            };

            i = 0;

          case 26:
            if (!(i < files.length)) {
              _context.next = 33;
              break;
            }

            _ret = _loop(i);

            if (!(_ret === "continue")) {
              _context.next = 30;
              break;
            }

            return _context.abrupt("continue", 30);

          case 30:
            i++;
            _context.next = 26;
            break;

          case 33:
            shell.rm('-rf', '.git');
            shell.rm('-rf', '.questions.json');
            console.log("\n\n       |||\n      (o o)\n  ooO--(_)--Ooo-\n\n  \u2728 Great work!\n  ");

          case 36:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

exports["default"] = _default;