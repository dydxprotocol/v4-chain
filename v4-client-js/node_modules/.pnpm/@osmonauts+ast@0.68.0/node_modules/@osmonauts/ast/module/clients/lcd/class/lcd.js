import * as t from '@babel/types';
import { arrowFunctionExpression, callExpression, classMethod, classProperty, identifier, objectPattern } from '../../../utils'; // this is the ONLY time ast uses babel/parser

import { parse } from '@babel/parser';

const getAstFromString = str => {
  const plugins = ['objectRestSpread', 'classProperties', 'optionalCatchBinding', 'asyncGenerators', 'decorators-legacy', 'typescript', 'dynamicImport'];
  const ast = parse(str, {
    sourceType: 'module',
    // @ts-ignore
    plugins
  });
  return ast;
};

const getResponseTypeName = (context, name) => {
  return name + (context.options.useSDKTypes ? 'SDKType' : '');
};

const returnReponseType = (context, name) => {
  return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, name)))])));
};

const firstLower = s => s = s.charAt(0).toLowerCase() + s.slice(1);

const firstUpper = s => s = s.charAt(0).toUpperCase() + s.slice(1);

const returnAwaitRequest = (context, responseType, // method: 'get' | 'post',
hasOptions = false) => {
  const args = [t.identifier('endpoint')]; // if (method === 'post') {
  //     args.push(t.identifier('body'));
  // }

  if (hasOptions) {
    args.push(t.identifier('options'));
  }

  return t.returnStatement(t.awaitExpression(callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('req')), t.identifier('get')), args, t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, responseType)))]))));
};

const makeOptionsObject = () => {
  return t.variableDeclaration('const', [t.variableDeclarator(identifier('options', t.tsTypeAnnotation(t.tsAnyKeyword())), t.objectExpression([t.objectProperty(t.identifier('params'), t.objectExpression([]))]))]);
};

const setParamOption = (context, name, svc) => {
  const flippedCasing = Object.keys(svc.info.casing).reduce((m, v) => {
    m[svc.info.casing[v]] = v;
    return m;
  }, {});
  const queryParam = flippedCasing[name] ? flippedCasing[name] : name;
  const param = svc.info.paramMap[name]; // options.params.group_id = params.groupId;

  let expr = t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.memberExpression(t.identifier('options'), t.identifier('params')), t.identifier(queryParam)), t.memberExpression(t.identifier('params'), t.identifier(param))));

  if (name === 'pagination') {
    context.addUtil('setPaginationParams');
    expr = t.expressionStatement(t.callExpression(t.identifier('setPaginationParams'), [t.identifier('options'), t.memberExpression(t.identifier('params'), t.identifier('pagination'), false)]));
  }

  return t.ifStatement(t.binaryExpression('!==', t.unaryExpression('typeof', t.optionalMemberExpression(t.identifier('params'), t.identifier(param), false, true)), t.stringLiteral('undefined')), t.blockStatement([expr]));
}; // breaks a url string to prepare it for template strings


export const getUrlTemplateString = url => {
  const parts = url.split('/').filter(a => a !== '');
  let cur = [];
  let strs = [];
  let atEnd = false;

  for (let p = 0; p < parts.length; p++) {
    const part = parts[p];

    if (/[{}]+/.test(part)) {
      if (p === parts.length - 1) atEnd = true;

      if (cur.length) {
        const vals = cur.join('/');
        strs.push(vals);
      } else {
        strs.push('/');
      }

      cur = [];
    } else {
      cur.push(part);
    }
  }

  if (cur.length) {
    strs.push(cur.join('/'));
  }

  strs = strs.filter(str => str !== '').map((v, i) => {
    if (i === 0) {
      if (!v.endsWith('/')) v = `${v}/`;
      return v;
    } else if (i === strs.length - 1) {
      if (atEnd) {
        // we want them to end with / if it's an "atEnd" el
        if (!v.endsWith('/')) v = `${v}/`;
        return v;
      } // they should all start with "/"


      if (!v.startsWith('/')) v = `/${v}`;
      return v;
    }

    if (!v.endsWith('/')) v = `${v}/`;
    if (!v.startsWith('/')) v = `/${v}`;
    return v;
  });
  return {
    strs,
    atEnd
  };
};
export const makeTemplateTag = info => {
  const route = info.url.split('/').filter(a => a !== '').map(a => {
    if (a.startsWith('{')) {
      return `$${a}`;
    } else {
      return a;
    }
  }).join('/');
  const parsed = getAstFromString(`\`${route}\``);
  const ast = parsed.program.body[0].expression;
  ast.expressions = ast.expressions.map(identifier => {
    const name = info.casing?.[identifier.name] ? info.casing[identifier.name] : identifier.name;
    return t.memberExpression(t.identifier('params'), t.identifier(name));
  });
  return ast;
}; // do we need to set end prop in ast?
// we may want to t.templateElement!!!

export const makeTemplateTagLegacy = info => {
  if (!info.url) throw new Error('no URL on service method');
  const parts = getUrlTemplateString(info.url);
  const templateElts = parts.strs.map(raw => t.templateElement({
    raw
  })); // Number of TemplateLiteral quasis should be exactly one more than the number of expressions

  const pathParams = info.pathParams.map(param => {
    const name = info.casing?.[param] ? info.casing[param] : param;
    return t.memberExpression(t.identifier('params'), t.identifier(name));
  });

  if (parts.atEnd) {
    templateElts.push(t.templateElement({
      raw: ''
    }));
  } // THIS MEANS WE PROBABLY HAVE A BUG


  if (templateElts.length !== pathParams.length + 1) {
    templateElts.push(t.templateElement({
      raw: ''
    }));
  }

  templateElts.forEach((el, n) => {
    if (n === templateElts.length - 1) {
      // remove trailing slash...
      el.value.raw = el.value.raw.replace(/\/$/, '');
    }
  });
  return t.templateLiteral(templateElts, pathParams);
};

const makeComment = comment => {
  return [{
    type: 'CommentBlock',
    value: ` ${comment} `
  }];
};

const buildRequestMethod = (context, serviceMethod) => {
  const methodName = firstLower(serviceMethod.name);
  const comment = serviceMethod.comment ?? serviceMethod.name;

  if (!serviceMethod.info) {
    throw new Error('No Service URL!');
  }

  const queryParams = serviceMethod.info.queryParams.map(param => {
    return setParamOption(context, param, serviceMethod);
  });
  const optionsAst = [];

  if (serviceMethod.info.queryParams.length) {
    // options params object
    optionsAst.push(makeOptionsObject());
  } // parse field types


  Object.entries(serviceMethod.fields ?? {}).forEach(([key, value]) => {
    switch (value.parsedType.type) {
      case 'Type':
        // this gets the import for us and loads them into ctx
        // if later we need to get subtypes, we have it all w/ctx
        context.getTypeName(value);

      case 'native':
    }
  });
  const fieldNames = Object.keys(serviceMethod.fields ?? {});
  const hasParams = fieldNames.length > 0;
  const paramName = hasParams ? 'params' : '_params';
  let methodArgs = identifier(paramName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(serviceMethod.requestType)))); // if no params, then let's default to empty object for cleaner API

  if (!hasParams) {
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([]));
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([t.objectProperty(t.identifier('pagination'), t.identifier('undefined'), false, false)]));
  }

  const body = t.blockStatement([...optionsAst, // if optional params not undefined
  ...queryParams, // endpoint
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('endpoint'), makeTemplateTag(serviceMethod.info))]), // return 
  returnAwaitRequest(context, serviceMethod.responseType, // serviceMethod.info.method,
  serviceMethod.info.queryParams.length > 0)]);

  if (context.pluginValue('classesUseArrowFunctions')) {
    return classProperty(t.identifier(methodName), arrowFunctionExpression([methodArgs], body, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, serviceMethod.responseType)))]))), true), undefined, undefined, undefined, undefined, undefined, undefined, makeComment(comment));
  }

  return classMethod('method', t.identifier(methodName), [methodArgs], body, returnReponseType(context, serviceMethod.responseType), makeComment(comment), false, false, false, true // async
  );
}; // MARKED AS NOT DRY (used in rpc/lcd)


const bindThis = name => {
  return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier(name)), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(name)), t.identifier('bind')), [t.thisExpression()])));
};

const createLCDClientClassBody = (context, clientName, methods, service) => {
  let boundMethods = []; // until the super() issue is figured out, we have to remove this

  if (service && !context.pluginValue('classesUseArrowFunctions')) {
    boundMethods = Object.keys(service.methods).map(key => {
      const method = service.methods[key];

      if (typeof method.options?.['(google.api.http).get'] !== 'undefined') {
        const methodName = firstLower(method.name);
        return bindThis(methodName);
      }
    }).filter(Boolean);
  }

  return t.exportNamedDeclaration(t.classDeclaration(t.identifier(clientName), null, t.classBody([t.classProperty(t.identifier('req'), null, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('LCDClient')))), // constructor
  t.classMethod('constructor', t.identifier('constructor'), [objectPattern([t.objectProperty(t.identifier('requestClient'), t.identifier('requestClient'), false, true)], t.tsTypeAnnotation(t.tsTypeLiteral([t.tsPropertySignature(t.identifier('requestClient'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('LCDClient'))))])))], t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('req')), t.identifier('requestClient'))), /// methods
  ...boundMethods])), ...methods])));
};

export const createLCDClient = (context, service) => {
  const methods = Object.keys(service.methods).map(key => {
    const method = service.methods[key];

    if (method.info && typeof method.options?.['(google.api.http).get'] !== 'undefined') {
      return buildRequestMethod(context, method);
    }
  }).filter(Boolean);
  context.addUtil('LCDClient');

  if (methods.length) {
    const clientName = 'LCDQueryClient';
    return createLCDClientClassBody(context, clientName, methods, service);
  }
};
export const createAggregatedLCDClient = (context, services, clientName) => {
  context.addUtil('LCDClient');
  const methods = services.reduce((m, service) => {
    const innerMethods = Object.keys(service.methods).map(key => {
      const method = service.methods[key];
      return buildRequestMethod(context, method);
    });
    return [...m, ...innerMethods];
  }, []);
  return createLCDClientClassBody(context, clientName, methods);
};