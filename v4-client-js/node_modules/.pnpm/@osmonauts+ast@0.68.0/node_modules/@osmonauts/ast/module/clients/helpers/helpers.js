import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import * as t from '@babel/types';
import { identifier } from '../../utils';
import { camel } from '@osmonauts/utils';
export const addMsgMethod = ({
  methodName,
  typeUrl,
  TypeName,
  methodToCall
}) => {
  return t.objectMethod('method', t.identifier(methodName), [identifier('value', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(TypeName))))], t.blockStatement([t.returnStatement(t.objectExpression([t.objectProperty(t.identifier('typeUrl'), t.stringLiteral(typeUrl)), t.objectProperty(t.identifier('value'), t.callExpression(t.memberExpression(t.identifier(TypeName), t.identifier(methodToCall)), [t.identifier('value')]))]))]));
};
export const addFromJSONMethod = ({
  methodName,
  typeUrl,
  TypeName
}) => {
  return t.objectMethod('method', t.identifier(methodName), [identifier('value', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('any'))))], t.blockStatement([t.returnStatement(t.objectExpression([t.objectProperty(t.identifier('typeUrl'), t.stringLiteral(typeUrl)), t.objectProperty(t.identifier('value'), t.callExpression(t.memberExpression(t.identifier(TypeName), t.identifier('fromJSON')), [t.identifier('value')]))]))]));
};
export const addFromPartialMethod = ({
  methodName,
  typeUrl,
  TypeName
}) => {
  return addMsgMethod({
    methodName,
    typeUrl,
    TypeName,
    methodToCall: 'fromPartial'
  });
};
export const addToJSONMethod = ({
  methodName,
  typeUrl,
  TypeName
}) => {
  return addMsgMethod({
    methodName,
    typeUrl,
    TypeName,
    methodToCall: 'toJSON'
  });
};
export const addJsonMethod = ({
  methodName,
  typeUrl,
  TypeName
}) => {
  return t.objectMethod('method', t.identifier(methodName), [identifier('value', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(TypeName))))], t.blockStatement([t.returnStatement(t.objectExpression([t.objectProperty(t.identifier('typeUrl'), t.stringLiteral(typeUrl)), t.objectProperty(t.identifier('value'), t.identifier('value'), false, true)]))]));
};
export const addEncodedMethod = ({
  methodName,
  typeUrl,
  TypeName
}) => {
  return t.objectMethod('method', t.identifier(methodName), [identifier('value', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(TypeName))))], t.blockStatement([t.returnStatement(t.objectExpression([t.objectProperty(t.identifier('typeUrl'), t.stringLiteral(typeUrl)), t.objectProperty(t.identifier('value'), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier(TypeName), t.identifier('encode')), [t.identifier('value')]), t.identifier('finish')), []))]))]));
};
export const createHelperObject = ({
  context,
  // for future plugins
  name,
  mutations
}) => {
  mutations = mutations.map(mutation => {
    return _objectSpread(_objectSpread({}, mutation), {}, {
      methodName: camel(mutation.methodName)
    });
  });
  const methods = [context.pluginValue('prototypes.methods.encode') && t.objectProperty(t.identifier('encoded'), t.objectExpression(mutations.map(mutation => addEncodedMethod(mutation)))), t.objectProperty(t.identifier('withTypeUrl'), t.objectExpression(mutations.map(mutation => addJsonMethod(mutation)))), context.pluginValue('prototypes.methods.toJSON') && t.objectProperty(t.identifier('toJSON'), t.objectExpression(mutations.map(mutation => addToJSONMethod(mutation)))), context.pluginValue('prototypes.methods.fromJSON') && t.objectProperty(t.identifier('fromJSON'), t.objectExpression(mutations.map(mutation => addFromJSONMethod(mutation)))), context.pluginValue('prototypes.methods.fromPartial') && t.objectProperty(t.identifier('fromPartial'), t.objectExpression(mutations.map(mutation => addFromPartialMethod(mutation))))].filter(Boolean);
  return t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(name), t.objectExpression(methods))]));
};