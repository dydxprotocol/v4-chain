"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.types = exports.encode = exports.arrayTypes = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

var _types2 = require("../types");

var _ = require("..");

var _types3 = require("../../types");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var notUndefined = function notUndefined(prop) {
  return t.binaryExpression('!==', t.memberExpression(t.identifier('message'), t.identifier(prop)), t.identifier('undefined'));
};

var ifNotUndefined = function ifNotUndefined(prop, stmt) {
  return t.ifStatement(notUndefined(prop), t.blockStatement([stmt]));
};

var notEmptyString = function notEmptyString(prop) {
  return t.binaryExpression('!==', t.memberExpression(t.identifier('message'), t.identifier(prop)), t.stringLiteral(''));
};

var longNotZero = function longNotZero(prop) {
  return t.unaryExpression('!', t.callExpression(t.memberExpression(t.memberExpression(t.identifier('message'), t.identifier(prop)), t.identifier('isZero')), []));
};

var lengthNotZero = function lengthNotZero(prop) {
  return t.binaryExpression('!==', t.memberExpression(t.memberExpression(t.identifier('message'), t.identifier(prop)), t.identifier('length')), t.numericLiteral(0));
};

var ifTrue = function ifTrue(prop) {
  return t.binaryExpression('===', t.memberExpression(t.identifier('message'), t.identifier(prop)), t.booleanLiteral(true));
};

var notZero = function notZero(prop) {
  return t.binaryExpression('!==', t.memberExpression(t.identifier('message'), t.identifier(prop)), t.numericLiteral(0));
}; // TODO research, shouldn't we AND these two tests?


var wrapOptional = function wrapOptional(prop, test, isOptional) {
  if (isOptional) {
    return notUndefined(prop);
  }

  return test;
};

var scalarType = function scalarType(num, prop, type) {
  return t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier(type)), [t.memberExpression(t.identifier('message'), t.identifier(prop))]))]);
};

var encode = {
  string: function string(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.string(num, prop, args.isOptional);
  },
  "double": function double(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types["double"](num, prop, args.isOptional);
  },
  "float": function float(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types["float"](num, prop, args.isOptional);
  },
  int32: function int32(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.int32(num, prop, args.isOptional);
  },
  sint32: function sint32(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.sint32(num, prop, args.isOptional);
  },
  uint32: function uint32(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.uint32(num, prop, args.isOptional);
  },
  fixed32: function fixed32(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.fixed32(num, prop, args.isOptional);
  },
  sfixed32: function sfixed32(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.sfixed32(num, prop, args.isOptional);
  },
  int64: function int64(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.int64(num, prop, args.isOptional);
  },
  sint64: function sint64(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.sint64(num, prop, args.isOptional);
  },
  uint64: function uint64(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.uint64(num, prop, args.isOptional);
  },
  fixed64: function fixed64(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.fixed64(num, prop, args.isOptional);
  },
  sfixed64: function sfixed64(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.sfixed64(num, prop, args.isOptional);
  },
  bool: function bool(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.bool(num, prop, args.isOptional);
  },
  type: function type(args) {
    var prop = args.field.name;
    var name = args.context.getTypeName(args.field);
    var num = (0, _types2.getTagNumber)(args.field);
    return types.type(num, prop, name);
  },
  "enum": function _enum(args) {
    var num = (0, _types2.getTagNumber)(args.field);
    return types["enum"](args.context, num, args.field, args.isOptional, args.isOneOf);
  },
  bytes: function bytes(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.bytes(num, prop, args.isOptional);
  },
  timestamp: function timestamp(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    var timestampFormat = args.context.pluginValue('prototypes.typingsFormat.timestamp');

    switch (timestampFormat) {
      case 'timestamp':
        return types.timestamp(num, prop);

      case 'date':
      default:
        args.context.addUtil('toTimestamp');
        return types.timestampDate(num, prop);
    }
  },
  duration: function duration(args) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    var durationFormat = args.context.pluginValue('prototypes.typingsFormat.duration');

    switch (durationFormat) {
      case 'string':
        args.context.addUtil('toDuration');
        return types.duration(num, prop);

      case 'duration':
      default:
        return encode.type(args);
    }
  },
  forkDelimArray: function forkDelimArray(args, expr) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.forkDelimArray(num, prop, expr);
  },
  array: function array(args, expr) {
    var prop = args.field.name;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.array(num, prop, expr);
  },
  typeArray: function typeArray(args) {
    var prop = args.field.name;
    var name = args.context.getTypeName(args.field);
    var num = (0, _types2.getTagNumber)(args.field);
    return types.typeArray(num, prop, name);
  },
  keyHash: function keyHash(args) {
    var prop = args.field.name;
    var name = args.typeName;
    var num = (0, _types2.getTagNumber)(args.field);
    return types.keyHash(num, prop, name);
  }
};
exports.encode = encode;
var types = {
  /*
      if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
      }
  */
  string: function string(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, notEmptyString(prop), isOptional), scalarType(num, prop, 'string'));
  },

  /*
      if (message.doubleValue !== 0) {
        writer.uint32(41).double(message.doubleValue);
      }
  */
  "double": function double(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, notZero(prop), isOptional), scalarType(num, prop, 'double'));
  },

  /*
      if (message.floatValue !== 0) {
        writer.uint32(41).float(message.floatValue);
      }
  */
  "float": function float(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, notZero(prop), isOptional), scalarType(num, prop, 'float'));
  },
  //   if (message.int32Value !== 0) {
  //     writer.uint32(24).int32(message.int32Value);
  //   }
  int32: function int32(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, notZero(prop), isOptional), scalarType(num, prop, 'int32'));
  },
  //   if (message.sint32Value !== 0) {
  //     writer.uint32(24).sint32(message.sint32Value);
  //   }
  sint32: function sint32(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, notZero(prop), isOptional), scalarType(num, prop, 'sint32'));
  },
  //   if (message.int32Value !== 0) {
  //     writer.uint32(24).uint32(message.int32Value);
  //   }
  uint32: function uint32(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, notZero(prop), isOptional), scalarType(num, prop, 'uint32'));
  },
  fixed32: function fixed32(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, notZero(prop), isOptional), scalarType(num, prop, 'fixed32'));
  },
  sfixed32: function sfixed32(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, notZero(prop), isOptional), scalarType(num, prop, 'sfixed32'));
  },
  //   if (!message.int64Value.isZero()) {
  //     writer.uint32(24).int64(message.int64Value);
  //   }
  int64: function int64(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, longNotZero(prop), isOptional), scalarType(num, prop, 'int64'));
  },
  //   if (!message.sint64Value.isZero()) {
  //     writer.uint32(24).sint64(message.sint64Value);
  //   }
  sint64: function sint64(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, longNotZero(prop), isOptional), scalarType(num, prop, 'sint64'));
  },
  //   if (!message.int64Value.isZero()) {
  //     writer.uint32(24).uint64(message.int64Value);
  //   }
  uint64: function uint64(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, longNotZero(prop), isOptional), scalarType(num, prop, 'uint64'));
  },
  fixed64: function fixed64(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, longNotZero(prop), isOptional), scalarType(num, prop, 'fixed64'));
  },
  sfixed64: function sfixed64(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, longNotZero(prop), isOptional), scalarType(num, prop, 'sfixed64'));
  },
  //   if (message.disableMacros === true) {
  //     writer.uint32(32).bool(message.disableMacros);
  //   }
  bool: function bool(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, ifTrue(prop), isOptional), scalarType(num, prop, 'bool'));
  },
  type: function type(num, prop, name) {
    return t.ifStatement(notUndefined(prop), t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier(name), t.identifier('encode')), [t.memberExpression(t.identifier('message'), t.identifier(prop)), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('fork')), [])]), t.identifier('ldelim')), []))]));
  },
  //   if (message.singleField !== 0) {
  //     writer.uint32(24).int32(message.singleField);
  //   }
  "enum": function _enum(context, num, field, isOptional, isOneOf) {
    var prop = field.name;
    return t.ifStatement(wrapOptional(prop, t.binaryExpression('!==', t.memberExpression(t.identifier('message'), t.identifier(field.name)), (0, _types3.getDefaultTSTypeFromProtoType)(context, field, isOneOf)), isOptional), scalarType(num, prop, 'int32'));
  },

  /*
  if (message.queryData.length !== 0) {
  writer.uint32(18).bytes(message.queryData);
  }
  */
  bytes: function bytes(num, prop, isOptional) {
    return t.ifStatement(wrapOptional(prop, lengthNotZero(prop), isOptional), scalarType(num, prop, 'bytes'));
  },
  // if (message.periodReset !== undefined) {
  //     Timestamp.encode(toTimestamp(message.periodReset), writer.uint32(18).fork()).ldelim();
  //   }  
  timestamp: function timestamp(num, prop) {
    return ifNotUndefined(prop, t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('Timestamp'), t.identifier('encode')), [t.memberExpression(t.identifier('message'), t.identifier(prop)), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('fork')), [])]), t.identifier('ldelim')), [])));
  },
  timestampDate: function timestampDate(num, prop) {
    return ifNotUndefined(prop, t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('Timestamp'), t.identifier('encode')), [t.callExpression(t.identifier('toTimestamp'), [t.memberExpression(t.identifier('message'), t.identifier(prop))]), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('fork')), [])]), t.identifier('ldelim')), [])));
  },
  // if (message.period !== undefined) {
  //     Duration.encode(toDuration(message.period), writer.uint32(18).fork()).ldelim();
  //   }
  duration: function duration(num, prop) {
    return t.ifStatement(notUndefined(prop), t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('Duration'), t.identifier('encode')), [t.callExpression(t.identifier('toDuration'), [t.memberExpression(t.identifier('message'), t.identifier(prop))]), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('fork')), [])]), t.identifier('ldelim')), []))]));
  },

  /*
  writer.uint32(10).fork();
   for (const v of message.codeIds) {
      writer.uint64(v);
  }
   writer.ldelim();
  */
  forkDelimArray: function forkDelimArray(num, prop, expr) {
    return [t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('fork')), [])), t.forOfStatement(t.variableDeclaration('const', [t.variableDeclarator(t.identifier('v'), null)]), t.memberExpression(t.identifier('message'), t.identifier(prop)), t.blockStatement([expr])), t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('ldelim')), []))];
  },
  array: function array(num, prop, expr) {
    return [t.forOfStatement(t.variableDeclaration('const', [t.variableDeclarator(t.identifier('v'), null)]), t.memberExpression(t.identifier('message'), t.identifier(prop)), t.blockStatement([expr]))];
  },
  typeArray: function typeArray(num, prop, name) {
    return [t.forOfStatement(t.variableDeclaration('const', [t.variableDeclarator(t.identifier('v'), null)]), t.memberExpression(t.identifier('message'), t.identifier(prop)), t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier(name), t.identifier('encode')), [// "v!" just means it's NOT NULLABLE
    t.tsNonNullExpression(t.identifier('v')), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('fork')), [])]), t.identifier('ldelim')), []))]))];
  },
  // Object.entries(message.labels).forEach(([key, value]) => {
  //     LogEntry_LabelsEntry.encode({
  //       key: (key as any),
  //       value
  //     }, writer.uint32(106).fork()).ldelim();
  //   });
  keyHash: function keyHash(num, prop, name) {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('entries')), [t.memberExpression(t.identifier('message'), t.identifier(prop))]), t.identifier('forEach')), [t.arrowFunctionExpression([t.arrayPattern([t.identifier('key'), t.identifier('value')])], t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier((0, _.getKeyTypeEntryName)(name, prop)), t.identifier('encode')), [t.objectExpression([t.objectProperty(t.identifier('key'), t.tsAsExpression(t.identifier('key'), t.tsAnyKeyword())), t.objectProperty(t.identifier('value'), t.identifier('value'), false, true)]), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('fork')), [])]), t.identifier('ldelim')), []))]))]));
  }
};
exports.types = types;
var arrayTypes = {
  "double": function double() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('double')), [t.identifier('v')]));
  },
  bool: function bool() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('bool')), [t.identifier('v')]));
  },
  "float": function float() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('float')), [t.identifier('v')]));
  },
  int32: function int32() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('int32')), [t.identifier('v')]));
  },
  sint32: function sint32() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('sint32')), [t.identifier('v')]));
  },
  uint32: function uint32() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.identifier('v')]));
  },
  fixed32: function fixed32() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('fixed32')), [t.identifier('v')]));
  },
  sfixed32: function sfixed32() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('sfixed32')), [t.identifier('v')]));
  },
  int64: function int64() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('int64')), [t.identifier('v')]));
  },
  sint64: function sint64() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('sint64')), [t.identifier('v')]));
  },
  uint64: function uint64() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint64')), [t.identifier('v')]));
  },
  fixed64: function fixed64() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('fixed64')), [t.identifier('v')]));
  },
  sfixed64: function sfixed64() {
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('sfixed64')), [t.identifier('v')]));
  },
  string: function string(args) {
    var num = (0, _types2.getTagNumber)(args.field);
    return t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('string')), [t.tsNonNullExpression(t.identifier('v'))]));
  },
  bytes: function bytes(args) {
    var num = (0, _types2.getTagNumber)(args.field);
    return t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('writer'), t.identifier('uint32')), [t.numericLiteral(num)]), t.identifier('bytes')), [t.tsNonNullExpression(t.identifier('v'))]));
  },
  "enum": function _enum() {
    return arrayTypes.int32();
  }
};
exports.arrayTypes = arrayTypes;