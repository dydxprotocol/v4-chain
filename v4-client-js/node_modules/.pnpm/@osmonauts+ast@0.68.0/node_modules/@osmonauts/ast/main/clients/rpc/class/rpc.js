"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRpcClassName = exports.createRpcInterface = exports.createRpcClientInterface = exports.createRpcClientClass = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../../../utils");

var _utils2 = require("@osmonauts/utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var cleanType = function cleanType(ResponseType) {
  // MARKED AS NOT DRY [google.protobuf names]
  // TODO some have google.protobuf.Any shows up... figure out the better way to handle this
  if (/\./.test(ResponseType)) {
    ResponseType = ResponseType.split('.')[ResponseType.split('.').length - 1];
  }

  return ResponseType;
};

var returnReponseType = function returnReponseType(ResponseType) {
  ResponseType = cleanType(ResponseType);
  return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(ResponseType) // t.identifier(ResponseType + 'SDKType')
  )])));
};

var rpcMethodDefinition = function rpcMethodDefinition(name, svc, trailingComments, leadingComments) {
  var _svc$fields;

  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var fieldNames = Object.keys((_svc$fields = svc.fields) !== null && _svc$fields !== void 0 ? _svc$fields : {});
  var hasParams = fieldNames.length > 0;
  var optional = false; // // if no params, then let's default to empty object for cleaner API

  if (!hasParams) {
    optional = true;
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    optional = true;
  }

  var methodArgs = (0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(requestType))), optional);
  return (0, _utils.tsMethodSignature)(t.identifier(name), null, [methodArgs], returnReponseType(responseType), trailingComments, leadingComments);
}; // this.Accounts = this.Accounts.bind(this);
// MARKED AS NOT DRY (used in rpc/lcd)


var bindThis = function bindThis(name) {
  return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier(name)), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(name)), t.identifier('bind')), [t.thisExpression()])));
}; // const data = QueryAccountsRequest.encode(request).finish();


var encodeData = function encodeData(name) {
  return t.variableDeclaration('const', [t.variableDeclarator(t.identifier('data'), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier(name), t.identifier('encode')), [t.identifier('request')]), t.identifier('finish')), []))]);
}; // const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);


var promiseRequest = function promiseRequest(name, packageImportName) {
  name = cleanType(name);
  return t.variableDeclaration('const', [t.variableDeclarator(t.identifier('promise'), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('rpc')), t.identifier('request')), [t.stringLiteral(packageImportName), t.stringLiteral(name), t.identifier('data')]))]);
}; // return promise.then((data) => QueryAccountsResponse.decode(new _m0.Reader(data)));


var returnPromise = function returnPromise(name) {
  name = cleanType(name);
  return t.returnStatement(t.callExpression(t.memberExpression(t.identifier('promise'), t.identifier('then')), [t.arrowFunctionExpression([t.identifier('data')], t.callExpression(t.memberExpression(t.identifier(name), t.identifier('decode')), [t.newExpression(t.memberExpression(t.identifier('_m0'), t.identifier('Reader')), [t.identifier('data')])]))]));
};

var makeComment = function makeComment(comment) {
  return [{
    type: 'CommentBlock',
    value: " ".concat(comment, " ")
  }];
};

var rpcClassMethod = function rpcClassMethod(context, name, msg, svc, packageImport) {
  var _svc$comment, _svc$fields2;

  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var comment = (_svc$comment = svc.comment) !== null && _svc$comment !== void 0 ? _svc$comment : svc.name;
  var methodArgs = (0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(requestType))));
  var fieldNames = Object.keys((_svc$fields2 = svc.fields) !== null && _svc$fields2 !== void 0 ? _svc$fields2 : {});
  var hasParams = fieldNames.length > 0; // if no params, then let's default to empty object for cleaner API

  if (!hasParams) {
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([]));
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([t.objectProperty(t.identifier('pagination'), t.identifier('undefined'), false, false)]));
  }

  var body = t.blockStatement([// const data = QueryAccountsRequest.encode(request).finish();
  encodeData(requestType), // const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);
  promiseRequest(msg, packageImport), // return promise.then((data) => QueryAccountsResponse.decode(new _m0.Reader(data)));                        
  returnPromise(responseType)]);

  if (context.pluginValue('classesUseArrowFunctions')) {
    return (0, _utils.classProperty)(t.identifier(name), (0, _utils.arrowFunctionExpression)([methodArgs], body, returnReponseType(responseType), true), undefined, undefined, undefined, undefined, undefined, undefined, makeComment(comment));
  }

  return (0, _utils.classMethod)('method', t.identifier(name), [methodArgs], body, returnReponseType(responseType));
};

var rpcClassConstructor = function rpcClassConstructor(context, methods) {
  var bound = [];

  if (!context.pluginValue('classesUseArrowFunctions')) {
    bound = methods.map(function (method) {
      return bindThis(method);
    });
  }

  return (0, _utils.classMethod)('constructor', t.identifier('constructor'), [(0, _utils.identifier)('rpc', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Rpc'))))], t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('rpc')), t.identifier('rpc')))].concat((0, _toConsumableArray2["default"])(bound))));
};

var ensureOneSpace = function ensureOneSpace(str) {
  if (/^[\s\n\t]+/.test(str)) return str;
  return " ".concat(str);
};

var ensureOneSpaceEnd = function ensureOneSpaceEnd(str) {
  if (/[\s\n\t]$/.test(str)) return str;
  return "".concat(str, " ");
};

var processRpcComment = function processRpcComment(e) {
  var comment = e.comment;
  if (!comment) return '';

  if (!/[\n]+/.test(comment)) {
    return "*".concat(ensureOneSpaceEnd(ensureOneSpace((0, _utils.cleanComment)(comment))));
  }

  var lines = comment.split('\n');
  lines = ['*'].concat((0, _toConsumableArray2["default"])(lines), [' ']);
  var comments = lines.map(function (line, i) {
    if (i == 0) return line;
    if (i == lines.length - 1) return (0, _utils.cleanComment)(line);
    return " *".concat(ensureOneSpace((0, _utils.cleanComment)(line)));
  });
  return comments.join('\n');
};

var createRpcClientInterface = function createRpcClientInterface(context, service) {
  var _service$methods;

  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var keys = Object.keys((_service$methods = service.methods) !== null && _service$methods !== void 0 ? _service$methods : {});
  var methods = keys.map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    var leadingComments = method.comment ? [(0, _utils.commentBlock)(processRpcComment(method))] : [];
    var trailingComments = [];
    return rpcMethodDefinition(name, method, trailingComments, leadingComments);
  });
  var obj = t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(service.name), null, [], t.tsInterfaceBody((0, _toConsumableArray2["default"])(methods))));

  if (service.comment) {
    obj.leadingComments = [(0, _utils.commentBlock)("* ".concat(service.comment, " "))];
  }

  return obj;
};

exports.createRpcClientInterface = createRpcClientInterface;

var getRpcClassName = function getRpcClassName(service) {
  return "".concat(service.name, "ClientImpl");
};

exports.getRpcClassName = getRpcClassName;

var createRpcClientClass = function createRpcClientClass(context, service) {
  var _service$methods2, _service$methods3;

  context.addUtil('Rpc');
  context.addUtil('_m0');
  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var name = getRpcClassName(service);
  var implementsName = service.name;
  var methodNames = Object.keys((_service$methods2 = service.methods) !== null && _service$methods2 !== void 0 ? _service$methods2 : {}).map(function (key) {
    return camelRpcMethods ? (0, _utils2.camel)(key) : key;
  });
  var methods = Object.keys((_service$methods3 = service.methods) !== null && _service$methods3 !== void 0 ? _service$methods3 : {}).map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    return rpcClassMethod(context, name, key, method, context.ref.proto["package"] + '.' + service.name);
  });
  return t.exportNamedDeclaration((0, _utils.classDeclaration)(t.identifier(name), null, t.classBody([(0, _utils.classProperty)(t.identifier('rpc'), null, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Rpc'))), null, false, false, true, 'private'), // CONSTRUCTOR
  rpcClassConstructor(context, methodNames)].concat((0, _toConsumableArray2["default"])(methods))), null, [t.tsExpressionWithTypeArguments(t.identifier(implementsName))]));
};

exports.createRpcClientClass = createRpcClientClass;

var createRpcInterface = function createRpcInterface(context, service) {
  return t.tsInterfaceDeclaration(t.identifier('Rpc'), null, [], t.tsInterfaceBody([t.tsMethodSignature(t.identifier('request'), null, [(0, _utils.identifier)('service', t.tsTypeAnnotation(t.tsStringKeyword())), (0, _utils.identifier)('method', t.tsTypeAnnotation(t.tsStringKeyword())), (0, _utils.identifier)('data', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Uint8Array'))))], t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier('Uint8Array'))]))))]));
};

exports.createRpcInterface = createRpcInterface;