"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromPartial = exports.arrayTypes = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../../../utils");

var _types2 = require("../../types");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// message.sender = expr
var setField = function setField(prop, expr) {
  return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('message'), t.identifier(prop)), expr));
}; // message.sender = object.sender ?? value;


var setNullishCoalescing = function setNullishCoalescing(prop, value) {
  return setField(prop, t.logicalExpression('??', t.memberExpression(t.identifier('object'), t.identifier(prop)), value));
};

var setNotUndefinedAndNotNull = function setNotUndefinedAndNotNull(prop, value, defaultValue) {
  return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('message'), t.identifier(prop)), t.conditionalExpression(t.logicalExpression('&&', t.binaryExpression('!==', t.memberExpression(t.identifier('object'), t.identifier(prop)), t.identifier('undefined')), t.binaryExpression('!==', t.memberExpression(t.identifier('object'), t.identifier(prop)), t.nullLiteral())), value, defaultValue)));
};

var fromPartial = {
  // message.sender = object.sender ?? "";
  string: function string(args) {
    var prop = args.field.name;
    return setNullishCoalescing(prop, (0, _types2.getDefaultTSTypeFromProtoType)(args.context, args.field, args.isOneOf));
  },
  // message.disableMacros = object.disableMacros ?? false;
  bool: function bool(args) {
    var prop = args.field.name;
    return setNullishCoalescing(prop, (0, _types2.getDefaultTSTypeFromProtoType)(args.context, args.field, args.isOneOf));
  },
  // message.doubleValue = object.doubleValue ?? 0;
  number: function number(args) {
    var prop = args.field.name;
    return setNullishCoalescing(prop, (0, _types2.getDefaultTSTypeFromProtoType)(args.context, args.field, args.isOneOf));
  },
  int32: function int32(args) {
    return fromPartial.number(args);
  },
  uint32: function uint32(args) {
    return fromPartial.number(args);
  },
  sint32: function sint32(args) {
    return fromPartial.number(args);
  },
  fixed32: function fixed32(args) {
    return fromPartial.number(args);
  },
  sfixed32: function sfixed32(args) {
    return fromPartial.number(args);
  },
  "double": function double(args) {
    return fromPartial.number(args);
  },
  "float": function float(args) {
    return fromPartial.number(args);
  },
  // message.myInt64Value = object.myInt64Value !== undefined && object.myInt64Value !== null ? Long.fromValue(object.myInt64Value) : Long.ZERO;
  "long": function long(args) {
    var prop = args.field.name;
    return setNotUndefinedAndNotNull(prop, t.callExpression(t.memberExpression(t.identifier('Long'), t.identifier('fromValue')), [t.memberExpression(t.identifier('object'), t.identifier(prop))]), (0, _types2.getDefaultTSTypeFromProtoType)(args.context, args.field, args.isOneOf));
  },
  int64: function int64(args) {
    return fromPartial["long"](args);
  },
  uint64: function uint64(args) {
    return fromPartial["long"](args);
  },
  sint64: function sint64(args) {
    return fromPartial["long"](args);
  },
  fixed64: function fixed64(args) {
    return fromPartial["long"](args);
  },
  sfixed64: function sfixed64(args) {
    return fromPartial["long"](args);
  },
  // message.signDoc = object.signDoc !== undefined && object.signDoc !== null ? SignDocDirectAux.fromPartial(object.signDoc) : undefined;
  type: function type(args) {
    var prop = args.field.name;
    var name = args.context.getTypeName(args.field);
    return setNotUndefinedAndNotNull(prop, t.callExpression(t.memberExpression(t.identifier(name), t.identifier('fromPartial')), [t.memberExpression(t.identifier('object'), t.identifier(prop))]), t.identifier('undefined'));
  },
  // message.mode = object.mode ?? 0;
  "enum": function _enum(args) {
    var prop = args.field.name;
    return setNullishCoalescing(prop, (0, _types2.getDefaultTSTypeFromProtoType)(args.context, args.field, args.isOneOf));
  },
  // message.queryData = object.queryData ?? new Uint8Array()
  bytes: function bytes(args) {
    var prop = args.field.name;
    return setNullishCoalescing(prop, (0, _types2.getDefaultTSTypeFromProtoType)(args.context, args.field, args.isOneOf));
  },
  // message.period = object.period ?? undefined;
  duration: function duration(args) {
    var durationFormat = args.context.pluginValue('prototypes.typingsFormat.duration');

    switch (durationFormat) {
      case 'string':
        return fromPartial.durationString(args);

      case 'duration':
      default:
        return fromPartial.type(args);
    }
  },
  durationString: function durationString(args) {
    var prop = args.field.name;
    return setNullishCoalescing(prop, t.identifier('undefined'));
  },
  timestamp: function timestamp(args) {
    var timestampFormat = args.context.pluginValue('prototypes.typingsFormat.timestamp');

    switch (timestampFormat) {
      case 'timestamp':
        return fromPartial.type(args);

      case 'date':
      default:
        return fromPartial.timestampDate(args);
    }
  },
  // message.periodReset = object.periodReset ?? undefined;
  timestampDate: function timestampDate(args) {
    var prop = args.field.name;
    return setNullishCoalescing(prop, t.identifier('undefined'));
  },
  // message.referenceMap = Object.entries(object.referenceMap ?? {}).reduce<{
  //     [key: Long]: Reference;
  //   }>((acc, [key, value]) => {
  //     if (value !== undefined) {
  //       acc[Number(key)] = Reference.fromPartial(value);
  //     }
  //     return acc;
  //   }, {});
  // message.labels = Object.entries(object.typeMap ?? {}).reduce<{
  //     [key: string]: string;
  // }>((acc, [key, value]) => {
  //     if (value !== undefined) {
  //         acc[key] = String(value);
  //     }
  //     return acc;
  // }, {});
  keyHash: function keyHash(args) {
    var prop = args.field.name;
    var keyType = args.field.keyType;
    var valueType = args.field.parsedType.name;
    var fromPartial = null; // valueTypeType: string for identifier

    var valueTypeType = valueType;

    switch (valueType) {
      case 'string':
        fromPartial = t.identifier('String');
        break;

      case 'int32':
      case 'uint32':
        valueTypeType = 'number';
        fromPartial = t.identifier('Number');
        break;

      case 'int64':
      case 'uint64':
        valueTypeType = 'Long';
        fromPartial = t.memberExpression(t.identifier('Long'), t.identifier('fromValue'));
        break;

      default:
        fromPartial = t.memberExpression(t.identifier(valueType), t.identifier('fromPartial'));
    }

    var wrapKey = null;
    var keyTypeType = null;

    switch (keyType) {
      case 'string':
        wrapKey = function wrapKey(a) {
          return a;
        };

        keyTypeType = t.tsStringKeyword();
        break;

      case 'int64':
      case 'uint64':
        wrapKey = function wrapKey(a) {
          return t.callExpression(t.identifier('Number'), [a]);
        };

        keyTypeType = t.tsTypeReference(t.identifier('Long'));
        break;

      case 'int32':
      case 'uint32':
        wrapKey = function wrapKey(a) {
          return t.callExpression(t.identifier('Number'), [a]);
        };

        keyTypeType = t.tsNumberKeyword();
        break;

      default:
        throw new Error('keyHash requires new type. Ask maintainers.');
    }

    return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('message'), t.identifier(prop)), (0, _utils.callExpression)(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('entries')), [t.logicalExpression('??', t.memberExpression(t.identifier('object'), t.identifier(prop)), t.objectExpression([]))]), t.identifier('reduce')), [t.arrowFunctionExpression([t.identifier('acc'), t.arrayPattern([t.identifier('key'), t.identifier('value')])], t.blockStatement([t.ifStatement(t.binaryExpression('!==', t.identifier('value'), t.identifier('undefined')), t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('acc'), wrapKey(t.identifier('key')), true), t.callExpression(fromPartial, [t.identifier('value')])))])), t.returnStatement(t.identifier('acc'))])), t.objectExpression([])], t.tsTypeParameterInstantiation([t.tsTypeLiteral([t.tsIndexSignature([(0, _utils.identifier)('key', t.tsTypeAnnotation(keyTypeType))], t.tsTypeAnnotation(t.tsTypeReference(t.identifier(valueTypeType))))])]))));
  },
  // message.codeIds = object.codeIds?.map(e => Long.fromValue(e)) || [];
  array: function array(args, expr) {
    var prop = args.field.name;
    return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('message'), t.identifier(prop)), t.logicalExpression('||', t.optionalCallExpression(t.optionalMemberExpression(t.memberExpression(t.identifier('object'), t.identifier(prop)), t.identifier('map'), false, true), [t.arrowFunctionExpression([t.identifier('e')], expr)], false), t.arrayExpression([]))));
  }
};
exports.fromPartial = fromPartial;
var arrayTypes = {
  // message.overloadId = object.overloadId?.map(e => e) || [];
  identity: function identity() {
    return t.identifier('e');
  },
  string: function string() {
    return arrayTypes.identity();
  },
  bool: function bool() {
    return arrayTypes.identity();
  },
  bytes: function bytes() {
    return arrayTypes.identity();
  },
  "double": function double() {
    return arrayTypes.identity();
  },
  "float": function float() {
    return arrayTypes.identity();
  },
  int32: function int32() {
    return arrayTypes.identity();
  },
  uint32: function uint32() {
    return arrayTypes.identity();
  },
  sint32: function sint32() {
    return arrayTypes.identity();
  },
  fixed32: function fixed32() {
    return arrayTypes.identity();
  },
  sfixed32: function sfixed32() {
    return arrayTypes.identity();
  },
  "enum": function _enum() {
    return arrayTypes.identity();
  },
  // message.codeIds = object.codeIds?.map(e => Long.fromValue(e)) || [];
  "long": function long() {
    return t.callExpression(t.memberExpression(t.identifier('Long'), t.identifier('fromValue')), [t.identifier('e')]);
  },
  int64: function int64() {
    return arrayTypes["long"]();
  },
  uint64: function uint64() {
    return arrayTypes["long"]();
  },
  sint64: function sint64() {
    return arrayTypes["long"]();
  },
  fixed64: function fixed64() {
    return arrayTypes["long"]();
  },
  sfixed64: function sfixed64() {
    return arrayTypes["long"]();
  },
  // message.tokenInMaxs = object.tokenInMaxs?.map(e => Coin.fromPartial(e)) || [];
  type: function type(args) {
    var name = args.context.getTypeName(args.field);
    return t.callExpression(t.memberExpression(t.identifier(name), t.identifier('fromPartial')), [t.identifier('e')]);
  }
};
exports.arrayTypes = arrayTypes;