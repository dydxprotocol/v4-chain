"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toAminoParseField = exports.toAminoJsonMethod = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../../../utils");

var _utils2 = require("../utils");

var _utils3 = require("./utils");

var _proto = require("../../proto");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var needsImplementation = function needsImplementation(name, field) {
  throw new Error("need to implement toAmino (".concat(field.type, " rules[").concat(field.rule, "] name[").concat(name, "])"));
};

var warningDefaultImplementation = function warningDefaultImplementation(name, field) {
  console.warn("need to implement toAmino (".concat(field.type, " rules[").concat(field.rule, "] name[").concat(name, "])"));
};

;

var toAminoParseField = function toAminoParseField(_ref) {
  var _field$options;

  var context = _ref.context,
      field = _ref.field,
      currentProtoPath = _ref.currentProtoPath,
      previousScope = _ref.scope,
      previousFieldPath = _ref.fieldPath,
      nested = _ref.nested,
      isOptional = _ref.isOptional;
  var scope = [field.name].concat((0, _toConsumableArray2["default"])(previousScope));
  var fieldPath = [field].concat((0, _toConsumableArray2["default"])(previousFieldPath));
  var args = {
    context: context,
    field: field,
    currentProtoPath: currentProtoPath,
    scope: scope,
    fieldPath: fieldPath,
    nested: nested,
    isOptional: isOptional
  }; // arrays

  if (field.rule === 'repeated') {
    switch (field.type) {
      case 'string':
        return _utils3.toAmino.string(args);

      case 'int64':
      case 'sint64':
      case 'uint64':
      case 'fixed64':
      case 'sfixed64':
        return _utils3.toAmino.scalarArray(args, _utils3.arrayTypes["long"]);

      case 'double':
      case 'float':
      case 'int32':
      case 'sint32':
      case 'uint32':
      case 'fixed32':
      case 'sfixed32':
      case 'bool':
      case 'bytes':
        return _utils3.toAmino.defaultType(args);

      case 'string':
        return _utils3.toAmino.string(args);
    }

    switch (field.parsedType.type) {
      case 'Type':
        return _utils3.toAmino.typeArray(args);
    }

    return needsImplementation(field.name, field);
  } // casting Any types


  if (field.type === 'google.protobuf.Any') {
    switch ((_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options['(cosmos_proto.accepts_interface)']) {
      case 'cosmos.crypto.PubKey':
        return _utils3.toAmino.pubkey(args);
    }
  } // special types...


  switch (field.type) {
    case 'Timestamp':
    case 'google.protobuf.Timestamp':
      return _utils3.toAmino.defaultType(args);

    case 'cosmos.base.v1beta1.Coin':
      return _utils3.toAmino.coin(args);
    // TODO check can we just
    // make pieces optional and avoid hard-coding this type?

    case 'ibc.core.client.v1.Height':
    case 'Height':
      return _utils3.toAmino.height(args);

    case 'Duration':
    case 'google.protobuf.Duration':
      return _utils3.toAmino.duration(args);

    default:
  } // Types/Enums


  switch (field.parsedType.type) {
    case 'Enum':
      return _utils3.toAmino.defaultType(args);

    case 'Type':
      return _utils3.toAmino.type(args);
  }

  if (field.type === 'bytes') {
    var _field$options2, _field$options3;

    // bytes [RawContractMessage]
    if (((_field$options2 = field.options) === null || _field$options2 === void 0 ? void 0 : _field$options2['(gogoproto.casttype)']) === 'RawContractMessage') {
      return _utils3.toAmino.rawBytes(args);
    } // bytes [WASMByteCode]
    // TODO use a better option for this in proto source


    if (((_field$options3 = field.options) === null || _field$options3 === void 0 ? void 0 : _field$options3['(gogoproto.customname)']) === 'WASMByteCode') {
      return _utils3.toAmino.wasmByteCode(args);
    }
  } // scalar types...


  switch (field.type) {
    case 'string':
      return _utils3.toAmino.string(args);

    case 'int64':
    case 'sint64':
    case 'uint64':
    case 'fixed64':
    case 'sfixed64':
      return _utils3.toAmino["long"](args);

    case 'double':
    case 'float':
    case 'int32':
    case 'sint32':
    case 'uint32':
    case 'fixed32':
    case 'sfixed32':
    case 'bool':
    case 'bytes':
      return _utils3.toAmino.defaultType(args);

    default:
      warningDefaultImplementation(field.name, field);
      return _utils3.toAmino.defaultType(args);
  }
};

exports.toAminoParseField = toAminoParseField;

var toAminoJsonMethod = function toAminoJsonMethod(_ref2) {
  var context = _ref2.context,
      proto = _ref2.proto;
  var toAminoParams = t.objectPattern((0, _utils2.protoFieldsToArray)(proto).map(function (field) {
    return t.objectProperty(t.identifier(field.name), t.identifier(field.name), false, true);
  }));
  toAminoParams.typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier(proto.name)));
  var oneOfs = (0, _proto.getOneOfs)(proto);
  var fields = (0, _utils2.protoFieldsToArray)(proto).map(function (field) {
    var isOneOf = oneOfs.includes(field.name);
    var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
    var aminoField = toAminoParseField({
      context: context,
      field: field,
      currentProtoPath: context.ref.filename,
      scope: [],
      fieldPath: [],
      nested: 0,
      isOptional: isOptional
    });
    return {
      ctx: context,
      field: aminoField
    };
  }); // const ctxs = fields.map(({ ctx }) => ctx);
  // ctxs.forEach(ctx => {
  //     // console.log('imports, ', ctx)
  // })

  return (0, _utils.arrowFunctionExpression)([toAminoParams], t.blockStatement([t.returnStatement(t.objectExpression(fields.map(function (_ref3) {
    var field = _ref3.field;
    return field;
  })))]), t.tsTypeAnnotation(t.tsIndexedAccessType(t.tsTypeReference(t.identifier('Amino' + proto.name)), t.tsLiteralType(t.stringLiteral('value')))));
};

exports.toAminoJsonMethod = toAminoJsonMethod;