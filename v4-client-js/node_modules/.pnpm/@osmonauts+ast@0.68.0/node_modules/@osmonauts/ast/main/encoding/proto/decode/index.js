"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeMethodFields = exports.decodeMethod = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var t = _interopRequireWildcard(require("@babel/types"));

var _ = require("..");

var _utils = require("../../../utils");

var _types2 = require("../types");

var _utils2 = require("./utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var needsImplementation = function needsImplementation(name, field) {
  throw new Error("need to implement decode (".concat(field.type, " rules[").concat(field.rule, "] name[").concat(name, "])"));
};

var decodeMethodFields = function decodeMethodFields(context, name, proto) {
  var _proto$fields;

  var oneOfs = (0, _.getOneOfs)(proto);
  return Object.keys((_proto$fields = proto.fields) !== null && _proto$fields !== void 0 ? _proto$fields : {}).map(function (fieldName) {
    var field = _objectSpread({
      name: fieldName
    }, proto.fields[fieldName]);

    var isOneOf = oneOfs.includes(fieldName);
    var isOptional = (0, _.getFieldOptionality)(context, field, isOneOf);
    var args = {
      typeName: name,
      context: context,
      field: field,
      isOptional: isOptional
    };

    if (field.rule === 'repeated') {
      switch (field.type) {
        case 'string':
          return _utils2.decode.array(args, _utils2.baseTypes.string(args));

        case 'bytes':
          return _utils2.decode.array(args, _utils2.baseTypes.bytes(args));

        case 'double':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes["double"](args));

        case 'bool':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.bool(args));

        case 'float':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes["float"](args));

        case 'int32':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.int32(args));

        case 'sint32':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.sint32(args));

        case 'uint32':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.uint32(args));

        case 'fixed32':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.fixed32(args));

        case 'sfixed32':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.sfixed32(args));

        case 'int64':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.int64(args));

        case 'sint64':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.sint64(args));

        case 'uint64':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.uint64(args));

        case 'fixed64':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.fixed64(args));

        case 'sfixed64':
          return _utils2.decode.tagDelimArray(args, _utils2.baseTypes.sfixed64(args));

        default:
          switch (field.parsedType.type) {
            case 'Enum':
              return _utils2.decode.tagDelimArray(args, _utils2.baseTypes["enum"](args));

            case 'Type':
              return _utils2.decode.typeArray(args);
          }

          return needsImplementation(fieldName, field);
      }
    }

    if (field.keyType) {
      // currently they all look the same for decode()
      return _utils2.decode.keyHash(args);
    }

    switch (field.type) {
      case 'string':
        return _utils2.decode.string(args);

      case 'int32':
        return _utils2.decode.int32(args);

      case 'sint32':
        return _utils2.decode.sint32(args);

      case 'uint32':
        return _utils2.decode.uint32(args);

      case 'fixed32':
        return _utils2.decode.fixed32(args);

      case 'sfixed32':
        return _utils2.decode.sfixed32(args);

      case 'int64':
        return _utils2.decode.int64(args);

      case 'sint64':
        return _utils2.decode.sint64(args);

      case 'uint64':
        return _utils2.decode.uint64(args);

      case 'fixed64':
        return _utils2.decode.fixed64(args);

      case 'sfixed64':
        return _utils2.decode.sfixed64(args);

      case 'double':
        return _utils2.decode["double"](args);

      case 'float':
        return _utils2.decode["float"](args);

      case 'bytes':
        return _utils2.decode.bytes(args);

      case 'bool':
        return _utils2.decode.bool(args);

      case 'google.protobuf.Duration':
      case 'Duration':
        return _utils2.decode.duration(args);

      case 'google.protobuf.Timestamp':
      case 'Timestamp':
        return _utils2.decode.timestamp(args);

      default:
        switch (field.parsedType.type) {
          case 'Enum':
            return _utils2.decode["enum"](args);

          case 'Type':
            return _utils2.decode.type(args);
        }

        return needsImplementation(fieldName, field);
    }
  });
};

exports.decodeMethodFields = decodeMethodFields;

var decodeMethod = function decodeMethod(context, name, proto) {
  context.addUtil('_m0');
  var returnType = name; // decode can be coupled to API requests

  if (context.store.responses[name]) {
    // returnType = name + 'SDKType';
    returnType = name;
  }

  return (0, _utils.objectMethod)('method', t.identifier('decode'), [(0, _utils.identifier)('input', t.tsTypeAnnotation(t.tsUnionType([t.tsTypeReference(t.tsQualifiedName(t.identifier('_m0'), t.identifier('Reader')), null), t.tsTypeReference(t.identifier('Uint8Array'))])), false), (0, _utils.identifier)('length', t.tsTypeAnnotation(t.tsNumberKeyword()), true)], t.blockStatement([
  /*
  const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
  */
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('reader'), t.conditionalExpression(t.binaryExpression('instanceof', t.identifier('input'), t.memberExpression(t.identifier('_m0'), t.identifier('Reader'))), t.identifier('input'), t.newExpression(t.memberExpression(t.identifier('_m0'), t.identifier('Reader')), [t.identifier('input')])))]),
  /*
  let end = length === undefined ? reader.len : reader.pos + length;
  */
  t.variableDeclaration('let', [t.variableDeclarator(t.identifier('end'), t.conditionalExpression(t.binaryExpression('===', t.identifier('length'), t.identifier('undefined')), t.memberExpression(t.identifier('reader'), t.identifier('len')), t.binaryExpression('+', t.memberExpression(t.identifier('reader'), t.identifier('pos')), t.identifier('length'))))]),
  /*
  
  const message = createBaseMsgJoinPool();
   */
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('message'), t.callExpression( // 
  t.identifier((0, _types2.getBaseCreateTypeFuncName)(name)), []))]), ///////////
  ///////////
  ///////////
  t.whileStatement(t.binaryExpression('<', t.memberExpression(t.identifier('reader'), t.identifier('pos')), t.identifier('end')), t.blockStatement([/// DECODE BODY
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('tag'), t.callExpression(t.memberExpression(t.identifier('reader'), t.identifier('uint32')), []))]), t.switchStatement(t.binaryExpression('>>>', t.identifier('tag'), t.numericLiteral(3)), [].concat((0, _toConsumableArray2["default"])(decodeMethodFields(context, name, proto)), [
  /*
  default:
          reader.skipType(tag & 7);
          break;
  */
  t.switchCase(null, [t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('reader'), t.identifier('skipType')), [t.binaryExpression('&', t.identifier('tag'), t.numericLiteral(7))])), t.breakStatement()])]))])), // RETURN STATEMENT
  t.returnStatement(t.identifier('message'))]), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(returnType))));
};

exports.decodeMethod = decodeMethod;