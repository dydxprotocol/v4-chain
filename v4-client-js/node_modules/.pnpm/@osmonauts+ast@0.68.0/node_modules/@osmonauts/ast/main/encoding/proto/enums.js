"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProtoEnumToJSON = exports.createProtoEnumFromJSON = exports.createProtoEnum = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _types2 = require("./types");

var _utils = require("../../utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var getEnumValues = function getEnumValues(proto) {
  var enums = Object.keys(proto.values).map(function (key) {
    var e = {
      name: key,
      comment: null,
      value: null
    };
    e.value = proto.values[key];

    if (proto.comments[key]) {
      e.comment = proto.comments[key];
    }

    return e;
  });
  return enums;
};

var ensureOneSpace = function ensureOneSpace(str) {
  if (/^[\s\n\t]+/.test(str)) return str;
  return " ".concat(str);
};

var processEnumComment = function processEnumComment(e) {
  var comment = e.comment;

  if (!/[\n]+/.test(comment)) {
    return "* ".concat(e.name, " - ").concat(comment, " ");
  }

  var lines = comment.split('\n');
  lines = ['*'].concat((0, _toConsumableArray2["default"])(lines), [' ']);
  var comments = lines.map(function (line, i) {
    if (i == 0) return line;
    if (i == 1) return " * ".concat(e.name, " - ").concat((0, _utils.cleanComment)(line));
    if (i == lines.length - 1) return (0, _utils.cleanComment)(line);
    return " *".concat(ensureOneSpace((0, _utils.cleanComment)(line)));
  });
  return comments.join('\n');
};

var createProtoEnum = function createProtoEnum(context, name, proto) {
  var enums = getEnumValues(proto);
  var values = enums.map(function (e) {
    return (0, _utils.tsEnumMember)(t.identifier(e.name), t.numericLiteral(e.value), e.comment ? [{
      type: 'CommentBlock',
      value: processEnumComment(e)
    }] : []);
  });
  var declaration = t.exportNamedDeclaration(t.tsEnumDeclaration(t.identifier(name), [].concat((0, _toConsumableArray2["default"])(values), [// default
  (0, _utils.tsEnumMember)(t.identifier('UNRECOGNIZED'), t.unaryExpression('-', t.numericLiteral(1)), null)])));

  if (proto.comment) {
    declaration.leadingComments = [(0, _utils.makeCommentBlock)(proto.comment)];
  }

  return declaration;
};

exports.createProtoEnum = createProtoEnum;

var createProtoEnumFromJSON = function createProtoEnumFromJSON(context, name, proto) {
  var enums = getEnumValues(proto);
  var switches = enums.reduce(function (m, e) {
    m.push(t.switchCase(t.numericLiteral(e.value), []));
    m.push(t.switchCase(t.stringLiteral(e.name), [t.returnStatement(t.memberExpression(t.identifier(name), t.identifier(e.name)))]));
    return m;
  }, []);
  var unrecognizedEnums = [t.switchCase(t.stringLiteral('UNRECOGNIZED'), [])];
  return t.exportNamedDeclaration((0, _utils.functionDeclaration)(t.identifier((0, _types2.getEnumFromJsonName)(name)), [(0, _utils.identifier)('object', t.tsTypeAnnotation(t.tsAnyKeyword()))], t.blockStatement([t.switchStatement(t.identifier('object'), [].concat((0, _toConsumableArray2["default"])(switches), [// default
  t.switchCase(t.unaryExpression('-', t.numericLiteral(1)), [])], unrecognizedEnums, [t.switchCase(null, [t.returnStatement(t.memberExpression(t.identifier(name), t.identifier('UNRECOGNIZED')))])]))]), false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name)))));
};

exports.createProtoEnumFromJSON = createProtoEnumFromJSON;

var createProtoEnumToJSON = function createProtoEnumToJSON(context, name, proto) {
  var enums = getEnumValues(proto);
  var switches = enums.map(function (e) {
    return t.switchCase(t.memberExpression(t.identifier(name), t.identifier(e.name)), [t.returnStatement(t.stringLiteral(e.name))]);
  });
  var unrecognizedEnums = [t.switchCase(t.memberExpression(t.identifier(name), t.identifier('UNRECOGNIZED')), [])];
  return t.exportNamedDeclaration((0, _utils.functionDeclaration)(t.identifier((0, _types2.getEnumToJsonName)(name)), [(0, _utils.identifier)('object', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name))))], t.blockStatement([t.switchStatement(t.identifier('object'), [].concat((0, _toConsumableArray2["default"])(switches), unrecognizedEnums, [// default
  t.switchCase(null, [t.returnStatement(t.stringLiteral('UNRECOGNIZED'))])]))]), false, false, t.tsTypeAnnotation(t.tsStringKeyword())));
};

exports.createProtoEnumToJSON = createProtoEnumToJSON;