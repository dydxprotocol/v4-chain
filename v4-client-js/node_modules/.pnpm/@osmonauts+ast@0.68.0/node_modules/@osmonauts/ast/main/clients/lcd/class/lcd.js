"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTemplateTagLegacy = exports.makeTemplateTag = exports.getUrlTemplateString = exports.createLCDClient = exports.createAggregatedLCDClient = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../../../utils");

var _parser = require("@babel/parser");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// this is the ONLY time ast uses babel/parser
var getAstFromString = function getAstFromString(str) {
  var plugins = ['objectRestSpread', 'classProperties', 'optionalCatchBinding', 'asyncGenerators', 'decorators-legacy', 'typescript', 'dynamicImport'];
  var ast = (0, _parser.parse)(str, {
    sourceType: 'module',
    // @ts-ignore
    plugins: plugins
  });
  return ast;
};

var getResponseTypeName = function getResponseTypeName(context, name) {
  return name + (context.options.useSDKTypes ? 'SDKType' : '');
};

var returnReponseType = function returnReponseType(context, name) {
  return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, name)))])));
};

var firstLower = function firstLower(s) {
  return s = s.charAt(0).toLowerCase() + s.slice(1);
};

var firstUpper = function firstUpper(s) {
  return s = s.charAt(0).toUpperCase() + s.slice(1);
};

var returnAwaitRequest = function returnAwaitRequest(context, responseType) {
  var hasOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var args = [t.identifier('endpoint')]; // if (method === 'post') {
  //     args.push(t.identifier('body'));
  // }

  if (hasOptions) {
    args.push(t.identifier('options'));
  }

  return t.returnStatement(t.awaitExpression((0, _utils.callExpression)(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('req')), t.identifier('get')), args, t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, responseType)))]))));
};

var makeOptionsObject = function makeOptionsObject() {
  return t.variableDeclaration('const', [t.variableDeclarator((0, _utils.identifier)('options', t.tsTypeAnnotation(t.tsAnyKeyword())), t.objectExpression([t.objectProperty(t.identifier('params'), t.objectExpression([]))]))]);
};

var setParamOption = function setParamOption(context, name, svc) {
  var flippedCasing = Object.keys(svc.info.casing).reduce(function (m, v) {
    m[svc.info.casing[v]] = v;
    return m;
  }, {});
  var queryParam = flippedCasing[name] ? flippedCasing[name] : name;
  var param = svc.info.paramMap[name]; // options.params.group_id = params.groupId;

  var expr = t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.memberExpression(t.identifier('options'), t.identifier('params')), t.identifier(queryParam)), t.memberExpression(t.identifier('params'), t.identifier(param))));

  if (name === 'pagination') {
    context.addUtil('setPaginationParams');
    expr = t.expressionStatement(t.callExpression(t.identifier('setPaginationParams'), [t.identifier('options'), t.memberExpression(t.identifier('params'), t.identifier('pagination'), false)]));
  }

  return t.ifStatement(t.binaryExpression('!==', t.unaryExpression('typeof', t.optionalMemberExpression(t.identifier('params'), t.identifier(param), false, true)), t.stringLiteral('undefined')), t.blockStatement([expr]));
}; // breaks a url string to prepare it for template strings


var getUrlTemplateString = function getUrlTemplateString(url) {
  var parts = url.split('/').filter(function (a) {
    return a !== '';
  });
  var cur = [];
  var strs = [];
  var atEnd = false;

  for (var p = 0; p < parts.length; p++) {
    var part = parts[p];

    if (/[{}]+/.test(part)) {
      if (p === parts.length - 1) atEnd = true;

      if (cur.length) {
        var vals = cur.join('/');
        strs.push(vals);
      } else {
        strs.push('/');
      }

      cur = [];
    } else {
      cur.push(part);
    }
  }

  if (cur.length) {
    strs.push(cur.join('/'));
  }

  strs = strs.filter(function (str) {
    return str !== '';
  }).map(function (v, i) {
    if (i === 0) {
      if (!v.endsWith('/')) v = "".concat(v, "/");
      return v;
    } else if (i === strs.length - 1) {
      if (atEnd) {
        // we want them to end with / if it's an "atEnd" el
        if (!v.endsWith('/')) v = "".concat(v, "/");
        return v;
      } // they should all start with "/"


      if (!v.startsWith('/')) v = "/".concat(v);
      return v;
    }

    if (!v.endsWith('/')) v = "".concat(v, "/");
    if (!v.startsWith('/')) v = "/".concat(v);
    return v;
  });
  return {
    strs: strs,
    atEnd: atEnd
  };
};

exports.getUrlTemplateString = getUrlTemplateString;

var makeTemplateTag = function makeTemplateTag(info) {
  var route = info.url.split('/').filter(function (a) {
    return a !== '';
  }).map(function (a) {
    if (a.startsWith('{')) {
      return "$".concat(a);
    } else {
      return a;
    }
  }).join('/');
  var parsed = getAstFromString("`".concat(route, "`"));
  var ast = parsed.program.body[0].expression;
  ast.expressions = ast.expressions.map(function (identifier) {
    var _info$casing;

    var name = (_info$casing = info.casing) !== null && _info$casing !== void 0 && _info$casing[identifier.name] ? info.casing[identifier.name] : identifier.name;
    return t.memberExpression(t.identifier('params'), t.identifier(name));
  });
  return ast;
}; // do we need to set end prop in ast?
// we may want to t.templateElement!!!


exports.makeTemplateTag = makeTemplateTag;

var makeTemplateTagLegacy = function makeTemplateTagLegacy(info) {
  if (!info.url) throw new Error('no URL on service method');
  var parts = getUrlTemplateString(info.url);
  var templateElts = parts.strs.map(function (raw) {
    return t.templateElement({
      raw: raw
    });
  }); // Number of TemplateLiteral quasis should be exactly one more than the number of expressions

  var pathParams = info.pathParams.map(function (param) {
    var _info$casing2;

    var name = (_info$casing2 = info.casing) !== null && _info$casing2 !== void 0 && _info$casing2[param] ? info.casing[param] : param;
    return t.memberExpression(t.identifier('params'), t.identifier(name));
  });

  if (parts.atEnd) {
    templateElts.push(t.templateElement({
      raw: ''
    }));
  } // THIS MEANS WE PROBABLY HAVE A BUG


  if (templateElts.length !== pathParams.length + 1) {
    templateElts.push(t.templateElement({
      raw: ''
    }));
  }

  templateElts.forEach(function (el, n) {
    if (n === templateElts.length - 1) {
      // remove trailing slash...
      el.value.raw = el.value.raw.replace(/\/$/, '');
    }
  });
  return t.templateLiteral(templateElts, pathParams);
};

exports.makeTemplateTagLegacy = makeTemplateTagLegacy;

var makeComment = function makeComment(comment) {
  return [{
    type: 'CommentBlock',
    value: " ".concat(comment, " ")
  }];
};

var buildRequestMethod = function buildRequestMethod(context, serviceMethod) {
  var _serviceMethod$commen, _serviceMethod$fields, _serviceMethod$fields2;

  var methodName = firstLower(serviceMethod.name);
  var comment = (_serviceMethod$commen = serviceMethod.comment) !== null && _serviceMethod$commen !== void 0 ? _serviceMethod$commen : serviceMethod.name;

  if (!serviceMethod.info) {
    throw new Error('No Service URL!');
  }

  var queryParams = serviceMethod.info.queryParams.map(function (param) {
    return setParamOption(context, param, serviceMethod);
  });
  var optionsAst = [];

  if (serviceMethod.info.queryParams.length) {
    // options params object
    optionsAst.push(makeOptionsObject());
  } // parse field types


  Object.entries((_serviceMethod$fields = serviceMethod.fields) !== null && _serviceMethod$fields !== void 0 ? _serviceMethod$fields : {}).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    switch (value.parsedType.type) {
      case 'Type':
        // this gets the import for us and loads them into ctx
        // if later we need to get subtypes, we have it all w/ctx
        context.getTypeName(value);

      case 'native':
    }
  });
  var fieldNames = Object.keys((_serviceMethod$fields2 = serviceMethod.fields) !== null && _serviceMethod$fields2 !== void 0 ? _serviceMethod$fields2 : {});
  var hasParams = fieldNames.length > 0;
  var paramName = hasParams ? 'params' : '_params';
  var methodArgs = (0, _utils.identifier)(paramName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(serviceMethod.requestType)))); // if no params, then let's default to empty object for cleaner API

  if (!hasParams) {
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([]));
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([t.objectProperty(t.identifier('pagination'), t.identifier('undefined'), false, false)]));
  }

  var body = t.blockStatement([].concat(optionsAst, (0, _toConsumableArray2["default"])(queryParams), [// endpoint
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('endpoint'), makeTemplateTag(serviceMethod.info))]), // return 
  returnAwaitRequest(context, serviceMethod.responseType, // serviceMethod.info.method,
  serviceMethod.info.queryParams.length > 0)]));

  if (context.pluginValue('classesUseArrowFunctions')) {
    return (0, _utils.classProperty)(t.identifier(methodName), (0, _utils.arrowFunctionExpression)([methodArgs], body, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, serviceMethod.responseType)))]))), true), undefined, undefined, undefined, undefined, undefined, undefined, makeComment(comment));
  }

  return (0, _utils.classMethod)('method', t.identifier(methodName), [methodArgs], body, returnReponseType(context, serviceMethod.responseType), makeComment(comment), false, false, false, true // async
  );
}; // MARKED AS NOT DRY (used in rpc/lcd)


var bindThis = function bindThis(name) {
  return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier(name)), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(name)), t.identifier('bind')), [t.thisExpression()])));
};

var createLCDClientClassBody = function createLCDClientClassBody(context, clientName, methods, service) {
  var boundMethods = []; // until the super() issue is figured out, we have to remove this

  if (service && !context.pluginValue('classesUseArrowFunctions')) {
    boundMethods = Object.keys(service.methods).map(function (key) {
      var _method$options;

      var method = service.methods[key];

      if (typeof ((_method$options = method.options) === null || _method$options === void 0 ? void 0 : _method$options['(google.api.http).get']) !== 'undefined') {
        var methodName = firstLower(method.name);
        return bindThis(methodName);
      }
    }).filter(Boolean);
  }

  return t.exportNamedDeclaration(t.classDeclaration(t.identifier(clientName), null, t.classBody([t.classProperty(t.identifier('req'), null, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('LCDClient')))), // constructor
  t.classMethod('constructor', t.identifier('constructor'), [(0, _utils.objectPattern)([t.objectProperty(t.identifier('requestClient'), t.identifier('requestClient'), false, true)], t.tsTypeAnnotation(t.tsTypeLiteral([t.tsPropertySignature(t.identifier('requestClient'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('LCDClient'))))])))], t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('req')), t.identifier('requestClient')))].concat((0, _toConsumableArray2["default"])(boundMethods))))].concat((0, _toConsumableArray2["default"])(methods)))));
};

var createLCDClient = function createLCDClient(context, service) {
  var methods = Object.keys(service.methods).map(function (key) {
    var _method$options2;

    var method = service.methods[key];

    if (method.info && typeof ((_method$options2 = method.options) === null || _method$options2 === void 0 ? void 0 : _method$options2['(google.api.http).get']) !== 'undefined') {
      return buildRequestMethod(context, method);
    }
  }).filter(Boolean);
  context.addUtil('LCDClient');

  if (methods.length) {
    var clientName = 'LCDQueryClient';
    return createLCDClientClassBody(context, clientName, methods, service);
  }
};

exports.createLCDClient = createLCDClient;

var createAggregatedLCDClient = function createAggregatedLCDClient(context, services, clientName) {
  context.addUtil('LCDClient');
  var methods = services.reduce(function (m, service) {
    var innerMethods = Object.keys(service.methods).map(function (key) {
      var method = service.methods[key];
      return buildRequestMethod(context, method);
    });
    return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(innerMethods));
  }, []);
  return createLCDClientClassBody(context, clientName, methods);
};

exports.createAggregatedLCDClient = createAggregatedLCDClient;