"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderAminoField = exports.makeAminoTypeInterface = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../utils");

var _utils2 = require("./utils");

var _proto = require("../../proto");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

;

var renderAminoField = function renderAminoField(_ref) {
  var context = _ref.context,
      field = _ref.field,
      currentProtoPath = _ref.currentProtoPath,
      isOptional = _ref.isOptional;
  var args = {
    context: context,
    field: field,
    currentProtoPath: currentProtoPath,
    isOptional: isOptional
  };

  if (field.rule === 'repeated') {
    switch (field.parsedType.type) {
      case 'Type':
        return _utils2.aminoInterface.typeArray(args);

      case 'Enum':
        return _utils2.aminoInterface.enumArray(args);

      default:
        return _utils2.aminoInterface.array(args);
    }
  } // special "native" types...
  // above Type,Enum since they're Types


  switch (field.type) {
    // TODO check can we just
    // make pieces optional and avoid hard-coding this type?
    case 'ibc.core.client.v1.Height':
    case 'Height':
      return _utils2.aminoInterface.height(args);

    case 'Timestamp':
    case 'google.protobuf.Timestamp':
      return _utils2.aminoInterface.timestamp(args);

    case 'Duration':
    case 'google.protobuf.Duration':
      return _utils2.aminoInterface.duration(args);
  }

  switch (field.parsedType.type) {
    case 'Type':
      return _utils2.aminoInterface.type(args);

    case 'Enum':
      return _utils2.aminoInterface["enum"](args);
  } // scalar types...


  switch (field.type) {
    case 'string':
      return _utils2.aminoInterface.defaultType(args);

    case 'int64':
    case 'sint64':
    case 'uint64':
    case 'fixed64':
    case 'sfixed64':
      return _utils2.aminoInterface["long"](args);

    case 'double':
    case 'bool':
    case 'bytes':
    case 'int32':
    case 'sint32':
    case 'uint32':
    case 'fixed32':
    case 'sfixed32':
      return _utils2.aminoInterface.defaultType(args);
    // // TODO check can we just
    // // make pieces optional and avoid hard-coding this type?
    // case 'ibc.core.client.v1.Height':
    // case 'Height':
    // return aminoInterface.height(args);
    // case 'Timestamp':
    // case 'google.protobuf.Timestamp':
    //     return aminoInterface.timestamp(args);
    // case 'Duration':
    // case 'google.protobuf.Duration':
    //     return aminoInterface.duration(args);

    default:
      return _utils2.aminoInterface.defaultType(args);
  }
};

exports.renderAminoField = renderAminoField;
;

var makeAminoTypeInterface = function makeAminoTypeInterface(_ref2) {
  var context = _ref2.context,
      proto = _ref2.proto;
  context.addUtil('AminoMsg');
  var TypeName = proto.name;
  var typeUrl = (0, _utils.getTypeUrl)(context.ref.proto, proto);
  var aminoType = (0, _utils.typeUrlToAmino)(context, typeUrl);
  var oneOfs = (0, _proto.getOneOfs)(proto);
  var fields = (0, _utils.protoFieldsToArray)(proto).map(function (field) {
    var isOneOf = oneOfs.includes(field.name);
    var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
    var aminoField = renderAminoField({
      context: context,
      field: field,
      currentProtoPath: context.ref.filename,
      isOptional: isOptional
    });
    return {
      ctx: context,
      field: aminoField
    };
  });
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier('Amino' + TypeName), null, [t.tsExpressionWithTypeArguments(t.identifier('AminoMsg'))], t.tSInterfaceBody([t.tSPropertySignature(t.identifier('type'), t.tsTypeAnnotation(t.tSLiteralType(t.stringLiteral(aminoType)))), t.tSPropertySignature(t.identifier('value'), t.tsTypeAnnotation(t.tsTypeLiteral(fields.map(function (_ref3) {
    var field = _ref3.field;
    return field;
  }))))])));
};

exports.makeAminoTypeInterface = makeAminoTypeInterface;