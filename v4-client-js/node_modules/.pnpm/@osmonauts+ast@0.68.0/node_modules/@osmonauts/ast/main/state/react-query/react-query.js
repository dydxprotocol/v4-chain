"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRpcQueryHooks = exports.createRpcQueryHookInterfaces = exports.createRpcQueryHookClientMap = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../../utils");

var _utils2 = require("@osmonauts/utils");

var _case = require("case");

var _weakMap = require("./weak-map");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var makeUseHookName = function makeUseHookName(name) {
  return (0, _utils2.camel)('use_' + name);
};

var makeUseHookTypeName = function makeUseHookTypeName(name) {
  return (0, _case.pascal)('Use_' + name + 'Query');
};

var makeHookKeyName = function makeHookKeyName(name) {
  return (0, _utils2.camel)(name + 'Query');
};

var rpcHookMethod = function rpcHookMethod(context, name, svc) {
  var _svc$fields;

  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var fieldNames = Object.keys((_svc$fields = svc.fields) !== null && _svc$fields !== void 0 ? _svc$fields : {});
  var hasParams = fieldNames.length > 0;
  var optional = false; // // if no params, then let's default to empty object for cleaner API

  if (!hasParams) {
    optional = true;
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    optional = true;
  }

  context.addUtil('useQuery');
  return t.variableDeclaration('const', [t.variableDeclarator(t.identifier(makeUseHookName(name)), (0, _utils.arrowFunctionExpression)([(0, _utils.objectPattern)([t.objectProperty(t.identifier('request'), t.identifier('request'), false, true), t.objectProperty(t.identifier('options'), t.identifier('options'), false, true)], t.tsTypeAnnotation(t.tsTypeReference(t.identifier(makeUseHookTypeName(name)), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier('TData'))]))))], t.blockStatement([t.returnStatement((0, _utils.callExpression)(t.identifier('useQuery'), [t.arrayExpression([t.stringLiteral(makeHookKeyName(name)), t.identifier('request')]), t.arrowFunctionExpression([], t.blockStatement([t.ifStatement(t.unaryExpression('!', t.identifier('queryService'), true), t.throwStatement(t.newExpression(t.identifier('Error'), [t.stringLiteral('Query Service not initialized')]))), t.returnStatement(t.callExpression(t.memberExpression(t.identifier('queryService'), t.identifier(name)), [t.identifier('request')]))])), t.identifier('options')], t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(responseType)), t.tsTypeReference(t.identifier('Error')), t.tsTypeReference(t.identifier('TData'))])))]), null, false, (0, _utils.tsTypeParameterDeclaration)([t.tsTypeParameter(null, t.tsTypeReference(t.identifier(responseType)), 'TData')])))]);
};

var rpcHookMethodInterface = function rpcHookMethodInterface(context, name, svc) {
  var _svc$fields2;

  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var fieldNames = Object.keys((_svc$fields2 = svc.fields) !== null && _svc$fields2 !== void 0 ? _svc$fields2 : {});
  var hasParams = fieldNames.length > 0;
  var optional = false; // // if no params, then let's default to empty object for cleaner API

  if (!hasParams) {
    optional = true;
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    optional = true;
  }

  context.addUtil('ReactQueryParams');
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(makeUseHookTypeName(name)), t.tsTypeParameterDeclaration([t.tsTypeParameter(null, null, 'TData')]), [t.tsExpressionWithTypeArguments(t.identifier('ReactQueryParams'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(responseType)), t.tsTypeReference(t.identifier('TData'))]))], t.tsInterfaceBody([(0, _utils.tsPropertySignature)(t.identifier('request'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier(requestType))), optional)])));
};

var createRpcQueryHooks = function createRpcQueryHooks(context, service) {
  var _service$methods, _service$methods2;

  context.addUtil('QueryClient');
  context.addUtil('createProtobufRpcClient');
  context.addUtil('ProtobufRpcClient');
  var camelRpcMethods = context.pluginValue('rpcClients.camelCase'); // const name = service.name + 'ClientImpl';
  // const implementsName = service.name;
  // const methodNames = Object.keys(service.methods ?? {})
  //     .map(key => {
  //         return camelRpcMethods ? camel(key) : key
  //     });

  var methods = Object.keys((_service$methods = service.methods) !== null && _service$methods !== void 0 ? _service$methods : {}).map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    return rpcHookMethod(context, name, method);
  });
  var methodNames = Object.keys((_service$methods2 = service.methods) !== null && _service$methods2 !== void 0 ? _service$methods2 : {}).map(function (key) {
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    return {
      name: name,
      comment: service.methods[key].comment
    };
  });
  return t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier('createRpcQueryHooks'), t.arrowFunctionExpression([(0, _utils.identifier)('rpc', t.tsTypeAnnotation(t.tsUnionType([t.tsTypeReference(t.identifier('ProtobufRpcClient')), t.tsUndefinedKeyword()])))], // body
  t.blockStatement([// query service
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('queryService'), t.callExpression(t.identifier('getQueryService'), [t.identifier('rpc')]))])].concat((0, _toConsumableArray2["default"])(methods), [// return the methods...
  t.returnStatement(t.objectExpression(methodNames.map(function (_ref) {
    var name = _ref.name,
        comment = _ref.comment;
    return (0, _utils.objectProperty)(t.identifier(makeUseHookName(name)), t.identifier(makeUseHookName(name)), false, true, null, (0, _utils.makeCommentLineWithBlocks)(comment));
  })))])) // end body
  ))]));
};

exports.createRpcQueryHooks = createRpcQueryHooks;

var createRpcQueryHookInterfaces = function createRpcQueryHookInterfaces(context, service) {
  var _service$methods3;

  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var methods = Object.keys((_service$methods3 = service.methods) !== null && _service$methods3 !== void 0 ? _service$methods3 : {}).map(function (key) {
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    var method = service.methods[key];
    return {
      name: name,
      method: method
    };
  });
  return methods.map(function (method) {
    return rpcHookMethodInterface(context, method.name, method.method);
  });
};

exports.createRpcQueryHookInterfaces = createRpcQueryHookInterfaces;

var createRpcQueryHookClientMap = function createRpcQueryHookClientMap(context, service) {
  var name = service.name + 'ClientImpl';
  return (0, _weakMap.createClientMap)(name);
};

exports.createRpcQueryHookClientMap = createRpcQueryHookClientMap;