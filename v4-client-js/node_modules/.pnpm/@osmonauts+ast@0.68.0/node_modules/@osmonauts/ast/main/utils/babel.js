"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classMethod = exports.classDeclaration = exports.callExpression = exports.arrowFunctionExpression = void 0;
exports.classProperty = classProperty;
exports.tsEnumMember = exports.objectProperty = exports.objectPattern = exports.objectMethod = exports.makeCommentLineWithBlocks = exports.identifier = exports.functionDeclaration = exports.commentLine = exports.commentBlock = void 0;
exports.tsMethodSignature = tsMethodSignature;
exports.tsTypeParameterDeclaration = exports.tsPropertySignature = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("./utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// TODO move to @osmonauts/utils package
var commentBlock = function commentBlock(value) {
  return {
    type: 'CommentBlock',
    value: value,
    start: null,
    end: null,
    loc: null
  };
};

exports.commentBlock = commentBlock;

var commentLine = function commentLine(value) {
  return {
    type: 'CommentLine',
    value: value,
    start: null,
    end: null,
    loc: null
  };
};

exports.commentLine = commentLine;

function tsMethodSignature(key) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var parameters = arguments.length > 2 ? arguments[2] : undefined;
  var typeAnnotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var trailingComments = arguments.length > 4 ? arguments[4] : undefined;
  var leadingComments = arguments.length > 5 ? arguments[5] : undefined;
  var obj = t.tsMethodSignature(key, typeParameters, parameters, typeAnnotation);
  obj.kind = 'method';

  if (trailingComments && trailingComments.length) {
    obj.trailingComments = trailingComments;
  }

  if (leadingComments && leadingComments.length) {
    obj.leadingComments = leadingComments;
  }

  return obj;
}

var classMethod = function classMethod(kind, key, params, body, returnType) {
  var leadingComments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
  var computed = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

  var _static = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

  var generator = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var async = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var obj = t.classMethod(kind, key, params, body, computed, _static, generator, async);

  if (returnType) {
    obj.returnType = returnType;
  }

  if (leadingComments) {
    obj.leadingComments = leadingComments;
  }

  return obj;
};

exports.classMethod = classMethod;

var tsEnumMember = function tsEnumMember(id, initializer, leadingComments) {
  var obj = t.tsEnumMember(id, initializer);
  obj.leadingComments = leadingComments;
  return obj;
};

exports.tsEnumMember = tsEnumMember;

var tsPropertySignature = function tsPropertySignature(key, typeAnnotation, optional) {
  var obj = t.tsPropertySignature(key, typeAnnotation);
  obj.optional = optional;
  return obj;
};

exports.tsPropertySignature = tsPropertySignature;

var functionDeclaration = function functionDeclaration(id, params, body, generator, async, returnType) {
  var func = t.functionDeclaration(id, params, body, generator, async);
  func.returnType = returnType;
  return func;
};

exports.functionDeclaration = functionDeclaration;

var callExpression = function callExpression(callee, _arguments, typeParameters) {
  var callExpr = t.callExpression(callee, _arguments);
  callExpr.typeParameters = typeParameters;
  return callExpr;
};

exports.callExpression = callExpression;

var identifier = function identifier(name, typeAnnotation) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var type = t.identifier(name);
  type.typeAnnotation = typeAnnotation;
  type.optional = optional;
  return type;
};

exports.identifier = identifier;

var classDeclaration = function classDeclaration(id) {
  var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var vImplements = arguments.length > 4 ? arguments[4] : undefined;
  var obj = t.classDeclaration(id, superClass, body, decorators);

  if (vImplements) {
    obj["implements"] = vImplements;
  }

  return obj;
};

exports.classDeclaration = classDeclaration;

function classProperty(key) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  var _readonly = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

  var accessibility = arguments.length > 7 ? arguments[7] : undefined;
  var leadingComments = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
  var obj = t.classProperty(key, value, typeAnnotation, decorators, computed, _static);
  if (accessibility) obj.accessibility = accessibility;
  if (_readonly) obj.readonly = _readonly;
  if (leadingComments.length) obj.leadingComments = leadingComments;
  return obj;
}

;

var arrowFunctionExpression = function arrowFunctionExpression(params, body, returnType) {
  var isAsync = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var typeParameters = arguments.length > 4 ? arguments[4] : undefined;
  var func = t.arrowFunctionExpression(params, body, isAsync);
  func.returnType = returnType;
  func.typeParameters = typeParameters;
  return func;
};

exports.arrowFunctionExpression = arrowFunctionExpression;

var tsTypeParameterDeclaration = function tsTypeParameterDeclaration(params) {
  var obj = t.tsTypeParameterDeclaration(params);
  delete obj.extra;
  return obj;
};

exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;

var objectPattern = function objectPattern(properties, typeAnnotation) {
  var obj = t.objectPattern(properties);
  obj.typeAnnotation = typeAnnotation;
  return obj;
};

exports.objectPattern = objectPattern;

var objectMethod = function objectMethod(kind, key, params, body, computed, generator, async, returnType, typeParameters) {
  var obj = t.objectMethod(kind, key, params, body, computed, generator, async);
  obj.returnType = returnType;
  obj.typeParameters = typeParameters;
  return obj;
};

exports.objectMethod = objectMethod;

var objectProperty = function objectProperty(key, value, computed, shorthand, decorators) {
  var leadingComments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
  var obj = t.objectProperty(key, value, computed, shorthand, decorators);
  if (leadingComments.length) obj.leadingComments = leadingComments;
  return obj;
};

exports.objectProperty = objectProperty;

var makeCommentLineWithBlocks = function makeCommentLineWithBlocks(comment) {
  if (!comment) return []; // NOTE using blocks instead of lines here...
  // @ts-ignore

  return [(0, _utils.makeCommentBlock)(comment)];
};

exports.makeCommentLineWithBlocks = makeCommentLineWithBlocks;