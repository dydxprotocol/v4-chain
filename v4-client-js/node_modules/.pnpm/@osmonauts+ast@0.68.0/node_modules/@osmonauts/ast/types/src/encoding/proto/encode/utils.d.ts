import * as t from '@babel/types';
import { EncodeMethod } from './index';
import { ProtoParseContext } from '../../context';
import { ProtoField } from '@osmonauts/types';
export declare const encode: {
    string(args: EncodeMethod): t.IfStatement;
    double(args: EncodeMethod): t.IfStatement;
    float(args: EncodeMethod): t.IfStatement;
    int32(args: EncodeMethod): t.IfStatement;
    sint32(args: EncodeMethod): t.IfStatement;
    uint32(args: EncodeMethod): t.IfStatement;
    fixed32(args: EncodeMethod): t.IfStatement;
    sfixed32(args: EncodeMethod): t.IfStatement;
    int64(args: EncodeMethod): t.IfStatement;
    sint64(args: EncodeMethod): t.IfStatement;
    uint64(args: EncodeMethod): t.IfStatement;
    fixed64(args: EncodeMethod): t.IfStatement;
    sfixed64(args: EncodeMethod): t.IfStatement;
    bool(args: EncodeMethod): t.IfStatement;
    type(args: EncodeMethod): t.IfStatement;
    enum(args: EncodeMethod): t.IfStatement;
    bytes(args: EncodeMethod): t.IfStatement;
    timestamp(args: EncodeMethod): t.Statement;
    duration(args: EncodeMethod): t.IfStatement;
    forkDelimArray(args: EncodeMethod, expr: t.Statement): (t.ExpressionStatement | t.ForOfStatement)[];
    array(args: EncodeMethod, expr: t.Statement): t.ForOfStatement[];
    typeArray(args: EncodeMethod): t.ForOfStatement[];
    keyHash(args: EncodeMethod): t.ExpressionStatement;
};
export declare const types: {
    string(num: number, prop: string, isOptional: boolean): t.IfStatement;
    double(num: number, prop: string, isOptional: boolean): t.IfStatement;
    float(num: number, prop: string, isOptional: boolean): t.IfStatement;
    int32(num: number, prop: string, isOptional: boolean): t.IfStatement;
    sint32(num: number, prop: string, isOptional: boolean): t.IfStatement;
    uint32(num: number, prop: string, isOptional: boolean): t.IfStatement;
    fixed32(num: number, prop: string, isOptional: boolean): t.IfStatement;
    sfixed32(num: number, prop: string, isOptional: boolean): t.IfStatement;
    int64(num: number, prop: string, isOptional: boolean): t.IfStatement;
    sint64(num: number, prop: string, isOptional: boolean): t.IfStatement;
    uint64(num: number, prop: string, isOptional: boolean): t.IfStatement;
    fixed64(num: number, prop: string, isOptional: boolean): t.IfStatement;
    sfixed64(num: number, prop: string, isOptional: boolean): t.IfStatement;
    bool(num: number, prop: string, isOptional: boolean): t.IfStatement;
    type(num: number, prop: string, name: string): t.IfStatement;
    enum(context: ProtoParseContext, num: number, field: ProtoField, isOptional: boolean, isOneOf: boolean): t.IfStatement;
    bytes(num: number, prop: string, isOptional: boolean): t.IfStatement;
    timestamp(num: number, prop: string): t.Statement;
    timestampDate(num: number, prop: string): t.Statement;
    duration(num: number, prop: string): t.IfStatement;
    forkDelimArray(num: number, prop: string, expr: t.Statement): (t.ExpressionStatement | t.ForOfStatement)[];
    array(num: number, prop: string, expr: t.Statement): t.ForOfStatement[];
    typeArray(num: number, prop: string, name: string): t.ForOfStatement[];
    keyHash(num: number, prop: string, name: string): t.ExpressionStatement;
};
export declare const arrayTypes: {
    double(): t.ExpressionStatement;
    bool(): t.ExpressionStatement;
    float(): t.ExpressionStatement;
    int32(): t.ExpressionStatement;
    sint32(): t.ExpressionStatement;
    uint32(): t.ExpressionStatement;
    fixed32(): t.ExpressionStatement;
    sfixed32(): t.ExpressionStatement;
    int64(): t.ExpressionStatement;
    sint64(): t.ExpressionStatement;
    uint64(): t.ExpressionStatement;
    fixed64(): t.ExpressionStatement;
    sfixed64(): t.ExpressionStatement;
    string(args: EncodeMethod): t.ExpressionStatement;
    bytes(args: EncodeMethod): t.ExpressionStatement;
    enum(): t.ExpressionStatement;
};
