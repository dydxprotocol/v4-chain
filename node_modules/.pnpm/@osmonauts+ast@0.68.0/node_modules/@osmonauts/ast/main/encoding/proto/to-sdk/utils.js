"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSDK = exports.arrayTypes = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

var _types2 = require("../../types");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var notUndefinedSetValue = function notUndefinedSetValue(sdkName, msgName, expr) {
  return t.expressionStatement(t.logicalExpression('&&', t.binaryExpression('!==', t.memberExpression(t.identifier('message'), t.identifier(msgName)), t.identifier('undefined')), t.assignmentExpression('=', t.memberExpression(t.identifier('obj'), t.identifier(sdkName)), expr)));
};

var toSDK = {
  scalar: function scalar(args) {
    var _getFieldNames = (0, _types2.getFieldNames)(args.field),
        propName = _getFieldNames.propName,
        origName = _getFieldNames.origName;

    return notUndefinedSetValue(origName, propName, t.memberExpression(t.identifier('message'), t.identifier(propName)));
  },
  string: function string(args) {
    return toSDK.scalar(args);
  },
  "double": function double(args) {
    return toSDK.scalar(args);
  },
  "float": function float(args) {
    return toSDK.scalar(args);
  },
  bool: function bool(args) {
    return toSDK.scalar(args);
  },
  number: function number(args) {
    return toSDK.scalar(args);
  },
  int32: function int32(args) {
    return toSDK.scalar(args);
  },
  uint32: function uint32(args) {
    return toSDK.scalar(args);
  },
  sint32: function sint32(args) {
    return toSDK.scalar(args);
  },
  fixed32: function fixed32(args) {
    return toSDK.scalar(args);
  },
  sfixed32: function sfixed32(args) {
    return toSDK.scalar(args);
  },
  "long": function long(args) {
    return toSDK.scalar(args);
  },
  int64: function int64(args) {
    return toSDK.scalar(args);
  },
  uint64: function uint64(args) {
    return toSDK.scalar(args);
  },
  sint64: function sint64(args) {
    return toSDK.scalar(args);
  },
  fixed64: function fixed64(args) {
    return toSDK.scalar(args);
  },
  sfixed64: function sfixed64(args) {
    return toSDK.scalar(args);
  },
  type: function type(args) {
    var _getFieldNames2 = (0, _types2.getFieldNames)(args.field),
        propName = _getFieldNames2.propName,
        origName = _getFieldNames2.origName;

    var name = args.context.getTypeName(args.field); // TODO isn't the nested conditional a waste? (using ts-proto as reference)
    // maybe null is OK?

    return notUndefinedSetValue(origName, propName, t.conditionalExpression(t.memberExpression(t.identifier('message'), t.identifier(propName)), t.callExpression(t.memberExpression(t.identifier(name), t.identifier('toSDK')), [t.memberExpression(t.identifier('message'), t.identifier(propName))]), t.identifier('undefined')));
  },
  "enum": function _enum(args) {
    var _getFieldNames3 = (0, _types2.getFieldNames)(args.field),
        propName = _getFieldNames3.propName,
        origName = _getFieldNames3.origName;

    var enumFuncName = args.context.getToEnum(args.field);
    return notUndefinedSetValue(origName, propName, t.callExpression(t.identifier(enumFuncName), [t.memberExpression(t.identifier('message'), t.identifier(propName))]));
  },
  bytes: function bytes(args) {
    return toSDK.scalar(args);
  },
  duration: function duration(args) {
    return toSDK.type(args);
  },
  timestamp: function timestamp(args) {
    return toSDK.type(args);
  },
  keyHash: function keyHash(args) {
    var _getFieldNames4 = (0, _types2.getFieldNames)(args.field),
        propName = _getFieldNames4.propName,
        origName = _getFieldNames4.origName;

    var keyType = args.field.keyType;
    var valueType = args.field.parsedType.name;
    var toSDK = null;

    switch (valueType) {
      case 'string':
        toSDK = t.identifier('v');
        break;

      case 'uint32':
      case 'int32':
        toSDK = t.callExpression(t.memberExpression(t.identifier('Math'), t.identifier('round')), [t.identifier('v')]);
        break;

      case 'int64':
      case 'uint64':
        toSDK = t.callExpression(t.memberExpression(t.identifier('v'), t.identifier('toString')), []);
        break;

      default:
        toSDK = t.callExpression(t.memberExpression(t.identifier(valueType), t.identifier('toSDK')), [t.identifier('v')]);
    }

    return [t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('obj'), t.identifier(origName)), t.objectExpression([]))), //
    t.ifStatement(t.memberExpression(t.identifier('message'), t.identifier(propName)), t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('entries')), [t.memberExpression(t.identifier('message'), t.identifier(propName))]), t.identifier('forEach')), [t.arrowFunctionExpression([t.arrayPattern([t.identifier('k'), t.identifier('v')])], t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.memberExpression(t.identifier('obj'), t.identifier(origName)), t.identifier('k'), true), toSDK))]))]))]))];
  },
  array: function array(args, expr) {
    var _getFieldNames5 = (0, _types2.getFieldNames)(args.field),
        propName = _getFieldNames5.propName,
        origName = _getFieldNames5.origName;

    return t.ifStatement(t.memberExpression(t.identifier('message'), t.identifier(propName)), t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('obj'), t.identifier(origName)), t.callExpression(t.memberExpression(t.memberExpression(t.identifier('message'), t.identifier(propName)), t.identifier('map')), [t.arrowFunctionExpression([t.identifier('e')], expr)])))]), t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('obj'), t.identifier(origName)), t.arrayExpression([])))]));
  }
};
exports.toSDK = toSDK;
var arrayTypes = {
  scalar: function scalar() {
    return t.identifier('e');
  },
  string: function string() {
    return arrayTypes.scalar();
  },
  "double": function double() {
    return arrayTypes.scalar();
  },
  "float": function float() {
    return arrayTypes.scalar();
  },
  bool: function bool() {
    return arrayTypes.scalar();
  },
  number: function number() {
    return arrayTypes.scalar();
  },
  int32: function int32() {
    return arrayTypes.number();
  },
  uint32: function uint32() {
    return arrayTypes.number();
  },
  sint32: function sint32() {
    return arrayTypes.number();
  },
  fixed32: function fixed32() {
    return arrayTypes.number();
  },
  sfixed32: function sfixed32() {
    return arrayTypes.number();
  },
  "long": function long(args) {
    return arrayTypes.scalar();
  },
  int64: function int64(args) {
    return arrayTypes["long"](args);
  },
  uint64: function uint64(args) {
    return arrayTypes["long"](args);
  },
  sint64: function sint64(args) {
    return arrayTypes["long"](args);
  },
  fixed64: function fixed64(args) {
    return arrayTypes["long"](args);
  },
  sfixed64: function sfixed64(args) {
    return arrayTypes["long"](args);
  },
  bytes: function bytes(args) {
    return arrayTypes.scalar();
  },
  "enum": function _enum(args) {
    var enumFuncName = args.context.getToEnum(args.field);
    return t.callExpression(t.identifier(enumFuncName), [t.identifier('e')]);
  },
  type: function type(args) {
    var name = args.context.getTypeName(args.field);
    return t.conditionalExpression(t.identifier('e'), t.callExpression(t.memberExpression(t.identifier(name), t.identifier('toSDK')), [t.identifier('e')]), t.identifier('undefined'));
  }
};
exports.arrayTypes = arrayTypes;