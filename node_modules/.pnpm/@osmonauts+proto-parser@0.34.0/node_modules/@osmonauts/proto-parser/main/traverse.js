"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverse = exports.recursiveTraversal = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _protobufjs = require("@pyramation/protobufjs");

var _lookup = require("./lookup");

var _services = require("./services");

var _utils = require("./utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var traverse = function traverse(store, ref) {
  var imports = {};
  var exports = {};
  var obj = {
    imports: ref.proto.imports,
    "package": ref.proto["package"],
    root: recursiveTraversal(store, ref, ref.proto.root, imports, exports, [], false),
    parsedImports: null,
    parsedExports: null,
    importNames: null
  };
  obj.parsedImports = imports;
  obj.parsedExports = exports;
  var counter = 1;
  obj.importNames = Object.entries(imports).reduce(function (m, _ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        path = _ref2[0],
        names = _ref2[1];

    m[path] = m[path] || {};
    names.forEach(function (importName) {
      var hasConflict = Object.entries(imports).some(function (_ref3) {
        var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
            otherPath = _ref4[0],
            otherNames = _ref4[1];

        if (path === otherPath) return false;
        if (otherNames.includes(importName)) return true;
      });

      if (hasConflict || exports.hasOwnProperty(importName)) {
        m[path][importName] = importName + counter++;
      } else {
        m[path][importName] = importName;
      }
    });
    return m;
  }, {}); // just bc devs use proto syntax for types in the same file
  // does not mean we need to import them
  // delete any imports related to "this" file

  delete obj.importNames[ref.filename];
  delete obj.parsedImports[ref.filename];
  return obj;
};

exports.traverse = traverse;

var getAllRefs = function getAllRefs(store, ref) {
  var _ref$proto$imports$ma, _ref$proto$imports;

  var importRefs = (_ref$proto$imports$ma = (_ref$proto$imports = ref.proto.imports) === null || _ref$proto$imports === void 0 ? void 0 : _ref$proto$imports.map(function (imp) {
    return store.findProto(imp);
  })) !== null && _ref$proto$imports$ma !== void 0 ? _ref$proto$imports$ma : [];
  return importRefs.reduce(function (m, v) {
    return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(getAllRefs(store, v)));
  }, importRefs);
};

var traverseFields = function traverseFields(store, ref, obj, imports, traversal) {
  return Object.keys(obj.fields).reduce(function (m, mykey) {
    var field = obj.fields[mykey];
    var fieldName = mykey;
    var regexp = /([a-zA-Z0-9]+)[_]+([0-9]+)$/;

    if (regexp.test(fieldName)) {
      var matches = fieldName.match(regexp);

      if (matches !== null && matches !== void 0 && matches.length) {
        var begin = fieldName.split(matches[1])[0];
        fieldName = "".concat(begin).concat(matches[1]).concat(matches[2]);
      }
    }

    var serialize = function serialize() {
      if (typeof field.toJSON !== 'undefined') {
        // non-traversed
        return field.toJSON({
          keepComments: true
        });
      } // traversed
      // field.name is used for proto!


      field.name = fieldName;
      return field;
    };

    var found = null;

    if (_utils.SCALAR_TYPES.includes(field.type)) {
      m[fieldName] = _objectSpread({
        parsedType: {
          name: field.type,
          type: 'native'
        },
        isScalar: true,
        typeNum: _utils.SCALAR_TYPES.indexOf(field.type)
      }, serialize());
      return m;
    } // nested scope first


    found = (0, _lookup.lookupNested)(ref, traversal, field.type);

    if (found) {
      m[fieldName] = _objectSpread({
        scope: found.scope,
        parsedType: (0, _utils.instanceType)(found)
      }, serialize());
      return m;
    } // local scope second


    found = (0, _lookup.lookup)(store, ref, field.type);

    if (found) {
      m[fieldName] = _objectSpread({
        scope: found.scope,
        parsedType: (0, _utils.instanceType)(found)
      }, serialize());
      return m;
    }

    found = (0, _lookup.importLookup)(store, ref, field.type);

    if (found) {
      imports[found["import"]] = imports[found["import"]] || [];
      imports[found["import"]] = (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(imports[found["import"]]), [found.name])));
      m[fieldName] = _objectSpread(_objectSpread({
        parsedType: (0, _utils.instanceType)(found.obj),
        scopeType: 'import',
        scope: [found.obj.scope]
      }, serialize()), {}, {
        importedName: found.importedName,
        "import": found["import"]
      });
      return m;
    } // found = protoImportLookup(store, ref, field.type);
    // if (found) {
    //     imports[found.import] = imports[found.import] || [];
    //     imports[found.import] = [...new Set([...imports[found.import], found.name])];
    //     m[fieldName] = {
    //         parsedType: instanceType(found.obj),
    //         scopeType: 'protoImport',
    //         scope: [found.package],
    //         ...serialize(),
    //         importedName: found.importedName,
    //         import: found.import,
    //     };
    //     return m;
    // }
    // new scope lookup (TODO: replace above cases)


    var typeNames = (0, _utils.lookupSymbolScopes)(field.type, ref.proto["package"] + '.dummy');

    var _iterator = _createForOfIteratorHelper(typeNames),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var lookupType = _step.value;
        found = (0, _lookup.protoScopeImportLookup)(store, ref, lookupType);

        if (found) {
          imports[found["import"]] = imports[found["import"]] || [];
          imports[found["import"]] = (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(imports[found["import"]]), [found.name])));
          m[fieldName] = _objectSpread(_objectSpread({
            parsedType: (0, _utils.instanceType)(found.obj),
            scopeType: 'protoImport',
            scope: found.obj.scope ? found.obj.scope : [found["package"]]
          }, serialize()), {}, {
            importedName: found.importedName,
            "import": found["import"]
          });
          return m;
        }
      } // e.g. akash/deployment/v1beta2/service.proto
      // referencing messages in another file, and so we need access through our imports
      // if we get this issue again, this should be recursive and not just one level...

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var importRefs = ref.proto.imports.map(function (imp) {
      return store.findProto(imp);
    }); // const importRefs = getAllRefs(store, ref);

    var _iterator2 = _createForOfIteratorHelper(importRefs),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var importRef = _step2.value;

        var _typeNames = (0, _utils.lookupSymbolScopes)(field.type, importRef.proto["package"] + '.dummy');

        var _iterator3 = _createForOfIteratorHelper(_typeNames),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _lookupType = _step3.value;
            found = (0, _lookup.protoScopeImportLookup)(store, importRef, _lookupType);

            if (found) {
              imports[found["import"]] = imports[found["import"]] || [];
              imports[found["import"]] = (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(imports[found["import"]]), [found.name])));
              m[fieldName] = _objectSpread(_objectSpread({
                parsedType: (0, _utils.instanceType)(found.obj),
                scopeType: 'protoImport',
                scope: found.obj.scope ? found.obj.scope : [found["package"]]
              }, serialize()), {}, {
                importedName: found.importedName,
                "import": found["import"]
              });
              return m;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    console.warn("\n".concat(obj.name, ".").concat(field.name, ": ").concat(field.type, " NOT FOUND from ").concat(ref.filename, " in ").concat(ref.proto["package"], "\nyou should contact the maintainers.\n"));
    return m;
  }, {});
};

var traverseType = function traverseType(store, ref, obj, imports, exports, traversal, isNested) {
  var nested = null;

  if (obj.nested) {
    nested = Object.keys(obj.nested).reduce(function (m, key) {
      m[key] = recursiveTraversal(store, ref, obj.nested[key], imports, exports, [].concat((0, _toConsumableArray2["default"])(traversal), [key]), true);
      return m;
    }, {});
  }

  if (!isNested) {
    exports[obj.name] = exports[obj.name] || [];
    exports[obj.name] = true;
  }

  var traversed = {
    type: 'Type',
    name: obj.name,
    options: obj.options,
    oneofs: obj.oneofs ? Object.keys(obj.oneofs).reduce(function (m, v) {
      m[v] = {
        // parse oneof
        oneof: obj.oneofs[v].oneof.map(function (name) {
          return name;
        })
      };
      return m;
    }, {}) : undefined,
    fields: traverseFields(store, ref, obj, imports, traversal),
    nested: nested,
    keyTypes: [],
    comment: obj.comment
  }; // parse keyType

  var hasKeyType = Object.keys(traversed.fields).some(function (field) {
    return !!traversed.fields[field].keyType;
  });
  var keyTypes = [];

  if (hasKeyType) {
    keyTypes = Object.keys(traversed.fields).filter(function (field) {
      return !!traversed.fields[field].keyType;
    }).map(function (field) {
      return _objectSpread({
        name: field
      }, traversed.fields[field]);
    });
  }

  traversed.keyTypes = keyTypes;
  return traversed;
};

var traverseEnum = function traverseEnum(store, ref, obj, imports) {
  return _objectSpread({
    type: 'Enum',
    name: obj.name
  }, obj.toJSON({
    keepComments: true
  }));
};

var traverseField = function traverseField(store, ref, obj, imports) {
  return _objectSpread({
    // type is already a property on field
    name: obj.name
  }, obj.toJSON({
    keepComments: true
  }));
};

var traverseServiceMethod = function traverseServiceMethod(store, ref, obj, imports, name, traversal) {
  var service = obj.methods[name];
  var requestType = service.requestType,
      responseType = service.responseType,
      options = service.options,
      comment = service.comment;
  var responseObject = (0, _lookup.lookupAny)(store, ref, requestType);

  if (!responseObject) {
    throw new Error('Symbol not found ' + requestType);
  }

  var requestObject = (0, _lookup.lookupAny)(store, ref, requestType);

  if (!requestObject) {
    throw new Error('Symbol not found ' + requestType);
  }

  var fields = traverseFields(store, ref, requestObject.obj, imports, traversal);
  var info = (0, _services.parseService)({
    options: options,
    fields: fields
  });
  var svc = {
    type: 'ServiceMethod',
    info: info,
    name: name,
    comment: comment,
    requestType: requestType,
    responseType: responseType,
    options: options,
    fields: fields
  };

  if (info) {
    // TODO is this still needed?
    // get casing info for request objects
    Object.keys(requestObject.obj.fields).map(function (fieldName) {
      var field = requestObject.obj.fields[fieldName];
      var protoCasing = store.options.prototypes.parser.keepCase ? field.options['(telescope:orig)'] : field.options['(telescope:camel)'];
      var origCase = field.options['(telescope:orig)'];
      svc.info.casing = svc.info.casing || {};
      svc.info.casing[origCase] = protoCasing;
    });
  }

  store.registerRequest(svc);
  return svc;
};

var traverseService = function traverseService(store, ref, obj, imports, traversal) {
  var json = obj.toJSON({
    keepComments: true
  });
  var methods = Object.keys(json.methods).reduce(function (m, key) {
    m[key] = traverseServiceMethod(store, ref, json, imports, key, traversal);
    return m;
  }, {});
  return _objectSpread(_objectSpread({
    type: 'Service',
    name: obj.name
  }, obj.toJSON({
    keepComments: true
  })), {}, {
    methods: methods
  });
};

var recursiveTraversal = function recursiveTraversal(store, ref, obj, imports, exports, traversal, isNested) {
  if (obj instanceof _protobufjs.Type) {
    return traverseType(store, ref, obj, imports, exports, traversal, isNested);
  }

  if (obj instanceof _protobufjs.Enum) {
    return traverseEnum(store, ref, obj, imports);
  }

  if (obj instanceof _protobufjs.Service) {
    return traverseService(store, ref, obj, imports, traversal);
  }

  if (obj instanceof _protobufjs.Field) {
    return traverseField(store, ref, obj, imports);
  }

  if (obj instanceof _protobufjs.Root) {
    if (obj.nested) {
      return Object.keys(obj.nested).reduce(function (m, key) {
        m.nested[key] = recursiveTraversal(store, ref, obj.nested[key], imports, exports, [].concat((0, _toConsumableArray2["default"])(traversal), [key]), isNested);
        return m;
      }, {
        type: 'Root',
        nested: {}
      });
    } else {
      throw new Error('recursiveTraversal() [Root] cannot find protobufjs Type');
    }
  }

  if (obj instanceof _protobufjs.Namespace) {
    if (obj.nested) {
      return Object.keys(obj.nested).reduce(function (m, key) {
        m.nested[key] = recursiveTraversal(store, ref, obj.nested[key], imports, exports, [].concat((0, _toConsumableArray2["default"])(traversal), [key]), isNested);
        return m;
      }, {
        type: 'Namespace',
        nested: {}
      });
    } else {
      throw new Error('recursiveTraversal() [Namespace] cannot find protobufjs Type');
    }
  }

  throw new Error('recursiveTraversal() cannot find protobufjs Type');
};

exports.recursiveTraversal = recursiveTraversal;